// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file hangouts.proto

import Foundation


public func == (lhs: DoNotDisturbSetting, rhs: DoNotDisturbSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDoNotDisturb == rhs.hasDoNotDisturb) && (!lhs.hasDoNotDisturb || lhs.doNotDisturb == rhs.doNotDisturb)
  fieldCheck = fieldCheck && (lhs.hasExpirationTimestamp == rhs.hasExpirationTimestamp) && (!lhs.hasExpirationTimestamp || lhs.expirationTimestamp == rhs.expirationTimestamp)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NotificationSettings, rhs: NotificationSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDndSettings == rhs.hasDndSettings) && (!lhs.hasDndSettings || lhs.dndSettings == rhs.dndSettings)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationId, rhs: ConversationId) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ParticipantId, rhs: ParticipantId) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGaiaId == rhs.hasGaiaId) && (!lhs.hasGaiaId || lhs.gaiaId == rhs.gaiaId)
  fieldCheck = fieldCheck && (lhs.hasChatId == rhs.hasChatId) && (!lhs.hasChatId || lhs.chatId == rhs.chatId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeviceStatus, rhs: DeviceStatus) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMobile == rhs.hasMobile) && (!lhs.hasMobile || lhs.mobile == rhs.mobile)
  fieldCheck = fieldCheck && (lhs.hasDesktop == rhs.hasDesktop) && (!lhs.hasDesktop || lhs.desktop == rhs.desktop)
  fieldCheck = fieldCheck && (lhs.hasTablet == rhs.hasTablet) && (!lhs.hasTablet || lhs.tablet == rhs.tablet)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: LastSeen, rhs: LastSeen) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLastSeenTimestampUsec == rhs.hasLastSeenTimestampUsec) && (!lhs.hasLastSeenTimestampUsec || lhs.lastSeenTimestampUsec == rhs.lastSeenTimestampUsec)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Presence, rhs: Presence) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasReachable == rhs.hasReachable) && (!lhs.hasReachable || lhs.reachable == rhs.reachable)
  fieldCheck = fieldCheck && (lhs.hasAvailable == rhs.hasAvailable) && (!lhs.hasAvailable || lhs.available == rhs.available)
  fieldCheck = fieldCheck && (lhs.hasDeviceStatus == rhs.hasDeviceStatus) && (!lhs.hasDeviceStatus || lhs.deviceStatus == rhs.deviceStatus)
  fieldCheck = fieldCheck && (lhs.hasMoodMessage == rhs.hasMoodMessage) && (!lhs.hasMoodMessage || lhs.moodMessage == rhs.moodMessage)
  fieldCheck = fieldCheck && (lhs.hasLastSeen == rhs.hasLastSeen) && (!lhs.hasLastSeen || lhs.lastSeen == rhs.lastSeen)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PresenceResult, rhs: PresenceResult) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasPresence == rhs.hasPresence) && (!lhs.hasPresence || lhs.presence == rhs.presence)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ClientIdentifier, rhs: ClientIdentifier) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResource == rhs.hasResource) && (!lhs.hasResource || lhs.resource == rhs.resource)
  fieldCheck = fieldCheck && (lhs.hasHeaderId == rhs.hasHeaderId) && (!lhs.hasHeaderId || lhs.headerId == rhs.headerId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ClientPresenceState, rhs: ClientPresenceState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasIdentifier == rhs.hasIdentifier) && (!lhs.hasIdentifier || lhs.identifier == rhs.identifier)
  fieldCheck = fieldCheck && (lhs.hasState == rhs.hasState) && (!lhs.hasState || lhs.state == rhs.state)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserEventState, rhs: UserEventState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasClientGeneratedId == rhs.hasClientGeneratedId) && (!lhs.hasClientGeneratedId || lhs.clientGeneratedId == rhs.clientGeneratedId)
  fieldCheck = fieldCheck && (lhs.hasNotificationLevel == rhs.hasNotificationLevel) && (!lhs.hasNotificationLevel || lhs.notificationLevel == rhs.notificationLevel)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Formatting, rhs: Formatting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBold == rhs.hasBold) && (!lhs.hasBold || lhs.bold == rhs.bold)
  fieldCheck = fieldCheck && (lhs.hasItalic == rhs.hasItalic) && (!lhs.hasItalic || lhs.italic == rhs.italic)
  fieldCheck = fieldCheck && (lhs.hasStrikethrough == rhs.hasStrikethrough) && (!lhs.hasStrikethrough || lhs.strikethrough == rhs.strikethrough)
  fieldCheck = fieldCheck && (lhs.hasUnderline == rhs.hasUnderline) && (!lhs.hasUnderline || lhs.underline == rhs.underline)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: LinkData, rhs: LinkData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLinkTarget == rhs.hasLinkTarget) && (!lhs.hasLinkTarget || lhs.linkTarget == rhs.linkTarget)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Segment, rhs: Segment) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasText == rhs.hasText) && (!lhs.hasText || lhs.text == rhs.text)
  fieldCheck = fieldCheck && (lhs.hasFormatting == rhs.hasFormatting) && (!lhs.hasFormatting || lhs.formatting == rhs.formatting)
  fieldCheck = fieldCheck && (lhs.hasLinkData == rhs.hasLinkData) && (!lhs.hasLinkData || lhs.linkData == rhs.linkData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PlusPhoto, rhs: PlusPhoto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasThumbnail == rhs.hasThumbnail) && (!lhs.hasThumbnail || lhs.thumbnail == rhs.thumbnail)
  fieldCheck = fieldCheck && (lhs.hasOwnerObfuscatedId == rhs.hasOwnerObfuscatedId) && (!lhs.hasOwnerObfuscatedId || lhs.ownerObfuscatedId == rhs.ownerObfuscatedId)
  fieldCheck = fieldCheck && (lhs.hasAlbumId == rhs.hasAlbumId) && (!lhs.hasAlbumId || lhs.albumId == rhs.albumId)
  fieldCheck = fieldCheck && (lhs.hasPhotoId == rhs.hasPhotoId) && (!lhs.hasPhotoId || lhs.photoId == rhs.photoId)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = fieldCheck && (lhs.hasOriginalContentUrl == rhs.hasOriginalContentUrl) && (!lhs.hasOriginalContentUrl || lhs.originalContentUrl == rhs.originalContentUrl)
  fieldCheck = fieldCheck && (lhs.hasMediaType == rhs.hasMediaType) && (!lhs.hasMediaType || lhs.mediaType == rhs.mediaType)
  fieldCheck = fieldCheck && (lhs.streamId == rhs.streamId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PlusPhoto.Thumbnail, rhs: PlusPhoto.Thumbnail) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = fieldCheck && (lhs.hasImageUrl == rhs.hasImageUrl) && (!lhs.hasImageUrl || lhs.imageUrl == rhs.imageUrl)
  fieldCheck = fieldCheck && (lhs.hasWidthPx == rhs.hasWidthPx) && (!lhs.hasWidthPx || lhs.widthPx == rhs.widthPx)
  fieldCheck = fieldCheck && (lhs.hasHeightPx == rhs.hasHeightPx) && (!lhs.hasHeightPx || lhs.heightPx == rhs.heightPx)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Place, rhs: Place) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasRepresentativeImage == rhs.hasRepresentativeImage) && (!lhs.hasRepresentativeImage || lhs.representativeImage == rhs.representativeImage)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Place.RepresentativeImage, rhs: Place.RepresentativeImage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EmbedItem, rhs: EmbedItem) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasPlusPhoto == rhs.hasPlusPhoto) && (!lhs.hasPlusPhoto || lhs.plusPhoto == rhs.plusPhoto)
  fieldCheck = fieldCheck && (lhs.hasPlace == rhs.hasPlace) && (!lhs.hasPlace || lhs.place == rhs.place)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Attachment, rhs: Attachment) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEmbedItem == rhs.hasEmbedItem) && (!lhs.hasEmbedItem || lhs.embedItem == rhs.embedItem)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MessageContent, rhs: MessageContent) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.segment == rhs.segment)
  fieldCheck = fieldCheck && (lhs.attachment == rhs.attachment)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EventAnnotation, rhs: EventAnnotation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ChatMessage, rhs: ChatMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.annotation == rhs.annotation)
  fieldCheck = fieldCheck && (lhs.hasMessageContent == rhs.hasMessageContent) && (!lhs.hasMessageContent || lhs.messageContent == rhs.messageContent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MembershipChange, rhs: MembershipChange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.participantIds == rhs.participantIds)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationRename, rhs: ConversationRename) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNewName == rhs.hasNewName) && (!lhs.hasNewName || lhs.newName == rhs.newName)
  fieldCheck = fieldCheck && (lhs.hasOldName == rhs.hasOldName) && (!lhs.hasOldName || lhs.oldName == rhs.oldName)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: HangoutEvent, rhs: HangoutEvent) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEventType == rhs.hasEventType) && (!lhs.hasEventType || lhs.eventType == rhs.eventType)
  fieldCheck = fieldCheck && (lhs.participantId == rhs.participantId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Otrmodification, rhs: Otrmodification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOldOtrStatus == rhs.hasOldOtrStatus) && (!lhs.hasOldOtrStatus || lhs.oldOtrStatus == rhs.oldOtrStatus)
  fieldCheck = fieldCheck && (lhs.hasNewOtrStatus == rhs.hasNewOtrStatus) && (!lhs.hasNewOtrStatus || lhs.newOtrStatus == rhs.newOtrStatus)
  fieldCheck = fieldCheck && (lhs.hasOldOtrToggle == rhs.hasOldOtrToggle) && (!lhs.hasOldOtrToggle || lhs.oldOtrToggle == rhs.oldOtrToggle)
  fieldCheck = fieldCheck && (lhs.hasNewOtrToggle == rhs.hasNewOtrToggle) && (!lhs.hasNewOtrToggle || lhs.newOtrToggle == rhs.newOtrToggle)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: HashModifier, rhs: HashModifier) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUpdateId == rhs.hasUpdateId) && (!lhs.hasUpdateId || lhs.updateId == rhs.updateId)
  fieldCheck = fieldCheck && (lhs.hasHashDiff == rhs.hasHashDiff) && (!lhs.hasHashDiff || lhs.hashDiff == rhs.hashDiff)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Event, rhs: Event) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasSenderId == rhs.hasSenderId) && (!lhs.hasSenderId || lhs.senderId == rhs.senderId)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasSelfEventState == rhs.hasSelfEventState) && (!lhs.hasSelfEventState || lhs.selfEventState == rhs.selfEventState)
  fieldCheck = fieldCheck && (lhs.hasSourceType == rhs.hasSourceType) && (!lhs.hasSourceType || lhs.sourceType == rhs.sourceType)
  fieldCheck = fieldCheck && (lhs.hasChatMessage == rhs.hasChatMessage) && (!lhs.hasChatMessage || lhs.chatMessage == rhs.chatMessage)
  fieldCheck = fieldCheck && (lhs.hasMembershipChange == rhs.hasMembershipChange) && (!lhs.hasMembershipChange || lhs.membershipChange == rhs.membershipChange)
  fieldCheck = fieldCheck && (lhs.hasConversationRename == rhs.hasConversationRename) && (!lhs.hasConversationRename || lhs.conversationRename == rhs.conversationRename)
  fieldCheck = fieldCheck && (lhs.hasHangoutEvent == rhs.hasHangoutEvent) && (!lhs.hasHangoutEvent || lhs.hangoutEvent == rhs.hangoutEvent)
  fieldCheck = fieldCheck && (lhs.hasEventId == rhs.hasEventId) && (!lhs.hasEventId || lhs.eventId == rhs.eventId)
  fieldCheck = fieldCheck && (lhs.hasExpirationTimestamp == rhs.hasExpirationTimestamp) && (!lhs.hasExpirationTimestamp || lhs.expirationTimestamp == rhs.expirationTimestamp)
  fieldCheck = fieldCheck && (lhs.hasOtrModification == rhs.hasOtrModification) && (!lhs.hasOtrModification || lhs.otrModification == rhs.otrModification)
  fieldCheck = fieldCheck && (lhs.hasAdvancesSortTimestamp == rhs.hasAdvancesSortTimestamp) && (!lhs.hasAdvancesSortTimestamp || lhs.advancesSortTimestamp == rhs.advancesSortTimestamp)
  fieldCheck = fieldCheck && (lhs.hasOtrStatus == rhs.hasOtrStatus) && (!lhs.hasOtrStatus || lhs.otrStatus == rhs.otrStatus)
  fieldCheck = fieldCheck && (lhs.hasPersisted == rhs.hasPersisted) && (!lhs.hasPersisted || lhs.persisted == rhs.persisted)
  fieldCheck = fieldCheck && (lhs.hasMediumType == rhs.hasMediumType) && (!lhs.hasMediumType || lhs.mediumType == rhs.mediumType)
  fieldCheck = fieldCheck && (lhs.hasEventType == rhs.hasEventType) && (!lhs.hasEventType || lhs.eventType == rhs.eventType)
  fieldCheck = fieldCheck && (lhs.hasEventVersion == rhs.hasEventVersion) && (!lhs.hasEventVersion || lhs.eventVersion == rhs.eventVersion)
  fieldCheck = fieldCheck && (lhs.hasHashModifier == rhs.hasHashModifier) && (!lhs.hasHashModifier || lhs.hashModifier == rhs.hashModifier)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserReadState, rhs: UserReadState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasParticipantId == rhs.hasParticipantId) && (!lhs.hasParticipantId || lhs.participantId == rhs.participantId)
  fieldCheck = fieldCheck && (lhs.hasLatestReadTimestamp == rhs.hasLatestReadTimestamp) && (!lhs.hasLatestReadTimestamp || lhs.latestReadTimestamp == rhs.latestReadTimestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeliveryMedium, rhs: DeliveryMedium) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMediumType == rhs.hasMediumType) && (!lhs.hasMediumType || lhs.mediumType == rhs.mediumType)
  fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeliveryMediumOption, rhs: DeliveryMediumOption) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeliveryMedium == rhs.hasDeliveryMedium) && (!lhs.hasDeliveryMedium || lhs.deliveryMedium == rhs.deliveryMedium)
  fieldCheck = fieldCheck && (lhs.hasCurrentDefault == rhs.hasCurrentDefault) && (!lhs.hasCurrentDefault || lhs.currentDefault == rhs.currentDefault)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserConversationState, rhs: UserConversationState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasClientGeneratedId == rhs.hasClientGeneratedId) && (!lhs.hasClientGeneratedId || lhs.clientGeneratedId == rhs.clientGeneratedId)
  fieldCheck = fieldCheck && (lhs.hasSelfReadState == rhs.hasSelfReadState) && (!lhs.hasSelfReadState || lhs.selfReadState == rhs.selfReadState)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasNotificationLevel == rhs.hasNotificationLevel) && (!lhs.hasNotificationLevel || lhs.notificationLevel == rhs.notificationLevel)
  fieldCheck = fieldCheck && (lhs.view == rhs.view)
  fieldCheck = fieldCheck && (lhs.hasInviterId == rhs.hasInviterId) && (!lhs.hasInviterId || lhs.inviterId == rhs.inviterId)
  fieldCheck = fieldCheck && (lhs.hasInviteTimestamp == rhs.hasInviteTimestamp) && (!lhs.hasInviteTimestamp || lhs.inviteTimestamp == rhs.inviteTimestamp)
  fieldCheck = fieldCheck && (lhs.hasSortTimestamp == rhs.hasSortTimestamp) && (!lhs.hasSortTimestamp || lhs.sortTimestamp == rhs.sortTimestamp)
  fieldCheck = fieldCheck && (lhs.hasActiveTimestamp == rhs.hasActiveTimestamp) && (!lhs.hasActiveTimestamp || lhs.activeTimestamp == rhs.activeTimestamp)
  fieldCheck = fieldCheck && (lhs.hasInviteAffinity == rhs.hasInviteAffinity) && (!lhs.hasInviteAffinity || lhs.inviteAffinity == rhs.inviteAffinity)
  fieldCheck = fieldCheck && (lhs.deliveryMediumOption == rhs.deliveryMediumOption)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationParticipantData, rhs: ConversationParticipantData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasFallbackName == rhs.hasFallbackName) && (!lhs.hasFallbackName || lhs.fallbackName == rhs.fallbackName)
  fieldCheck = fieldCheck && (lhs.hasInvitationStatus == rhs.hasInvitationStatus) && (!lhs.hasInvitationStatus || lhs.invitationStatus == rhs.invitationStatus)
  fieldCheck = fieldCheck && (lhs.hasParticipantType == rhs.hasParticipantType) && (!lhs.hasParticipantType || lhs.participantType == rhs.participantType)
  fieldCheck = fieldCheck && (lhs.hasNewInvitationStatus == rhs.hasNewInvitationStatus) && (!lhs.hasNewInvitationStatus || lhs.newInvitationStatus == rhs.newInvitationStatus)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Conversation, rhs: Conversation) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasSelfConversationState == rhs.hasSelfConversationState) && (!lhs.hasSelfConversationState || lhs.selfConversationState == rhs.selfConversationState)
  fieldCheck = fieldCheck && (lhs.readState == rhs.readState)
  fieldCheck = fieldCheck && (lhs.hasHasActiveHangout == rhs.hasHasActiveHangout) && (!lhs.hasHasActiveHangout || lhs.hasActiveHangout == rhs.hasActiveHangout)
  fieldCheck = fieldCheck && (lhs.hasOtrStatus == rhs.hasOtrStatus) && (!lhs.hasOtrStatus || lhs.otrStatus == rhs.otrStatus)
  fieldCheck = fieldCheck && (lhs.hasOtrToggle == rhs.hasOtrToggle) && (!lhs.hasOtrToggle || lhs.otrToggle == rhs.otrToggle)
  fieldCheck = fieldCheck && (lhs.hasConversationHistorySupported == rhs.hasConversationHistorySupported) && (!lhs.hasConversationHistorySupported || lhs.conversationHistorySupported == rhs.conversationHistorySupported)
  fieldCheck = fieldCheck && (lhs.currentParticipant == rhs.currentParticipant)
  fieldCheck = fieldCheck && (lhs.participantData == rhs.participantData)
  fieldCheck = fieldCheck && (lhs.networkType == rhs.networkType)
  fieldCheck = fieldCheck && (lhs.hasForceHistoryState == rhs.hasForceHistoryState) && (!lhs.hasForceHistoryState || lhs.forceHistoryState == rhs.forceHistoryState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EasterEgg, rhs: EasterEgg) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: BlockStateChange, rhs: BlockStateChange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasParticipantId == rhs.hasParticipantId) && (!lhs.hasParticipantId || lhs.participantId == rhs.participantId)
  fieldCheck = fieldCheck && (lhs.hasNewBlockState == rhs.hasNewBlockState) && (!lhs.hasNewBlockState || lhs.newBlockState == rhs.newBlockState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Photo, rhs: Photo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPhotoId == rhs.hasPhotoId) && (!lhs.hasPhotoId || lhs.photoId == rhs.photoId)
  fieldCheck = fieldCheck && (lhs.hasDeleteAlbumlessSourcePhoto == rhs.hasDeleteAlbumlessSourcePhoto) && (!lhs.hasDeleteAlbumlessSourcePhoto || lhs.deleteAlbumlessSourcePhoto == rhs.deleteAlbumlessSourcePhoto)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasIsCustomUserId == rhs.hasIsCustomUserId) && (!lhs.hasIsCustomUserId || lhs.isCustomUserId == rhs.isCustomUserId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ExistingMedia, rhs: ExistingMedia) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPhoto == rhs.hasPhoto) && (!lhs.hasPhoto || lhs.photo == rhs.photo)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EventRequestHeader, rhs: EventRequestHeader) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasClientGeneratedId == rhs.hasClientGeneratedId) && (!lhs.hasClientGeneratedId || lhs.clientGeneratedId == rhs.clientGeneratedId)
  fieldCheck = fieldCheck && (lhs.hasExpectedOtr == rhs.hasExpectedOtr) && (!lhs.hasExpectedOtr || lhs.expectedOtr == rhs.expectedOtr)
  fieldCheck = fieldCheck && (lhs.hasDeliveryMedium == rhs.hasDeliveryMedium) && (!lhs.hasDeliveryMedium || lhs.deliveryMedium == rhs.deliveryMedium)
  fieldCheck = fieldCheck && (lhs.hasEventType == rhs.hasEventType) && (!lhs.hasEventType || lhs.eventType == rhs.eventType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ClientVersion, rhs: ClientVersion) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasClientId == rhs.hasClientId) && (!lhs.hasClientId || lhs.clientId == rhs.clientId)
  fieldCheck = fieldCheck && (lhs.hasBuildType == rhs.hasBuildType) && (!lhs.hasBuildType || lhs.buildType == rhs.buildType)
  fieldCheck = fieldCheck && (lhs.hasMajorVersion == rhs.hasMajorVersion) && (!lhs.hasMajorVersion || lhs.majorVersion == rhs.majorVersion)
  fieldCheck = fieldCheck && (lhs.hasVersionTimestamp == rhs.hasVersionTimestamp) && (!lhs.hasVersionTimestamp || lhs.versionTimestamp == rhs.versionTimestamp)
  fieldCheck = fieldCheck && (lhs.hasDeviceOsVersion == rhs.hasDeviceOsVersion) && (!lhs.hasDeviceOsVersion || lhs.deviceOsVersion == rhs.deviceOsVersion)
  fieldCheck = fieldCheck && (lhs.hasDeviceHardware == rhs.hasDeviceHardware) && (!lhs.hasDeviceHardware || lhs.deviceHardware == rhs.deviceHardware)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestHeader, rhs: RequestHeader) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasClientVersion == rhs.hasClientVersion) && (!lhs.hasClientVersion || lhs.clientVersion == rhs.clientVersion)
  fieldCheck = fieldCheck && (lhs.hasClientIdentifier == rhs.hasClientIdentifier) && (!lhs.hasClientIdentifier || lhs.clientIdentifier == rhs.clientIdentifier)
  fieldCheck = fieldCheck && (lhs.hasLanguageCode == rhs.hasLanguageCode) && (!lhs.hasLanguageCode || lhs.languageCode == rhs.languageCode)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseHeader, rhs: ResponseHeader) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasErrorDescription == rhs.hasErrorDescription) && (!lhs.hasErrorDescription || lhs.errorDescription == rhs.errorDescription)
  fieldCheck = fieldCheck && (lhs.hasDebugUrl == rhs.hasDebugUrl) && (!lhs.hasDebugUrl || lhs.debugUrl == rhs.debugUrl)
  fieldCheck = fieldCheck && (lhs.hasRequestTraceId == rhs.hasRequestTraceId) && (!lhs.hasRequestTraceId || lhs.requestTraceId == rhs.requestTraceId)
  fieldCheck = fieldCheck && (lhs.hasCurrentServerTime == rhs.hasCurrentServerTime) && (!lhs.hasCurrentServerTime || lhs.currentServerTime == rhs.currentServerTime)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Entity, rhs: Entity) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPresence == rhs.hasPresence) && (!lhs.hasPresence || lhs.presence == rhs.presence)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasProperties == rhs.hasProperties) && (!lhs.hasProperties || lhs.properties == rhs.properties)
  fieldCheck = fieldCheck && (lhs.hasEntityType == rhs.hasEntityType) && (!lhs.hasEntityType || lhs.entityType == rhs.entityType)
  fieldCheck = fieldCheck && (lhs.hasHadPastHangoutState == rhs.hasHadPastHangoutState) && (!lhs.hasHadPastHangoutState || lhs.hadPastHangoutState == rhs.hadPastHangoutState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EntityProperties, rhs: EntityProperties) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasDisplayName == rhs.hasDisplayName) && (!lhs.hasDisplayName || lhs.displayName == rhs.displayName)
  fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
  fieldCheck = fieldCheck && (lhs.hasPhotoUrl == rhs.hasPhotoUrl) && (!lhs.hasPhotoUrl || lhs.photoUrl == rhs.photoUrl)
  fieldCheck = fieldCheck && (lhs.email == rhs.email)
  fieldCheck = fieldCheck && (lhs.phone == rhs.phone)
  fieldCheck = fieldCheck && (lhs.hasInUsersDomain == rhs.hasInUsersDomain) && (!lhs.hasInUsersDomain || lhs.inUsersDomain == rhs.inUsersDomain)
  fieldCheck = fieldCheck && (lhs.hasGender == rhs.hasGender) && (!lhs.hasGender || lhs.gender == rhs.gender)
  fieldCheck = fieldCheck && (lhs.hasPhotoUrlStatus == rhs.hasPhotoUrlStatus) && (!lhs.hasPhotoUrlStatus || lhs.photoUrlStatus == rhs.photoUrlStatus)
  fieldCheck = fieldCheck && (lhs.hasCanonicalEmail == rhs.hasCanonicalEmail) && (!lhs.hasCanonicalEmail || lhs.canonicalEmail == rhs.canonicalEmail)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationState, rhs: ConversationState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasConversation == rhs.hasConversation) && (!lhs.hasConversation || lhs.conversation == rhs.conversation)
  fieldCheck = fieldCheck && (lhs.event == rhs.event)
  fieldCheck = fieldCheck && (lhs.hasEventContinuationToken == rhs.hasEventContinuationToken) && (!lhs.hasEventContinuationToken || lhs.eventContinuationToken == rhs.eventContinuationToken)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EventContinuationToken, rhs: EventContinuationToken) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEventId == rhs.hasEventId) && (!lhs.hasEventId || lhs.eventId == rhs.eventId)
  fieldCheck = fieldCheck && (lhs.hasStorageContinuationToken == rhs.hasStorageContinuationToken) && (!lhs.hasStorageContinuationToken || lhs.storageContinuationToken == rhs.storageContinuationToken)
  fieldCheck = fieldCheck && (lhs.hasEventTimestamp == rhs.hasEventTimestamp) && (!lhs.hasEventTimestamp || lhs.eventTimestamp == rhs.eventTimestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EntityLookupSpec, rhs: EntityLookupSpec) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGaiaId == rhs.hasGaiaId) && (!lhs.hasGaiaId || lhs.gaiaId == rhs.gaiaId)
  fieldCheck = fieldCheck && (lhs.hasEmail == rhs.hasEmail) && (!lhs.hasEmail || lhs.email == rhs.email)
  fieldCheck = fieldCheck && (lhs.hasPhone == rhs.hasPhone) && (!lhs.hasPhone || lhs.phone == rhs.phone)
  fieldCheck = fieldCheck && (lhs.hasCreateOffnetworkGaia == rhs.hasCreateOffnetworkGaia) && (!lhs.hasCreateOffnetworkGaia || lhs.createOffnetworkGaia == rhs.createOffnetworkGaia)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConfigurationBit, rhs: ConfigurationBit) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConfigurationBitType == rhs.hasConfigurationBitType) && (!lhs.hasConfigurationBitType || lhs.configurationBitType == rhs.configurationBitType)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RichPresenceState, rhs: RichPresenceState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.getRichPresenceEnabledState == rhs.getRichPresenceEnabledState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RichPresenceEnabledState, rhs: RichPresenceEnabledState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DesktopOffSetting, rhs: DesktopOffSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDesktopOff == rhs.hasDesktopOff) && (!lhs.hasDesktopOff || lhs.desktopOff == rhs.desktopOff)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DesktopOffState, rhs: DesktopOffState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDesktopOff == rhs.hasDesktopOff) && (!lhs.hasDesktopOff || lhs.desktopOff == rhs.desktopOff)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DndSetting, rhs: DndSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDoNotDisturb == rhs.hasDoNotDisturb) && (!lhs.hasDoNotDisturb || lhs.doNotDisturb == rhs.doNotDisturb)
  fieldCheck = fieldCheck && (lhs.hasTimeoutSecs == rhs.hasTimeoutSecs) && (!lhs.hasTimeoutSecs || lhs.timeoutSecs == rhs.timeoutSecs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PresenceStateSetting, rhs: PresenceStateSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTimeoutSecs == rhs.hasTimeoutSecs) && (!lhs.hasTimeoutSecs || lhs.timeoutSecs == rhs.timeoutSecs)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MoodMessage, rhs: MoodMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMoodContent == rhs.hasMoodContent) && (!lhs.hasMoodContent || lhs.moodContent == rhs.moodContent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MoodContent, rhs: MoodContent) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.segment == rhs.segment)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MoodSetting, rhs: MoodSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMoodMessage == rhs.hasMoodMessage) && (!lhs.hasMoodMessage || lhs.moodMessage == rhs.moodMessage)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MoodState, rhs: MoodState) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMoodSetting == rhs.hasMoodSetting) && (!lhs.hasMoodSetting || lhs.moodSetting == rhs.moodSetting)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeleteAction, rhs: DeleteAction) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeleteActionTimestamp == rhs.hasDeleteActionTimestamp) && (!lhs.hasDeleteActionTimestamp || lhs.deleteActionTimestamp == rhs.deleteActionTimestamp)
  fieldCheck = fieldCheck && (lhs.hasDeleteUpperBoundTimestamp == rhs.hasDeleteUpperBoundTimestamp) && (!lhs.hasDeleteUpperBoundTimestamp || lhs.deleteUpperBoundTimestamp == rhs.deleteUpperBoundTimestamp)
  fieldCheck = fieldCheck && (lhs.hasDeleteType == rhs.hasDeleteType) && (!lhs.hasDeleteType || lhs.deleteType == rhs.deleteType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: InviteeId, rhs: InviteeId) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGaiaId == rhs.hasGaiaId) && (!lhs.hasGaiaId || lhs.gaiaId == rhs.gaiaId)
  fieldCheck = fieldCheck && (lhs.hasFallbackName == rhs.hasFallbackName) && (!lhs.hasFallbackName || lhs.fallbackName == rhs.fallbackName)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Country, rhs: Country) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRegionCode == rhs.hasRegionCode) && (!lhs.hasRegionCode || lhs.regionCode == rhs.regionCode)
  fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DesktopSoundSetting, rhs: DesktopSoundSetting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDesktopSoundState == rhs.hasDesktopSoundState) && (!lhs.hasDesktopSoundState || lhs.desktopSoundState == rhs.desktopSoundState)
  fieldCheck = fieldCheck && (lhs.hasDesktopRingSoundState == rhs.hasDesktopRingSoundState) && (!lhs.hasDesktopRingSoundState || lhs.desktopRingSoundState == rhs.desktopRingSoundState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PhoneData, rhs: PhoneData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.phone == rhs.phone)
  fieldCheck = fieldCheck && (lhs.hasCallerIdSettingsMask == rhs.hasCallerIdSettingsMask) && (!lhs.hasCallerIdSettingsMask || lhs.callerIdSettingsMask == rhs.callerIdSettingsMask)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Phone, rhs: Phone) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
  fieldCheck = fieldCheck && (lhs.hasGoogleVoice == rhs.hasGoogleVoice) && (!lhs.hasGoogleVoice || lhs.googleVoice == rhs.googleVoice)
  fieldCheck = fieldCheck && (lhs.hasVerificationStatus == rhs.hasVerificationStatus) && (!lhs.hasVerificationStatus || lhs.verificationStatus == rhs.verificationStatus)
  fieldCheck = fieldCheck && (lhs.hasDiscoverable == rhs.hasDiscoverable) && (!lhs.hasDiscoverable || lhs.discoverable == rhs.discoverable)
  fieldCheck = fieldCheck && (lhs.hasDiscoverabilityStatus == rhs.hasDiscoverabilityStatus) && (!lhs.hasDiscoverabilityStatus || lhs.discoverabilityStatus == rhs.discoverabilityStatus)
  fieldCheck = fieldCheck && (lhs.hasPrimary == rhs.hasPrimary) && (!lhs.hasPrimary || lhs.primary == rhs.primary)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: I18NData, rhs: I18NData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNationalNumber == rhs.hasNationalNumber) && (!lhs.hasNationalNumber || lhs.nationalNumber == rhs.nationalNumber)
  fieldCheck = fieldCheck && (lhs.hasInternationalNumber == rhs.hasInternationalNumber) && (!lhs.hasInternationalNumber || lhs.internationalNumber == rhs.internationalNumber)
  fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
  fieldCheck = fieldCheck && (lhs.hasRegionCode == rhs.hasRegionCode) && (!lhs.hasRegionCode || lhs.regionCode == rhs.regionCode)
  fieldCheck = fieldCheck && (lhs.hasIsValid == rhs.hasIsValid) && (!lhs.hasIsValid || lhs.isValid == rhs.isValid)
  fieldCheck = fieldCheck && (lhs.hasValidationResult == rhs.hasValidationResult) && (!lhs.hasValidationResult || lhs.validationResult == rhs.validationResult)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PhoneNumber, rhs: PhoneNumber) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasE164 == rhs.hasE164) && (!lhs.hasE164 || lhs.e164 == rhs.e164)
  fieldCheck = fieldCheck && (lhs.hasI18NData == rhs.hasI18NData) && (!lhs.hasI18NData || lhs.i18NData == rhs.i18NData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SuggestedContactGroupHash, rhs: SuggestedContactGroupHash) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMaxResults == rhs.hasMaxResults) && (!lhs.hasMaxResults || lhs.maxResults == rhs.maxResults)
  fieldCheck = fieldCheck && (lhs.hasHash == rhs.hasHash) && (!lhs.hasHash || lhs.hash == rhs.hash)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SuggestedContact, rhs: SuggestedContact) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEntity == rhs.hasEntity) && (!lhs.hasEntity || lhs.entity == rhs.entity)
  fieldCheck = fieldCheck && (lhs.hasInvitationStatus == rhs.hasInvitationStatus) && (!lhs.hasInvitationStatus || lhs.invitationStatus == rhs.invitationStatus)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SuggestedContactGroup, rhs: SuggestedContactGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHashMatched == rhs.hasHashMatched) && (!lhs.hasHashMatched || lhs.hashMatched == rhs.hashMatched)
  fieldCheck = fieldCheck && (lhs.hasHash == rhs.hasHash) && (!lhs.hasHash || lhs.hash == rhs.hash)
  fieldCheck = fieldCheck && (lhs.contact == rhs.contact)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: StateUpdate, rhs: StateUpdate) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStateUpdateHeader == rhs.hasStateUpdateHeader) && (!lhs.hasStateUpdateHeader || lhs.stateUpdateHeader == rhs.stateUpdateHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationNotification == rhs.hasConversationNotification) && (!lhs.hasConversationNotification || lhs.conversationNotification == rhs.conversationNotification)
  fieldCheck = fieldCheck && (lhs.hasEventNotification == rhs.hasEventNotification) && (!lhs.hasEventNotification || lhs.eventNotification == rhs.eventNotification)
  fieldCheck = fieldCheck && (lhs.hasFocusNotification == rhs.hasFocusNotification) && (!lhs.hasFocusNotification || lhs.focusNotification == rhs.focusNotification)
  fieldCheck = fieldCheck && (lhs.hasTypingNotification == rhs.hasTypingNotification) && (!lhs.hasTypingNotification || lhs.typingNotification == rhs.typingNotification)
  fieldCheck = fieldCheck && (lhs.hasNotificationLevelNotification == rhs.hasNotificationLevelNotification) && (!lhs.hasNotificationLevelNotification || lhs.notificationLevelNotification == rhs.notificationLevelNotification)
  fieldCheck = fieldCheck && (lhs.hasReplyToInviteNotification == rhs.hasReplyToInviteNotification) && (!lhs.hasReplyToInviteNotification || lhs.replyToInviteNotification == rhs.replyToInviteNotification)
  fieldCheck = fieldCheck && (lhs.hasWatermarkNotification == rhs.hasWatermarkNotification) && (!lhs.hasWatermarkNotification || lhs.watermarkNotification == rhs.watermarkNotification)
  fieldCheck = fieldCheck && (lhs.hasViewModification == rhs.hasViewModification) && (!lhs.hasViewModification || lhs.viewModification == rhs.viewModification)
  fieldCheck = fieldCheck && (lhs.hasEasterEggNotification == rhs.hasEasterEggNotification) && (!lhs.hasEasterEggNotification || lhs.easterEggNotification == rhs.easterEggNotification)
  fieldCheck = fieldCheck && (lhs.hasConversation == rhs.hasConversation) && (!lhs.hasConversation || lhs.conversation == rhs.conversation)
  fieldCheck = fieldCheck && (lhs.hasSelfPresenceNotification == rhs.hasSelfPresenceNotification) && (!lhs.hasSelfPresenceNotification || lhs.selfPresenceNotification == rhs.selfPresenceNotification)
  fieldCheck = fieldCheck && (lhs.hasDeleteNotification == rhs.hasDeleteNotification) && (!lhs.hasDeleteNotification || lhs.deleteNotification == rhs.deleteNotification)
  fieldCheck = fieldCheck && (lhs.hasPresenceNotification == rhs.hasPresenceNotification) && (!lhs.hasPresenceNotification || lhs.presenceNotification == rhs.presenceNotification)
  fieldCheck = fieldCheck && (lhs.hasBlockNotification == rhs.hasBlockNotification) && (!lhs.hasBlockNotification || lhs.blockNotification == rhs.blockNotification)
  fieldCheck = fieldCheck && (lhs.hasNotificationSettingNotification == rhs.hasNotificationSettingNotification) && (!lhs.hasNotificationSettingNotification || lhs.notificationSettingNotification == rhs.notificationSettingNotification)
  fieldCheck = fieldCheck && (lhs.hasRichPresenceEnabledStateNotification == rhs.hasRichPresenceEnabledStateNotification) && (!lhs.hasRichPresenceEnabledStateNotification || lhs.richPresenceEnabledStateNotification == rhs.richPresenceEnabledStateNotification)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: StateUpdateHeader, rhs: StateUpdateHeader) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasActiveClientState == rhs.hasActiveClientState) && (!lhs.hasActiveClientState || lhs.activeClientState == rhs.activeClientState)
  fieldCheck = fieldCheck && (lhs.hasRequestTraceId == rhs.hasRequestTraceId) && (!lhs.hasRequestTraceId || lhs.requestTraceId == rhs.requestTraceId)
  fieldCheck = fieldCheck && (lhs.hasNotificationSettings == rhs.hasNotificationSettings) && (!lhs.hasNotificationSettings || lhs.notificationSettings == rhs.notificationSettings)
  fieldCheck = fieldCheck && (lhs.hasCurrentServerTime == rhs.hasCurrentServerTime) && (!lhs.hasCurrentServerTime || lhs.currentServerTime == rhs.currentServerTime)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: BatchUpdate, rhs: BatchUpdate) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.stateUpdate == rhs.stateUpdate)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationNotification, rhs: ConversationNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversation == rhs.hasConversation) && (!lhs.hasConversation || lhs.conversation == rhs.conversation)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EventNotification, rhs: EventNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEvent == rhs.hasEvent) && (!lhs.hasEvent || lhs.event == rhs.event)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetFocusNotification, rhs: SetFocusNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasSenderId == rhs.hasSenderId) && (!lhs.hasSenderId || lhs.senderId == rhs.senderId)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasDevice == rhs.hasDevice) && (!lhs.hasDevice || lhs.device == rhs.device)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetTypingNotification, rhs: SetTypingNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasSenderId == rhs.hasSenderId) && (!lhs.hasSenderId || lhs.senderId == rhs.senderId)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetConversationNotificationLevelNotification, rhs: SetConversationNotificationLevelNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasLevel == rhs.hasLevel) && (!lhs.hasLevel || lhs.level == rhs.level)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ReplyToInviteNotification, rhs: ReplyToInviteNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: WatermarkNotification, rhs: WatermarkNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSenderId == rhs.hasSenderId) && (!lhs.hasSenderId || lhs.senderId == rhs.senderId)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasLatestReadTimestamp == rhs.hasLatestReadTimestamp) && (!lhs.hasLatestReadTimestamp || lhs.latestReadTimestamp == rhs.latestReadTimestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationViewModification, rhs: ConversationViewModification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasOldView == rhs.hasOldView) && (!lhs.hasOldView || lhs.oldView == rhs.oldView)
  fieldCheck = fieldCheck && (lhs.hasNewView == rhs.hasNewView) && (!lhs.hasNewView || lhs.newView == rhs.newView)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EasterEggNotification, rhs: EasterEggNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSenderId == rhs.hasSenderId) && (!lhs.hasSenderId || lhs.senderId == rhs.senderId)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasEasterEgg == rhs.hasEasterEgg) && (!lhs.hasEasterEgg || lhs.easterEgg == rhs.easterEgg)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SelfPresenceNotification, rhs: SelfPresenceNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasClientPresenceState == rhs.hasClientPresenceState) && (!lhs.hasClientPresenceState || lhs.clientPresenceState == rhs.clientPresenceState)
  fieldCheck = fieldCheck && (lhs.hasDoNotDisturbSetting == rhs.hasDoNotDisturbSetting) && (!lhs.hasDoNotDisturbSetting || lhs.doNotDisturbSetting == rhs.doNotDisturbSetting)
  fieldCheck = fieldCheck && (lhs.hasDesktopOffSetting == rhs.hasDesktopOffSetting) && (!lhs.hasDesktopOffSetting || lhs.desktopOffSetting == rhs.desktopOffSetting)
  fieldCheck = fieldCheck && (lhs.hasDesktopOffState == rhs.hasDesktopOffState) && (!lhs.hasDesktopOffState || lhs.desktopOffState == rhs.desktopOffState)
  fieldCheck = fieldCheck && (lhs.hasMoodState == rhs.hasMoodState) && (!lhs.hasMoodState || lhs.moodState == rhs.moodState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeleteActionNotification, rhs: DeleteActionNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasDeleteAction == rhs.hasDeleteAction) && (!lhs.hasDeleteAction || lhs.deleteAction == rhs.deleteAction)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PresenceNotification, rhs: PresenceNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.presence == rhs.presence)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: BlockNotification, rhs: BlockNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.blockStateChange == rhs.blockStateChange)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetNotificationSettingNotification, rhs: SetNotificationSettingNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDesktopSoundSetting == rhs.hasDesktopSoundSetting) && (!lhs.hasDesktopSoundSetting || lhs.desktopSoundSetting == rhs.desktopSoundSetting)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RichPresenceEnabledStateNotification, rhs: RichPresenceEnabledStateNotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.richPresenceEnabledState == rhs.richPresenceEnabledState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConversationSpec, rhs: ConversationSpec) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: OffnetworkAddress, rhs: OffnetworkAddress) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasEmail == rhs.hasEmail) && (!lhs.hasEmail || lhs.email == rhs.email)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EntityResult, rhs: EntityResult) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLookupSpec == rhs.hasLookupSpec) && (!lhs.hasLookupSpec || lhs.lookupSpec == rhs.lookupSpec)
  fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: AddUserRequest, rhs: AddUserRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.inviteeId == rhs.inviteeId)
  fieldCheck = fieldCheck && (lhs.hasEventRequestHeader == rhs.hasEventRequestHeader) && (!lhs.hasEventRequestHeader || lhs.eventRequestHeader == rhs.eventRequestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: AddUserResponse, rhs: AddUserResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasCreatedEvent == rhs.hasCreatedEvent) && (!lhs.hasCreatedEvent || lhs.createdEvent == rhs.createdEvent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CreateConversationRequest, rhs: CreateConversationRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasClientGeneratedId == rhs.hasClientGeneratedId) && (!lhs.hasClientGeneratedId || lhs.clientGeneratedId == rhs.clientGeneratedId)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.inviteeId == rhs.inviteeId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CreateConversationResponse, rhs: CreateConversationResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasConversation == rhs.hasConversation) && (!lhs.hasConversation || lhs.conversation == rhs.conversation)
  fieldCheck = fieldCheck && (lhs.hasNewConversationCreated == rhs.hasNewConversationCreated) && (!lhs.hasNewConversationCreated || lhs.newConversationCreated == rhs.newConversationCreated)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeleteConversationRequest, rhs: DeleteConversationRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasDeleteUpperBoundTimestamp == rhs.hasDeleteUpperBoundTimestamp) && (!lhs.hasDeleteUpperBoundTimestamp || lhs.deleteUpperBoundTimestamp == rhs.deleteUpperBoundTimestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DeleteConversationResponse, rhs: DeleteConversationResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasDeleteAction == rhs.hasDeleteAction) && (!lhs.hasDeleteAction || lhs.deleteAction == rhs.deleteAction)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EasterEggRequest, rhs: EasterEggRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasEasterEgg == rhs.hasEasterEgg) && (!lhs.hasEasterEgg || lhs.easterEgg == rhs.easterEgg)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: EasterEggResponse, rhs: EasterEggResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetConversationRequest, rhs: GetConversationRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationSpec == rhs.hasConversationSpec) && (!lhs.hasConversationSpec || lhs.conversationSpec == rhs.conversationSpec)
  fieldCheck = fieldCheck && (lhs.hasIncludeEvent == rhs.hasIncludeEvent) && (!lhs.hasIncludeEvent || lhs.includeEvent == rhs.includeEvent)
  fieldCheck = fieldCheck && (lhs.hasMaxEventsPerConversation == rhs.hasMaxEventsPerConversation) && (!lhs.hasMaxEventsPerConversation || lhs.maxEventsPerConversation == rhs.maxEventsPerConversation)
  fieldCheck = fieldCheck && (lhs.hasEventContinuationToken == rhs.hasEventContinuationToken) && (!lhs.hasEventContinuationToken || lhs.eventContinuationToken == rhs.eventContinuationToken)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetConversationResponse, rhs: GetConversationResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationState == rhs.hasConversationState) && (!lhs.hasConversationState || lhs.conversationState == rhs.conversationState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetEntityByIdRequest, rhs: GetEntityByIdRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.batchLookupSpec == rhs.batchLookupSpec)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetEntityByIdResponse, rhs: GetEntityByIdResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
  fieldCheck = fieldCheck && (lhs.entityResult == rhs.entityResult)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetSuggestedEntitiesRequest, rhs: GetSuggestedEntitiesRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasMaxCount == rhs.hasMaxCount) && (!lhs.hasMaxCount || lhs.maxCount == rhs.maxCount)
  fieldCheck = fieldCheck && (lhs.hasFavorites == rhs.hasFavorites) && (!lhs.hasFavorites || lhs.favorites == rhs.favorites)
  fieldCheck = fieldCheck && (lhs.hasContactsYouHangoutWith == rhs.hasContactsYouHangoutWith) && (!lhs.hasContactsYouHangoutWith || lhs.contactsYouHangoutWith == rhs.contactsYouHangoutWith)
  fieldCheck = fieldCheck && (lhs.hasOtherContactsOnHangouts == rhs.hasOtherContactsOnHangouts) && (!lhs.hasOtherContactsOnHangouts || lhs.otherContactsOnHangouts == rhs.otherContactsOnHangouts)
  fieldCheck = fieldCheck && (lhs.hasOtherContacts == rhs.hasOtherContacts) && (!lhs.hasOtherContacts || lhs.otherContacts == rhs.otherContacts)
  fieldCheck = fieldCheck && (lhs.hasDismissedContacts == rhs.hasDismissedContacts) && (!lhs.hasDismissedContacts || lhs.dismissedContacts == rhs.dismissedContacts)
  fieldCheck = fieldCheck && (lhs.hasPinnedFavorites == rhs.hasPinnedFavorites) && (!lhs.hasPinnedFavorites || lhs.pinnedFavorites == rhs.pinnedFavorites)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetSuggestedEntitiesResponse, rhs: GetSuggestedEntitiesResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
  fieldCheck = fieldCheck && (lhs.hasFavorites == rhs.hasFavorites) && (!lhs.hasFavorites || lhs.favorites == rhs.favorites)
  fieldCheck = fieldCheck && (lhs.hasContactsYouHangoutWith == rhs.hasContactsYouHangoutWith) && (!lhs.hasContactsYouHangoutWith || lhs.contactsYouHangoutWith == rhs.contactsYouHangoutWith)
  fieldCheck = fieldCheck && (lhs.hasOtherContactsOnHangouts == rhs.hasOtherContactsOnHangouts) && (!lhs.hasOtherContactsOnHangouts || lhs.otherContactsOnHangouts == rhs.otherContactsOnHangouts)
  fieldCheck = fieldCheck && (lhs.hasOtherContacts == rhs.hasOtherContacts) && (!lhs.hasOtherContacts || lhs.otherContacts == rhs.otherContacts)
  fieldCheck = fieldCheck && (lhs.hasDismissedContacts == rhs.hasDismissedContacts) && (!lhs.hasDismissedContacts || lhs.dismissedContacts == rhs.dismissedContacts)
  fieldCheck = fieldCheck && (lhs.hasPinnedFavorites == rhs.hasPinnedFavorites) && (!lhs.hasPinnedFavorites || lhs.pinnedFavorites == rhs.pinnedFavorites)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetSelfInfoRequest, rhs: GetSelfInfoRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GetSelfInfoResponse, rhs: GetSelfInfoResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasSelfEntity == rhs.hasSelfEntity) && (!lhs.hasSelfEntity || lhs.selfEntity == rhs.selfEntity)
  fieldCheck = fieldCheck && (lhs.hasIsKnownMinor == rhs.hasIsKnownMinor) && (!lhs.hasIsKnownMinor || lhs.isKnownMinor == rhs.isKnownMinor)
  fieldCheck = fieldCheck && (lhs.hasDndState == rhs.hasDndState) && (!lhs.hasDndState || lhs.dndState == rhs.dndState)
  fieldCheck = fieldCheck && (lhs.hasDesktopOffSetting == rhs.hasDesktopOffSetting) && (!lhs.hasDesktopOffSetting || lhs.desktopOffSetting == rhs.desktopOffSetting)
  fieldCheck = fieldCheck && (lhs.hasPhoneData == rhs.hasPhoneData) && (!lhs.hasPhoneData || lhs.phoneData == rhs.phoneData)
  fieldCheck = fieldCheck && (lhs.configurationBit == rhs.configurationBit)
  fieldCheck = fieldCheck && (lhs.hasDesktopOffState == rhs.hasDesktopOffState) && (!lhs.hasDesktopOffState || lhs.desktopOffState == rhs.desktopOffState)
  fieldCheck = fieldCheck && (lhs.hasGooglePlusUser == rhs.hasGooglePlusUser) && (!lhs.hasGooglePlusUser || lhs.googlePlusUser == rhs.googlePlusUser)
  fieldCheck = fieldCheck && (lhs.hasDesktopSoundSetting == rhs.hasDesktopSoundSetting) && (!lhs.hasDesktopSoundSetting || lhs.desktopSoundSetting == rhs.desktopSoundSetting)
  fieldCheck = fieldCheck && (lhs.hasRichPresenceState == rhs.hasRichPresenceState) && (!lhs.hasRichPresenceState || lhs.richPresenceState == rhs.richPresenceState)
  fieldCheck = fieldCheck && (lhs.hasDefaultCountry == rhs.hasDefaultCountry) && (!lhs.hasDefaultCountry || lhs.defaultCountry == rhs.defaultCountry)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: QueryPresenceRequest, rhs: QueryPresenceRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.participantId == rhs.participantId)
  fieldCheck = fieldCheck && (lhs.fieldMask == rhs.fieldMask)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: QueryPresenceResponse, rhs: QueryPresenceResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.presenceResult == rhs.presenceResult)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RemoveUserRequest, rhs: RemoveUserRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasEventRequestHeader == rhs.hasEventRequestHeader) && (!lhs.hasEventRequestHeader || lhs.eventRequestHeader == rhs.eventRequestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RemoveUserResponse, rhs: RemoveUserResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasCreatedEvent == rhs.hasCreatedEvent) && (!lhs.hasCreatedEvent || lhs.createdEvent == rhs.createdEvent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RenameConversationRequest, rhs: RenameConversationRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasNewName == rhs.hasNewName) && (!lhs.hasNewName || lhs.newName == rhs.newName)
  fieldCheck = fieldCheck && (lhs.hasEventRequestHeader == rhs.hasEventRequestHeader) && (!lhs.hasEventRequestHeader || lhs.eventRequestHeader == rhs.eventRequestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RenameConversationResponse, rhs: RenameConversationResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasCreatedEvent == rhs.hasCreatedEvent) && (!lhs.hasCreatedEvent || lhs.createdEvent == rhs.createdEvent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SearchEntitiesRequest, rhs: SearchEntitiesRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasQuery == rhs.hasQuery) && (!lhs.hasQuery || lhs.query == rhs.query)
  fieldCheck = fieldCheck && (lhs.hasMaxCount == rhs.hasMaxCount) && (!lhs.hasMaxCount || lhs.maxCount == rhs.maxCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SearchEntitiesResponse, rhs: SearchEntitiesResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SendChatMessageRequest, rhs: SendChatMessageRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.annotation == rhs.annotation)
  fieldCheck = fieldCheck && (lhs.hasMessageContent == rhs.hasMessageContent) && (!lhs.hasMessageContent || lhs.messageContent == rhs.messageContent)
  fieldCheck = fieldCheck && (lhs.hasExistingMedia == rhs.hasExistingMedia) && (!lhs.hasExistingMedia || lhs.existingMedia == rhs.existingMedia)
  fieldCheck = fieldCheck && (lhs.hasEventRequestHeader == rhs.hasEventRequestHeader) && (!lhs.hasEventRequestHeader || lhs.eventRequestHeader == rhs.eventRequestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SendChatMessageResponse, rhs: SendChatMessageResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasCreatedEvent == rhs.hasCreatedEvent) && (!lhs.hasCreatedEvent || lhs.createdEvent == rhs.createdEvent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SendOffnetworkInvitationRequest, rhs: SendOffnetworkInvitationRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasInviteeAddress == rhs.hasInviteeAddress) && (!lhs.hasInviteeAddress || lhs.inviteeAddress == rhs.inviteeAddress)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SendOffnetworkInvitationResponse, rhs: SendOffnetworkInvitationResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetActiveClientRequest, rhs: SetActiveClientRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasIsActive == rhs.hasIsActive) && (!lhs.hasIsActive || lhs.isActive == rhs.isActive)
  fieldCheck = fieldCheck && (lhs.hasFullJid == rhs.hasFullJid) && (!lhs.hasFullJid || lhs.fullJid == rhs.fullJid)
  fieldCheck = fieldCheck && (lhs.hasTimeoutSecs == rhs.hasTimeoutSecs) && (!lhs.hasTimeoutSecs || lhs.timeoutSecs == rhs.timeoutSecs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetActiveClientResponse, rhs: SetActiveClientResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetConversationLevelRequest, rhs: SetConversationLevelRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetConversationLevelResponse, rhs: SetConversationLevelResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetConversationNotificationLevelRequest, rhs: SetConversationNotificationLevelRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasLevel == rhs.hasLevel) && (!lhs.hasLevel || lhs.level == rhs.level)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetConversationNotificationLevelResponse, rhs: SetConversationNotificationLevelResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetFocusRequest, rhs: SetFocusRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasTimeoutSecs == rhs.hasTimeoutSecs) && (!lhs.hasTimeoutSecs || lhs.timeoutSecs == rhs.timeoutSecs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetFocusResponse, rhs: SetFocusResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetPresenceRequest, rhs: SetPresenceRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasPresenceStateSetting == rhs.hasPresenceStateSetting) && (!lhs.hasPresenceStateSetting || lhs.presenceStateSetting == rhs.presenceStateSetting)
  fieldCheck = fieldCheck && (lhs.hasDndSetting == rhs.hasDndSetting) && (!lhs.hasDndSetting || lhs.dndSetting == rhs.dndSetting)
  fieldCheck = fieldCheck && (lhs.hasDesktopOffSetting == rhs.hasDesktopOffSetting) && (!lhs.hasDesktopOffSetting || lhs.desktopOffSetting == rhs.desktopOffSetting)
  fieldCheck = fieldCheck && (lhs.hasMoodSetting == rhs.hasMoodSetting) && (!lhs.hasMoodSetting || lhs.moodSetting == rhs.moodSetting)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetPresenceResponse, rhs: SetPresenceResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetTypingRequest, rhs: SetTypingRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SetTypingResponse, rhs: SetTypingResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SyncAllNewEventsRequest, rhs: SyncAllNewEventsRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasLastSyncTimestamp == rhs.hasLastSyncTimestamp) && (!lhs.hasLastSyncTimestamp || lhs.lastSyncTimestamp == rhs.lastSyncTimestamp)
  fieldCheck = fieldCheck && (lhs.hasMaxResponseSizeBytes == rhs.hasMaxResponseSizeBytes) && (!lhs.hasMaxResponseSizeBytes || lhs.maxResponseSizeBytes == rhs.maxResponseSizeBytes)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SyncAllNewEventsResponse, rhs: SyncAllNewEventsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasSyncTimestamp == rhs.hasSyncTimestamp) && (!lhs.hasSyncTimestamp || lhs.syncTimestamp == rhs.syncTimestamp)
  fieldCheck = fieldCheck && (lhs.conversationState == rhs.conversationState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SyncRecentConversationsRequest, rhs: SyncRecentConversationsRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasMaxConversations == rhs.hasMaxConversations) && (!lhs.hasMaxConversations || lhs.maxConversations == rhs.maxConversations)
  fieldCheck = fieldCheck && (lhs.hasMaxEventsPerConversation == rhs.hasMaxEventsPerConversation) && (!lhs.hasMaxEventsPerConversation || lhs.maxEventsPerConversation == rhs.maxEventsPerConversation)
  fieldCheck = fieldCheck && (lhs.syncFilter == rhs.syncFilter)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SyncRecentConversationsResponse, rhs: SyncRecentConversationsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = fieldCheck && (lhs.hasSyncTimestamp == rhs.hasSyncTimestamp) && (!lhs.hasSyncTimestamp || lhs.syncTimestamp == rhs.syncTimestamp)
  fieldCheck = fieldCheck && (lhs.conversationState == rhs.conversationState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UpdateWatermarkRequest, rhs: UpdateWatermarkRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequestHeader == rhs.hasRequestHeader) && (!lhs.hasRequestHeader || lhs.requestHeader == rhs.requestHeader)
  fieldCheck = fieldCheck && (lhs.hasConversationId == rhs.hasConversationId) && (!lhs.hasConversationId || lhs.conversationId == rhs.conversationId)
  fieldCheck = fieldCheck && (lhs.hasLastReadTimestamp == rhs.hasLastReadTimestamp) && (!lhs.hasLastReadTimestamp || lhs.lastReadTimestamp == rhs.lastReadTimestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UpdateWatermarkResponse, rhs: UpdateWatermarkResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResponseHeader == rhs.hasResponseHeader) && (!lhs.hasResponseHeader || lhs.responseHeader == rhs.responseHeader)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct HangoutsRoot {
  public static var sharedInstance : HangoutsRoot {
   struct Static {
       static let instance : HangoutsRoot = HangoutsRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(_ registry:ExtensionRegistry) {
  }
}



//Enum type declaration start 

// Describes which Hangouts client is active.
public enum ActiveClientState:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  // No client is active.
  case ActiveClientStateNoActive = 0

  // This is the active client.
  case ActiveClientStateIsActive = 1

  // Other client is active.
  case ActiveClientStateOtherActive = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ActiveClientStateNoActive: return ".ActiveClientStateNoActive"
          case .ActiveClientStateIsActive: return ".ActiveClientStateIsActive"
          case .ActiveClientStateOtherActive: return ".ActiveClientStateOtherActive"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum FocusType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case FocusTypeUnknown = 0
  case FocusTypeFocused = 1
  case FocusTypeUnfocused = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .FocusTypeUnknown: return ".FocusTypeUnknown"
          case .FocusTypeFocused: return ".FocusTypeFocused"
          case .FocusTypeUnfocused: return ".FocusTypeUnfocused"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum FocusDevice:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case FocusDeviceUnspecified = 0
  case FocusDeviceDesktop = 20
  case FocusDeviceMobile = 300

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .FocusDeviceUnspecified: return ".FocusDeviceUnspecified"
          case .FocusDeviceDesktop: return ".FocusDeviceDesktop"
          case .FocusDeviceMobile: return ".FocusDeviceMobile"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum TypingType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case TypingTypeUnknown = 0

  // Started typing.
  case TypingTypeStarted = 1

  // Stopped typing with inputted text.
  case TypingTypePaused = 2

  // Stopped typing with no inputted text.
  case TypingTypeStopped = 3

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .TypingTypeUnknown: return ".TypingTypeUnknown"
          case .TypingTypeStarted: return ".TypingTypeStarted"
          case .TypingTypePaused: return ".TypingTypePaused"
          case .TypingTypeStopped: return ".TypingTypeStopped"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ClientPresenceStateType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ClientPresenceStateUnknown = 0
  case ClientPresenceStateNone = 1
  case ClientPresenceStateDesktopIdle = 30
  case ClientPresenceStateDesktopActive = 40

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ClientPresenceStateUnknown: return ".ClientPresenceStateUnknown"
          case .ClientPresenceStateNone: return ".ClientPresenceStateNone"
          case .ClientPresenceStateDesktopIdle: return ".ClientPresenceStateDesktopIdle"
          case .ClientPresenceStateDesktopActive: return ".ClientPresenceStateDesktopActive"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum NotificationLevel:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case NotificationLevelUnknown = 0

  // Notifications are disabled.
  case NotificationLevelQuiet = 10

  // Notifications are enabled.
  case NotificationLevelRing = 30

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .NotificationLevelUnknown: return ".NotificationLevelUnknown"
          case .NotificationLevelQuiet: return ".NotificationLevelQuiet"
          case .NotificationLevelRing: return ".NotificationLevelRing"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum SegmentType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  // Segment is text.
  case SegmentTypeText = 0

  // Segment is a line break.
  case SegmentTypeLineBreak = 1

  // Segment is hyperlinked text.
  case SegmentTypeLink = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .SegmentTypeText: return ".SegmentTypeText"
          case .SegmentTypeLineBreak: return ".SegmentTypeLineBreak"
          case .SegmentTypeLink: return ".SegmentTypeLink"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// A type of embedded item.
public enum ItemType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ItemTypeThing = 0

  // Google Plus photo.
  case ItemTypePlusPhoto = 249
  case ItemTypePlace = 335

  // Google Map place.
  case ItemTypePlaceV2 = 340

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ItemTypeThing: return ".ItemTypeThing"
          case .ItemTypePlusPhoto: return ".ItemTypePlusPhoto"
          case .ItemTypePlace: return ".ItemTypePlace"
          case .ItemTypePlaceV2: return ".ItemTypePlaceV2"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum MembershipChangeType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case MembershipChangeTypeJoin = 1
  case MembershipChangeTypeLeave = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .MembershipChangeTypeJoin: return ".MembershipChangeTypeJoin"
          case .MembershipChangeTypeLeave: return ".MembershipChangeTypeLeave"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum HangoutEventType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case HangoutEventTypeUnknown = 0
  case HangoutEventTypeStart = 1
  case HangoutEventTypeEnd = 2
  case HangoutEventTypeJoin = 3
  case HangoutEventTypeLeave = 4
  case HangoutEventTypeComingSoon = 5
  case HangoutEventTypeOngoing = 6

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .HangoutEventTypeUnknown: return ".HangoutEventTypeUnknown"
          case .HangoutEventTypeStart: return ".HangoutEventTypeStart"
          case .HangoutEventTypeEnd: return ".HangoutEventTypeEnd"
          case .HangoutEventTypeJoin: return ".HangoutEventTypeJoin"
          case .HangoutEventTypeLeave: return ".HangoutEventTypeLeave"
          case .HangoutEventTypeComingSoon: return ".HangoutEventTypeComingSoon"
          case .HangoutEventTypeOngoing: return ".HangoutEventTypeOngoing"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// Whether the OTR toggle is available to the user.
public enum OffTheRecordToggle:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case OffTheRecordToggleUnknown = 0
  case OffTheRecordToggleEnabled = 1
  case OffTheRecordToggleDisabled = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .OffTheRecordToggleUnknown: return ".OffTheRecordToggleUnknown"
          case .OffTheRecordToggleEnabled: return ".OffTheRecordToggleEnabled"
          case .OffTheRecordToggleDisabled: return ".OffTheRecordToggleDisabled"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum OffTheRecordStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case OffTheRecordStatusUnknown = 0

  // Conversation is off-the-record (history disabled).
  case OffTheRecordStatusOffTheRecord = 1

  // Conversation is on-the-record (history enabled).
  case OffTheRecordStatusOnTheRecord = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .OffTheRecordStatusUnknown: return ".OffTheRecordStatusUnknown"
          case .OffTheRecordStatusOffTheRecord: return ".OffTheRecordStatusOffTheRecord"
          case .OffTheRecordStatusOnTheRecord: return ".OffTheRecordStatusOnTheRecord"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum SourceType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case SourceTypeUnknown = 0

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .SourceTypeUnknown: return ".SourceTypeUnknown"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum EventType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case EventTypeUnknown = 0
  case EventTypeRegularChatMessage = 1
  case EventTypeSms = 2
  case EventTypeVoicemail = 3
  case EventTypeAddUser = 4
  case EventTypeRemoveUser = 5
  case EventTypeConversationRename = 6
  case EventTypeHangout = 7
  case EventTypePhoneCall = 8
  case EventTypeOtrModification = 9
  case EventTypePlanMutation = 10
  case EventTypeMms = 11
  case EventTypeDeprecated12 = 12

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .EventTypeUnknown: return ".EventTypeUnknown"
          case .EventTypeRegularChatMessage: return ".EventTypeRegularChatMessage"
          case .EventTypeSms: return ".EventTypeSms"
          case .EventTypeVoicemail: return ".EventTypeVoicemail"
          case .EventTypeAddUser: return ".EventTypeAddUser"
          case .EventTypeRemoveUser: return ".EventTypeRemoveUser"
          case .EventTypeConversationRename: return ".EventTypeConversationRename"
          case .EventTypeHangout: return ".EventTypeHangout"
          case .EventTypePhoneCall: return ".EventTypePhoneCall"
          case .EventTypeOtrModification: return ".EventTypeOtrModification"
          case .EventTypePlanMutation: return ".EventTypePlanMutation"
          case .EventTypeMms: return ".EventTypeMms"
          case .EventTypeDeprecated12: return ".EventTypeDeprecated12"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ConversationType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ConversationTypeUnknown = 0

  // Conversation is one-to-one (only 2 participants).
  case ConversationTypeOneToOne = 1

  // Conversation is group (any number of participants).
  case ConversationTypeGroup = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ConversationTypeUnknown: return ".ConversationTypeUnknown"
          case .ConversationTypeOneToOne: return ".ConversationTypeOneToOne"
          case .ConversationTypeGroup: return ".ConversationTypeGroup"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ConversationStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ConversationStatusUnknown = 0

  // User is invited to conversation.
  case ConversationStatusInvited = 1

  // User is participating in conversation.
  case ConversationStatusActive = 2

  // User has left conversation.
  case ConversationStatusLeft = 3

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ConversationStatusUnknown: return ".ConversationStatusUnknown"
          case .ConversationStatusInvited: return ".ConversationStatusInvited"
          case .ConversationStatusActive: return ".ConversationStatusActive"
          case .ConversationStatusLeft: return ".ConversationStatusLeft"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ConversationView:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ConversationViewUnknown = 0

  // Conversation is in inbox.
  case ConversationViewInbox = 1

  // Conversation has been archived.
  case ConversationViewArchived = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ConversationViewUnknown: return ".ConversationViewUnknown"
          case .ConversationViewInbox: return ".ConversationViewInbox"
          case .ConversationViewArchived: return ".ConversationViewArchived"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum DeliveryMediumType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case DeliveryMediumUnknown = 0
  case DeliveryMediumBabel = 1
  case DeliveryMediumGoogleVoice = 2
  case DeliveryMediumLocalSms = 3

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .DeliveryMediumUnknown: return ".DeliveryMediumUnknown"
          case .DeliveryMediumBabel: return ".DeliveryMediumBabel"
          case .DeliveryMediumGoogleVoice: return ".DeliveryMediumGoogleVoice"
          case .DeliveryMediumLocalSms: return ".DeliveryMediumLocalSms"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum InvitationAffinity:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case InviteAffinityUnknown = 0
  case InviteAffinityHigh = 1
  case InviteAffinityLow = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .InviteAffinityUnknown: return ".InviteAffinityUnknown"
          case .InviteAffinityHigh: return ".InviteAffinityHigh"
          case .InviteAffinityLow: return ".InviteAffinityLow"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ParticipantType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ParticipantTypeUnknown = 0
  case ParticipantTypeGaia = 2
  case ParticipantTypeGoogleVoice = 3

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ParticipantTypeUnknown: return ".ParticipantTypeUnknown"
          case .ParticipantTypeGaia: return ".ParticipantTypeGaia"
          case .ParticipantTypeGoogleVoice: return ".ParticipantTypeGoogleVoice"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum InvitationStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case InvitationStatusUnknown = 0
  case InvitationStatusPending = 1
  case InvitationStatusAccepted = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .InvitationStatusUnknown: return ".InvitationStatusUnknown"
          case .InvitationStatusPending: return ".InvitationStatusPending"
          case .InvitationStatusAccepted: return ".InvitationStatusAccepted"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ForceHistory:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ForceHistoryUnknown = 0
  case ForceHistoryNo = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ForceHistoryUnknown: return ".ForceHistoryUnknown"
          case .ForceHistoryNo: return ".ForceHistoryNo"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum NetworkType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case NetworkTypeUnknown = 0
  case NetworkTypeBabel = 1
  case NetworkTypeGoogleVoice = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .NetworkTypeUnknown: return ".NetworkTypeUnknown"
          case .NetworkTypeBabel: return ".NetworkTypeBabel"
          case .NetworkTypeGoogleVoice: return ".NetworkTypeGoogleVoice"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum BlockState:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case BlockStateUnknown = 0
  case BlockStateBlock = 1
  case BlockStateUnblock = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .BlockStateUnknown: return ".BlockStateUnknown"
          case .BlockStateBlock: return ".BlockStateBlock"
          case .BlockStateUnblock: return ".BlockStateUnblock"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ReplyToInviteType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ReplyToInviteTypeUnknown = 0
  case ReplyToInviteTypeAccept = 1
  case ReplyToInviteTypeDecline = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ReplyToInviteTypeUnknown: return ".ReplyToInviteTypeUnknown"
          case .ReplyToInviteTypeAccept: return ".ReplyToInviteTypeAccept"
          case .ReplyToInviteTypeDecline: return ".ReplyToInviteTypeDecline"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// Identifies the client.
public enum ClientId:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ClientIdUnknown = 0

  // Hangouts app for Android.
  case ClientIdAndroid = 1

  // Hangouts app for iOS.
  case ClientIdIos = 2

  // Hangouts Chrome extension.
  case ClientIdChrome = 3

  // Hangouts web interface in Google Plus.
  case ClientIdWebGplus = 5

  // Hangouts web interface in Gmail.
  case ClientIdWebGmail = 6

  // Hangouts Chrome app ("ultraviolet").
  case ClientIdUltraviolet = 13

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ClientIdUnknown: return ".ClientIdUnknown"
          case .ClientIdAndroid: return ".ClientIdAndroid"
          case .ClientIdIos: return ".ClientIdIos"
          case .ClientIdChrome: return ".ClientIdChrome"
          case .ClientIdWebGplus: return ".ClientIdWebGplus"
          case .ClientIdWebGmail: return ".ClientIdWebGmail"
          case .ClientIdUltraviolet: return ".ClientIdUltraviolet"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// Build type of the client.
public enum ClientBuildType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case BuildTypeUnknown = 0

  // Web app.
  case BuildTypeProductionWeb = 1

  // Native app.
  case BuildTypeProductionApp = 3

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .BuildTypeUnknown: return ".BuildTypeUnknown"
          case .BuildTypeProductionWeb: return ".BuildTypeProductionWeb"
          case .BuildTypeProductionApp: return ".BuildTypeProductionApp"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// Status of the response from the server to the client.
public enum ResponseStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ResponseStatusUnknown = 0
  case ResponseStatusOk = 1
  case ResponseStatusUnexpectedError = 3
  case ResponseStatusInvalidRequest = 4

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ResponseStatusUnknown: return ".ResponseStatusUnknown"
          case .ResponseStatusOk: return ".ResponseStatusOk"
          case .ResponseStatusUnexpectedError: return ".ResponseStatusUnexpectedError"
          case .ResponseStatusInvalidRequest: return ".ResponseStatusInvalidRequest"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// Status of EntityProperties.photo_url.
public enum PhotoUrlStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case PhotoUrlStatusUnknown = 0

  // URL is a placeholder.
  case PhotoUrlStatusPlaceholder = 1

  // URL is a photo set by the user.
  case PhotoUrlStatusUserPhoto = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .PhotoUrlStatusUnknown: return ".PhotoUrlStatusUnknown"
          case .PhotoUrlStatusPlaceholder: return ".PhotoUrlStatusPlaceholder"
          case .PhotoUrlStatusUserPhoto: return ".PhotoUrlStatusUserPhoto"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum Gender:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case GenderUnknown = 0
  case GenderMale = 1
  case GenderFemale = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .GenderUnknown: return ".GenderUnknown"
          case .GenderMale: return ".GenderMale"
          case .GenderFemale: return ".GenderFemale"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum ProfileType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ProfileTypeNone = 0
  case ProfileTypeEsUser = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ProfileTypeNone: return ".ProfileTypeNone"
          case .ProfileTypeEsUser: return ".ProfileTypeEsUser"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

// A type of binary configuration option.
public enum ConfigurationBitType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case ConfigurationBitTypeUnknown = 0
  case ConfigurationBitTypeUnknown1 = 1
  case ConfigurationBitTypeUnknown2 = 2
  case ConfigurationBitTypeUnknown3 = 3
  case ConfigurationBitTypeUnknown4 = 4
  case ConfigurationBitTypeUnknown5 = 5
  case ConfigurationBitTypeUnknown6 = 6
  case ConfigurationBitTypeUnknown7 = 7
  case ConfigurationBitTypeUnknown8 = 8
  case ConfigurationBitTypeUnknown9 = 9
  case ConfigurationBitTypeUnknown10 = 10
  case ConfigurationBitTypeUnknown11 = 11
  case ConfigurationBitTypeUnknown12 = 12
  case ConfigurationBitTypeUnknown13 = 13
  case ConfigurationBitTypeUnknown14 = 14
  case ConfigurationBitTypeUnknown15 = 15
  case ConfigurationBitTypeUnknown16 = 16
  case ConfigurationBitTypeUnknown17 = 17
  case ConfigurationBitTypeUnknown18 = 18
  case ConfigurationBitTypeUnknown19 = 19
  case ConfigurationBitTypeUnknown20 = 20
  case ConfigurationBitTypeUnknown21 = 21
  case ConfigurationBitTypeUnknown22 = 22
  case ConfigurationBitTypeUnknown23 = 23
  case ConfigurationBitTypeUnknown24 = 24
  case ConfigurationBitTypeUnknown25 = 25
  case ConfigurationBitTypeUnknown26 = 26
  case ConfigurationBitTypeUnknown27 = 27
  case ConfigurationBitTypeUnknown28 = 28
  case ConfigurationBitTypeUnknown29 = 29
  case ConfigurationBitTypeUnknown30 = 30
  case ConfigurationBitTypeUnknown31 = 31
  case ConfigurationBitTypeUnknown32 = 32
  case ConfigurationBitTypeUnknown33 = 33
  case ConfigurationBitTypeUnknown34 = 34
  case ConfigurationBitTypeUnknown35 = 35
  case ConfigurationBitTypeUnknown36 = 36

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .ConfigurationBitTypeUnknown: return ".ConfigurationBitTypeUnknown"
          case .ConfigurationBitTypeUnknown1: return ".ConfigurationBitTypeUnknown1"
          case .ConfigurationBitTypeUnknown2: return ".ConfigurationBitTypeUnknown2"
          case .ConfigurationBitTypeUnknown3: return ".ConfigurationBitTypeUnknown3"
          case .ConfigurationBitTypeUnknown4: return ".ConfigurationBitTypeUnknown4"
          case .ConfigurationBitTypeUnknown5: return ".ConfigurationBitTypeUnknown5"
          case .ConfigurationBitTypeUnknown6: return ".ConfigurationBitTypeUnknown6"
          case .ConfigurationBitTypeUnknown7: return ".ConfigurationBitTypeUnknown7"
          case .ConfigurationBitTypeUnknown8: return ".ConfigurationBitTypeUnknown8"
          case .ConfigurationBitTypeUnknown9: return ".ConfigurationBitTypeUnknown9"
          case .ConfigurationBitTypeUnknown10: return ".ConfigurationBitTypeUnknown10"
          case .ConfigurationBitTypeUnknown11: return ".ConfigurationBitTypeUnknown11"
          case .ConfigurationBitTypeUnknown12: return ".ConfigurationBitTypeUnknown12"
          case .ConfigurationBitTypeUnknown13: return ".ConfigurationBitTypeUnknown13"
          case .ConfigurationBitTypeUnknown14: return ".ConfigurationBitTypeUnknown14"
          case .ConfigurationBitTypeUnknown15: return ".ConfigurationBitTypeUnknown15"
          case .ConfigurationBitTypeUnknown16: return ".ConfigurationBitTypeUnknown16"
          case .ConfigurationBitTypeUnknown17: return ".ConfigurationBitTypeUnknown17"
          case .ConfigurationBitTypeUnknown18: return ".ConfigurationBitTypeUnknown18"
          case .ConfigurationBitTypeUnknown19: return ".ConfigurationBitTypeUnknown19"
          case .ConfigurationBitTypeUnknown20: return ".ConfigurationBitTypeUnknown20"
          case .ConfigurationBitTypeUnknown21: return ".ConfigurationBitTypeUnknown21"
          case .ConfigurationBitTypeUnknown22: return ".ConfigurationBitTypeUnknown22"
          case .ConfigurationBitTypeUnknown23: return ".ConfigurationBitTypeUnknown23"
          case .ConfigurationBitTypeUnknown24: return ".ConfigurationBitTypeUnknown24"
          case .ConfigurationBitTypeUnknown25: return ".ConfigurationBitTypeUnknown25"
          case .ConfigurationBitTypeUnknown26: return ".ConfigurationBitTypeUnknown26"
          case .ConfigurationBitTypeUnknown27: return ".ConfigurationBitTypeUnknown27"
          case .ConfigurationBitTypeUnknown28: return ".ConfigurationBitTypeUnknown28"
          case .ConfigurationBitTypeUnknown29: return ".ConfigurationBitTypeUnknown29"
          case .ConfigurationBitTypeUnknown30: return ".ConfigurationBitTypeUnknown30"
          case .ConfigurationBitTypeUnknown31: return ".ConfigurationBitTypeUnknown31"
          case .ConfigurationBitTypeUnknown32: return ".ConfigurationBitTypeUnknown32"
          case .ConfigurationBitTypeUnknown33: return ".ConfigurationBitTypeUnknown33"
          case .ConfigurationBitTypeUnknown34: return ".ConfigurationBitTypeUnknown34"
          case .ConfigurationBitTypeUnknown35: return ".ConfigurationBitTypeUnknown35"
          case .ConfigurationBitTypeUnknown36: return ".ConfigurationBitTypeUnknown36"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum RichPresenceType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case RichPresenceTypeUnknown = 0
  case RichPresenceTypeInCallState = 1
  case RichPresenceTypeUnknown3 = 3
  case RichPresenceTypeUnknown4 = 4
  case RichPresenceTypeUnknown5 = 5
  case RichPresenceTypeDevice = 2
  case RichPresenceTypeLastSeen = 6

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .RichPresenceTypeUnknown: return ".RichPresenceTypeUnknown"
          case .RichPresenceTypeInCallState: return ".RichPresenceTypeInCallState"
          case .RichPresenceTypeUnknown3: return ".RichPresenceTypeUnknown3"
          case .RichPresenceTypeUnknown4: return ".RichPresenceTypeUnknown4"
          case .RichPresenceTypeUnknown5: return ".RichPresenceTypeUnknown5"
          case .RichPresenceTypeDevice: return ".RichPresenceTypeDevice"
          case .RichPresenceTypeLastSeen: return ".RichPresenceTypeLastSeen"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum FieldMask:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case FieldMaskReachable = 1
  case FieldMaskAvailable = 2
  case FieldMaskMood = 3
  case FieldMaskInCall = 6
  case FieldMaskDevice = 7
  case FieldMaskLastSeen = 10

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .FieldMaskReachable: return ".FieldMaskReachable"
          case .FieldMaskAvailable: return ".FieldMaskAvailable"
          case .FieldMaskMood: return ".FieldMaskMood"
          case .FieldMaskInCall: return ".FieldMaskInCall"
          case .FieldMaskDevice: return ".FieldMaskDevice"
          case .FieldMaskLastSeen: return ".FieldMaskLastSeen"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum DeleteType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case DeleteTypeUnknown = 0
  case DeleteTypeUpperBound = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .DeleteTypeUnknown: return ".DeleteTypeUnknown"
          case .DeleteTypeUpperBound: return ".DeleteTypeUpperBound"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum SyncFilter:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case SyncFilterUnknown = 0
  case SyncFilterInbox = 1
  case SyncFilterArchived = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .SyncFilterUnknown: return ".SyncFilterUnknown"
          case .SyncFilterInbox: return ".SyncFilterInbox"
          case .SyncFilterArchived: return ".SyncFilterArchived"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum SoundState:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case SoundStateUnknown = 0
  case SoundStateOn = 1
  case SoundStateOff = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .SoundStateUnknown: return ".SoundStateUnknown"
          case .SoundStateOn: return ".SoundStateOn"
          case .SoundStateOff: return ".SoundStateOff"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum CallerIdSettingsMask:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case CallerIdSettingsMaskUnknown = 0
  case CallerIdSettingsMaskProvided = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .CallerIdSettingsMaskUnknown: return ".CallerIdSettingsMaskUnknown"
          case .CallerIdSettingsMaskProvided: return ".CallerIdSettingsMaskProvided"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum PhoneVerificationStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case PhoneVerificationStatusUnknown = 0
  case PhoneVerificationStatusVerified = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .PhoneVerificationStatusUnknown: return ".PhoneVerificationStatusUnknown"
          case .PhoneVerificationStatusVerified: return ".PhoneVerificationStatusVerified"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum PhoneDiscoverabilityStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case PhoneDiscoverabilityStatusUnknown = 0
  case PhoneDiscoverabilityStatusOptedInButNotDiscoverable = 2

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .PhoneDiscoverabilityStatusUnknown: return ".PhoneDiscoverabilityStatusUnknown"
          case .PhoneDiscoverabilityStatusOptedInButNotDiscoverable: return ".PhoneDiscoverabilityStatusOptedInButNotDiscoverable"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum PhoneValidationResult:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case PhoneValidationResultIsPossible = 0

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .PhoneValidationResultIsPossible: return ".PhoneValidationResultIsPossible"
      }
  }
}

//Enum type declaration end 



//Enum type declaration start 

public enum OffnetworkAddressType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
  case OffnetworkAddressTypeUnknown = 0
  case OffnetworkAddressTypeEmail = 1

  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .OffnetworkAddressTypeUnknown: return ".OffnetworkAddressTypeUnknown"
          case .OffnetworkAddressTypeEmail: return ".OffnetworkAddressTypeEmail"
      }
  }
}

//Enum type declaration end 

// The state of do-not-disturb mode. Not to be confused with DndSetting, which
// is used to change the state of do-not-disturb mode.
final public class DoNotDisturbSetting : GeneratedMessage, GeneratedMessageProtocol {
  // Whether do-not-disturb mode is enabled.
  public private(set) var doNotDisturb:Bool = false

  public private(set) var hasDoNotDisturb:Bool = false
  // Timestamp when do-not-disturb mode expires.
  public private(set) var expirationTimestamp:UInt64 = UInt64(0)

  public private(set) var hasExpirationTimestamp:Bool = false
  // Timestamp when this setting was applied. Not present when this message
  // comes from a notification.
  public private(set) var version:UInt64 = UInt64(0)

  public private(set) var hasVersion:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDoNotDisturb {
      try output.writeBool(1, value:doNotDisturb)
    }
    if hasExpirationTimestamp {
      try output.writeUInt64(2, value:expirationTimestamp)
    }
    if hasVersion {
      try output.writeUInt64(3, value:version)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDoNotDisturb {
      serialize_size += doNotDisturb.computeBoolSize(1)
    }
    if hasExpirationTimestamp {
      serialize_size += expirationTimestamp.computeUInt64Size(2)
    }
    if hasVersion {
      serialize_size += version.computeUInt64Size(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DoNotDisturbSetting> {
    var mergedArray = Array<DoNotDisturbSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DoNotDisturbSetting? {
    return try DoNotDisturbSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DoNotDisturbSetting {
    return try DoNotDisturbSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DoNotDisturbSetting.Builder {
    return DoNotDisturbSetting.classBuilder() as! DoNotDisturbSetting.Builder
  }
  public func getBuilder() -> DoNotDisturbSetting.Builder {
    return classBuilder() as! DoNotDisturbSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DoNotDisturbSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DoNotDisturbSetting.Builder()
  }
  public func toBuilder() throws -> DoNotDisturbSetting.Builder {
    return try DoNotDisturbSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DoNotDisturbSetting) throws -> DoNotDisturbSetting.Builder {
    return try DoNotDisturbSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDoNotDisturb {
      output += "\(indent) doNotDisturb: \(doNotDisturb) \n"
    }
    if hasExpirationTimestamp {
      output += "\(indent) expirationTimestamp: \(expirationTimestamp) \n"
    }
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDoNotDisturb {
             hashCode = (hashCode &* 31) &+ doNotDisturb.hashValue
          }
          if hasExpirationTimestamp {
             hashCode = (hashCode &* 31) &+ expirationTimestamp.hashValue
          }
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DoNotDisturbSetting"
  }
  override public func className() -> String {
      return "DoNotDisturbSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DoNotDisturbSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DoNotDisturbSetting = DoNotDisturbSetting()
    public func getMessage() -> DoNotDisturbSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDoNotDisturb:Bool {
         get {
              return builderResult.hasDoNotDisturb
         }
    }
    public var doNotDisturb:Bool {
         get {
              return builderResult.doNotDisturb
         }
         set (value) {
             builderResult.hasDoNotDisturb = true
             builderResult.doNotDisturb = value
         }
    }
    public func setDoNotDisturb(_ value:Bool) -> DoNotDisturbSetting.Builder {
      self.doNotDisturb = value
      return self
    }
    public func clearDoNotDisturb() -> DoNotDisturbSetting.Builder{
         builderResult.hasDoNotDisturb = false
         builderResult.doNotDisturb = false
         return self
    }
    public var hasExpirationTimestamp:Bool {
         get {
              return builderResult.hasExpirationTimestamp
         }
    }
    public var expirationTimestamp:UInt64 {
         get {
              return builderResult.expirationTimestamp
         }
         set (value) {
             builderResult.hasExpirationTimestamp = true
             builderResult.expirationTimestamp = value
         }
    }
    public func setExpirationTimestamp(_ value:UInt64) -> DoNotDisturbSetting.Builder {
      self.expirationTimestamp = value
      return self
    }
    public func clearExpirationTimestamp() -> DoNotDisturbSetting.Builder{
         builderResult.hasExpirationTimestamp = false
         builderResult.expirationTimestamp = UInt64(0)
         return self
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt64 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(_ value:UInt64) -> DoNotDisturbSetting.Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> DoNotDisturbSetting.Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DoNotDisturbSetting.Builder {
      builderResult = DoNotDisturbSetting()
      return self
    }
    public override func clone() throws -> DoNotDisturbSetting.Builder {
      return try DoNotDisturbSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DoNotDisturbSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DoNotDisturbSetting {
      let returnMe:DoNotDisturbSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DoNotDisturbSetting) throws -> DoNotDisturbSetting.Builder {
      if other == DoNotDisturbSetting() {
       return self
      }
      if other.hasDoNotDisturb {
           doNotDisturb = other.doNotDisturb
      }
      if other.hasExpirationTimestamp {
           expirationTimestamp = other.expirationTimestamp
      }
      if other.hasVersion {
           version = other.version
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DoNotDisturbSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DoNotDisturbSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          doNotDisturb = try input.readBool()

        case 16:
          expirationTimestamp = try input.readUInt64()

        case 24:
          version = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class NotificationSettings : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var dndSettings:DoNotDisturbSetting!
  public private(set) var hasDndSettings:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDndSettings {
      try output.writeMessage(1, value:dndSettings)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDndSettings {
        if let varSizedndSettings = dndSettings?.computeMessageSize(1) {
            serialize_size += varSizedndSettings
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<NotificationSettings> {
    var mergedArray = Array<NotificationSettings>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> NotificationSettings? {
    return try NotificationSettings.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationSettings {
    return try NotificationSettings.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> NotificationSettings.Builder {
    return NotificationSettings.classBuilder() as! NotificationSettings.Builder
  }
  public func getBuilder() -> NotificationSettings.Builder {
    return classBuilder() as! NotificationSettings.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return NotificationSettings.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return NotificationSettings.Builder()
  }
  public func toBuilder() throws -> NotificationSettings.Builder {
    return try NotificationSettings.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:NotificationSettings) throws -> NotificationSettings.Builder {
    return try NotificationSettings.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDndSettings {
      output += "\(indent) dndSettings {\n"
      if let outDescDndSettings = dndSettings {
        output += try outDescDndSettings.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDndSettings {
              if let hashValuedndSettings = dndSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedndSettings
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NotificationSettings"
  }
  override public func className() -> String {
      return "NotificationSettings"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return NotificationSettings.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:NotificationSettings = NotificationSettings()
    public func getMessage() -> NotificationSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDndSettings:Bool {
         get {
             return builderResult.hasDndSettings
         }
    }
    public var dndSettings:DoNotDisturbSetting! {
         get {
             if dndSettingsBuilder_ != nil {
                builderResult.dndSettings = dndSettingsBuilder_.getMessage()
             }
             return builderResult.dndSettings
         }
         set (value) {
             builderResult.hasDndSettings = true
             builderResult.dndSettings = value
         }
    }
    private var dndSettingsBuilder_:DoNotDisturbSetting.Builder! {
         didSet {
            builderResult.hasDndSettings = true
         }
    }
    public func getDndSettingsBuilder() -> DoNotDisturbSetting.Builder {
      if dndSettingsBuilder_ == nil {
         dndSettingsBuilder_ = DoNotDisturbSetting.Builder()
         builderResult.dndSettings = dndSettingsBuilder_.getMessage()
         if dndSettings != nil {
            try! dndSettingsBuilder_.mergeFrom(dndSettings)
         }
      }
      return dndSettingsBuilder_
    }
    public func setDndSettings(_ value:DoNotDisturbSetting!) -> NotificationSettings.Builder {
      self.dndSettings = value
      return self
    }
    public func mergeDndSettings(_ value:DoNotDisturbSetting) throws -> NotificationSettings.Builder {
      if builderResult.hasDndSettings {
        builderResult.dndSettings = try DoNotDisturbSetting.builderWithPrototype(builderResult.dndSettings).mergeFrom(value).buildPartial()
      } else {
        builderResult.dndSettings = value
      }
      builderResult.hasDndSettings = true
      return self
    }
    public func clearDndSettings() -> NotificationSettings.Builder {
      dndSettingsBuilder_ = nil
      builderResult.hasDndSettings = false
      builderResult.dndSettings = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> NotificationSettings.Builder {
      builderResult = NotificationSettings()
      return self
    }
    public override func clone() throws -> NotificationSettings.Builder {
      return try NotificationSettings.builderWithPrototype(builderResult)
    }
    public override func build() throws -> NotificationSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> NotificationSettings {
      let returnMe:NotificationSettings = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:NotificationSettings) throws -> NotificationSettings.Builder {
      if other == NotificationSettings() {
       return self
      }
      if (other.hasDndSettings) {
          try mergeDndSettings(other.dndSettings)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> NotificationSettings.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NotificationSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:DoNotDisturbSetting.Builder = DoNotDisturbSetting.Builder()
          if hasDndSettings {
            try subBuilder.mergeFrom(dndSettings)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          dndSettings = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Identifies a conversation.
final public class ConversationId : GeneratedMessage, GeneratedMessageProtocol {
  // Unique identifier for a conversation.
  public private(set) var id:String = ""

  public private(set) var hasId:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasId {
      try output.writeString(1, value:id)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeStringSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationId> {
    var mergedArray = Array<ConversationId>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationId? {
    return try ConversationId.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationId {
    return try ConversationId.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationId.Builder {
    return ConversationId.classBuilder() as! ConversationId.Builder
  }
  public func getBuilder() -> ConversationId.Builder {
    return classBuilder() as! ConversationId.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationId.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationId.Builder()
  }
  public func toBuilder() throws -> ConversationId.Builder {
    return try ConversationId.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationId) throws -> ConversationId.Builder {
    return try ConversationId.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationId"
  }
  override public func className() -> String {
      return "ConversationId"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationId.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationId = ConversationId()
    public func getMessage() -> ConversationId {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:String {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(_ value:String) -> ConversationId.Builder {
      self.id = value
      return self
    }
    public func clearId() -> ConversationId.Builder{
         builderResult.hasId = false
         builderResult.id = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationId.Builder {
      builderResult = ConversationId()
      return self
    }
    public override func clone() throws -> ConversationId.Builder {
      return try ConversationId.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationId {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationId {
      let returnMe:ConversationId = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationId) throws -> ConversationId.Builder {
      if other == ConversationId() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationId.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationId.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          id = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Identifies a user.
final public class ParticipantId : GeneratedMessage, GeneratedMessageProtocol {
  // Unique identifier for a user's Google account.
  public private(set) var gaiaId:String = ""

  public private(set) var hasGaiaId:Bool = false
  // Seems to always be the same as gaia_id.
  public private(set) var chatId:String = ""

  public private(set) var hasChatId:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasGaiaId {
      try output.writeString(1, value:gaiaId)
    }
    if hasChatId {
      try output.writeString(2, value:chatId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasGaiaId {
      serialize_size += gaiaId.computeStringSize(1)
    }
    if hasChatId {
      serialize_size += chatId.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ParticipantId> {
    var mergedArray = Array<ParticipantId>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ParticipantId? {
    return try ParticipantId.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ParticipantId {
    return try ParticipantId.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ParticipantId.Builder {
    return ParticipantId.classBuilder() as! ParticipantId.Builder
  }
  public func getBuilder() -> ParticipantId.Builder {
    return classBuilder() as! ParticipantId.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ParticipantId.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ParticipantId.Builder()
  }
  public func toBuilder() throws -> ParticipantId.Builder {
    return try ParticipantId.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ParticipantId) throws -> ParticipantId.Builder {
    return try ParticipantId.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasGaiaId {
      output += "\(indent) gaiaId: \(gaiaId) \n"
    }
    if hasChatId {
      output += "\(indent) chatId: \(chatId) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasGaiaId {
             hashCode = (hashCode &* 31) &+ gaiaId.hashValue
          }
          if hasChatId {
             hashCode = (hashCode &* 31) &+ chatId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ParticipantId"
  }
  override public func className() -> String {
      return "ParticipantId"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ParticipantId.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ParticipantId = ParticipantId()
    public func getMessage() -> ParticipantId {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasGaiaId:Bool {
         get {
              return builderResult.hasGaiaId
         }
    }
    public var gaiaId:String {
         get {
              return builderResult.gaiaId
         }
         set (value) {
             builderResult.hasGaiaId = true
             builderResult.gaiaId = value
         }
    }
    public func setGaiaId(_ value:String) -> ParticipantId.Builder {
      self.gaiaId = value
      return self
    }
    public func clearGaiaId() -> ParticipantId.Builder{
         builderResult.hasGaiaId = false
         builderResult.gaiaId = ""
         return self
    }
    public var hasChatId:Bool {
         get {
              return builderResult.hasChatId
         }
    }
    public var chatId:String {
         get {
              return builderResult.chatId
         }
         set (value) {
             builderResult.hasChatId = true
             builderResult.chatId = value
         }
    }
    public func setChatId(_ value:String) -> ParticipantId.Builder {
      self.chatId = value
      return self
    }
    public func clearChatId() -> ParticipantId.Builder{
         builderResult.hasChatId = false
         builderResult.chatId = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ParticipantId.Builder {
      builderResult = ParticipantId()
      return self
    }
    public override func clone() throws -> ParticipantId.Builder {
      return try ParticipantId.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ParticipantId {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ParticipantId {
      let returnMe:ParticipantId = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ParticipantId) throws -> ParticipantId.Builder {
      if other == ParticipantId() {
       return self
      }
      if other.hasGaiaId {
           gaiaId = other.gaiaId
      }
      if other.hasChatId {
           chatId = other.chatId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ParticipantId.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ParticipantId.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          gaiaId = try input.readString()

        case 18:
          chatId = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Indicates whether Hangouts is active (running in the foreground) on
// different types of devices.
final public class DeviceStatus : GeneratedMessage, GeneratedMessageProtocol {
  // True if a mobile phone is active.
  public private(set) var mobile:Bool = false

  public private(set) var hasMobile:Bool = false
  // True if a desktop or laptop is active.
  public private(set) var desktop:Bool = false

  public private(set) var hasDesktop:Bool = false
  // True if a tablet is active.
  public private(set) var tablet:Bool = false

  public private(set) var hasTablet:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMobile {
      try output.writeBool(1, value:mobile)
    }
    if hasDesktop {
      try output.writeBool(2, value:desktop)
    }
    if hasTablet {
      try output.writeBool(3, value:tablet)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMobile {
      serialize_size += mobile.computeBoolSize(1)
    }
    if hasDesktop {
      serialize_size += desktop.computeBoolSize(2)
    }
    if hasTablet {
      serialize_size += tablet.computeBoolSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeviceStatus> {
    var mergedArray = Array<DeviceStatus>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeviceStatus? {
    return try DeviceStatus.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeviceStatus {
    return try DeviceStatus.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeviceStatus.Builder {
    return DeviceStatus.classBuilder() as! DeviceStatus.Builder
  }
  public func getBuilder() -> DeviceStatus.Builder {
    return classBuilder() as! DeviceStatus.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeviceStatus.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeviceStatus.Builder()
  }
  public func toBuilder() throws -> DeviceStatus.Builder {
    return try DeviceStatus.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeviceStatus) throws -> DeviceStatus.Builder {
    return try DeviceStatus.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMobile {
      output += "\(indent) mobile: \(mobile) \n"
    }
    if hasDesktop {
      output += "\(indent) desktop: \(desktop) \n"
    }
    if hasTablet {
      output += "\(indent) tablet: \(tablet) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMobile {
             hashCode = (hashCode &* 31) &+ mobile.hashValue
          }
          if hasDesktop {
             hashCode = (hashCode &* 31) &+ desktop.hashValue
          }
          if hasTablet {
             hashCode = (hashCode &* 31) &+ tablet.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeviceStatus"
  }
  override public func className() -> String {
      return "DeviceStatus"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeviceStatus.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeviceStatus = DeviceStatus()
    public func getMessage() -> DeviceStatus {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMobile:Bool {
         get {
              return builderResult.hasMobile
         }
    }
    public var mobile:Bool {
         get {
              return builderResult.mobile
         }
         set (value) {
             builderResult.hasMobile = true
             builderResult.mobile = value
         }
    }
    public func setMobile(_ value:Bool) -> DeviceStatus.Builder {
      self.mobile = value
      return self
    }
    public func clearMobile() -> DeviceStatus.Builder{
         builderResult.hasMobile = false
         builderResult.mobile = false
         return self
    }
    public var hasDesktop:Bool {
         get {
              return builderResult.hasDesktop
         }
    }
    public var desktop:Bool {
         get {
              return builderResult.desktop
         }
         set (value) {
             builderResult.hasDesktop = true
             builderResult.desktop = value
         }
    }
    public func setDesktop(_ value:Bool) -> DeviceStatus.Builder {
      self.desktop = value
      return self
    }
    public func clearDesktop() -> DeviceStatus.Builder{
         builderResult.hasDesktop = false
         builderResult.desktop = false
         return self
    }
    public var hasTablet:Bool {
         get {
              return builderResult.hasTablet
         }
    }
    public var tablet:Bool {
         get {
              return builderResult.tablet
         }
         set (value) {
             builderResult.hasTablet = true
             builderResult.tablet = value
         }
    }
    public func setTablet(_ value:Bool) -> DeviceStatus.Builder {
      self.tablet = value
      return self
    }
    public func clearTablet() -> DeviceStatus.Builder{
         builderResult.hasTablet = false
         builderResult.tablet = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeviceStatus.Builder {
      builderResult = DeviceStatus()
      return self
    }
    public override func clone() throws -> DeviceStatus.Builder {
      return try DeviceStatus.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeviceStatus {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeviceStatus {
      let returnMe:DeviceStatus = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeviceStatus) throws -> DeviceStatus.Builder {
      if other == DeviceStatus() {
       return self
      }
      if other.hasMobile {
           mobile = other.mobile
      }
      if other.hasDesktop {
           desktop = other.desktop
      }
      if other.hasTablet {
           tablet = other.tablet
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeviceStatus.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeviceStatus.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          mobile = try input.readBool()

        case 16:
          desktop = try input.readBool()

        case 24:
          tablet = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class LastSeen : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var lastSeenTimestampUsec:UInt64 = UInt64(0)

  public private(set) var hasLastSeenTimestampUsec:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasLastSeenTimestampUsec {
      try output.writeUInt64(1, value:lastSeenTimestampUsec)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLastSeenTimestampUsec {
      serialize_size += lastSeenTimestampUsec.computeUInt64Size(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<LastSeen> {
    var mergedArray = Array<LastSeen>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> LastSeen? {
    return try LastSeen.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LastSeen {
    return try LastSeen.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> LastSeen.Builder {
    return LastSeen.classBuilder() as! LastSeen.Builder
  }
  public func getBuilder() -> LastSeen.Builder {
    return classBuilder() as! LastSeen.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return LastSeen.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return LastSeen.Builder()
  }
  public func toBuilder() throws -> LastSeen.Builder {
    return try LastSeen.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:LastSeen) throws -> LastSeen.Builder {
    return try LastSeen.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasLastSeenTimestampUsec {
      output += "\(indent) lastSeenTimestampUsec: \(lastSeenTimestampUsec) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLastSeenTimestampUsec {
             hashCode = (hashCode &* 31) &+ lastSeenTimestampUsec.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "LastSeen"
  }
  override public func className() -> String {
      return "LastSeen"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return LastSeen.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:LastSeen = LastSeen()
    public func getMessage() -> LastSeen {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasLastSeenTimestampUsec:Bool {
         get {
              return builderResult.hasLastSeenTimestampUsec
         }
    }
    public var lastSeenTimestampUsec:UInt64 {
         get {
              return builderResult.lastSeenTimestampUsec
         }
         set (value) {
             builderResult.hasLastSeenTimestampUsec = true
             builderResult.lastSeenTimestampUsec = value
         }
    }
    public func setLastSeenTimestampUsec(_ value:UInt64) -> LastSeen.Builder {
      self.lastSeenTimestampUsec = value
      return self
    }
    public func clearLastSeenTimestampUsec() -> LastSeen.Builder{
         builderResult.hasLastSeenTimestampUsec = false
         builderResult.lastSeenTimestampUsec = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> LastSeen.Builder {
      builderResult = LastSeen()
      return self
    }
    public override func clone() throws -> LastSeen.Builder {
      return try LastSeen.builderWithPrototype(builderResult)
    }
    public override func build() throws -> LastSeen {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> LastSeen {
      let returnMe:LastSeen = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:LastSeen) throws -> LastSeen.Builder {
      if other == LastSeen() {
       return self
      }
      if other.hasLastSeenTimestampUsec {
           lastSeenTimestampUsec = other.lastSeenTimestampUsec
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> LastSeen.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LastSeen.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          lastSeenTimestampUsec = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Presence : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var reachable:Bool = false

  public private(set) var hasReachable:Bool = false
  public private(set) var available:Bool = false

  public private(set) var hasAvailable:Bool = false
  public private(set) var deviceStatus:DeviceStatus!
  public private(set) var hasDeviceStatus:Bool = false
  public private(set) var moodMessage:MoodMessage!
  public private(set) var hasMoodMessage:Bool = false
  public private(set) var lastSeen:LastSeen!
  public private(set) var hasLastSeen:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodMessage {
     if !moodMessage.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasReachable {
      try output.writeBool(1, value:reachable)
    }
    if hasAvailable {
      try output.writeBool(2, value:available)
    }
    if hasDeviceStatus {
      try output.writeMessage(6, value:deviceStatus)
    }
    if hasMoodMessage {
      try output.writeMessage(9, value:moodMessage)
    }
    if hasLastSeen {
      try output.writeMessage(10, value:lastSeen)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasReachable {
      serialize_size += reachable.computeBoolSize(1)
    }
    if hasAvailable {
      serialize_size += available.computeBoolSize(2)
    }
    if hasDeviceStatus {
        if let varSizedeviceStatus = deviceStatus?.computeMessageSize(6) {
            serialize_size += varSizedeviceStatus
        }
    }
    if hasMoodMessage {
        if let varSizemoodMessage = moodMessage?.computeMessageSize(9) {
            serialize_size += varSizemoodMessage
        }
    }
    if hasLastSeen {
        if let varSizelastSeen = lastSeen?.computeMessageSize(10) {
            serialize_size += varSizelastSeen
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Presence> {
    var mergedArray = Array<Presence>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Presence? {
    return try Presence.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Presence {
    return try Presence.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Presence {
    return try Presence.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Presence {
    return try Presence.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Presence {
    return try Presence.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Presence {
    return try Presence.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Presence {
    return try Presence.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Presence.Builder {
    return Presence.classBuilder() as! Presence.Builder
  }
  public func getBuilder() -> Presence.Builder {
    return classBuilder() as! Presence.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Presence.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Presence.Builder()
  }
  public func toBuilder() throws -> Presence.Builder {
    return try Presence.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Presence) throws -> Presence.Builder {
    return try Presence.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasReachable {
      output += "\(indent) reachable: \(reachable) \n"
    }
    if hasAvailable {
      output += "\(indent) available: \(available) \n"
    }
    if hasDeviceStatus {
      output += "\(indent) deviceStatus {\n"
      if let outDescDeviceStatus = deviceStatus {
        output += try outDescDeviceStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMoodMessage {
      output += "\(indent) moodMessage {\n"
      if let outDescMoodMessage = moodMessage {
        output += try outDescMoodMessage.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLastSeen {
      output += "\(indent) lastSeen {\n"
      if let outDescLastSeen = lastSeen {
        output += try outDescLastSeen.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasReachable {
             hashCode = (hashCode &* 31) &+ reachable.hashValue
          }
          if hasAvailable {
             hashCode = (hashCode &* 31) &+ available.hashValue
          }
          if hasDeviceStatus {
              if let hashValuedeviceStatus = deviceStatus?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeviceStatus
              }
          }
          if hasMoodMessage {
              if let hashValuemoodMessage = moodMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodMessage
              }
          }
          if hasLastSeen {
              if let hashValuelastSeen = lastSeen?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuelastSeen
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Presence"
  }
  override public func className() -> String {
      return "Presence"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Presence.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Presence = Presence()
    public func getMessage() -> Presence {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasReachable:Bool {
         get {
              return builderResult.hasReachable
         }
    }
    public var reachable:Bool {
         get {
              return builderResult.reachable
         }
         set (value) {
             builderResult.hasReachable = true
             builderResult.reachable = value
         }
    }
    public func setReachable(_ value:Bool) -> Presence.Builder {
      self.reachable = value
      return self
    }
    public func clearReachable() -> Presence.Builder{
         builderResult.hasReachable = false
         builderResult.reachable = false
         return self
    }
    public var hasAvailable:Bool {
         get {
              return builderResult.hasAvailable
         }
    }
    public var available:Bool {
         get {
              return builderResult.available
         }
         set (value) {
             builderResult.hasAvailable = true
             builderResult.available = value
         }
    }
    public func setAvailable(_ value:Bool) -> Presence.Builder {
      self.available = value
      return self
    }
    public func clearAvailable() -> Presence.Builder{
         builderResult.hasAvailable = false
         builderResult.available = false
         return self
    }
    public var hasDeviceStatus:Bool {
         get {
             return builderResult.hasDeviceStatus
         }
    }
    public var deviceStatus:DeviceStatus! {
         get {
             if deviceStatusBuilder_ != nil {
                builderResult.deviceStatus = deviceStatusBuilder_.getMessage()
             }
             return builderResult.deviceStatus
         }
         set (value) {
             builderResult.hasDeviceStatus = true
             builderResult.deviceStatus = value
         }
    }
    private var deviceStatusBuilder_:DeviceStatus.Builder! {
         didSet {
            builderResult.hasDeviceStatus = true
         }
    }
    public func getDeviceStatusBuilder() -> DeviceStatus.Builder {
      if deviceStatusBuilder_ == nil {
         deviceStatusBuilder_ = DeviceStatus.Builder()
         builderResult.deviceStatus = deviceStatusBuilder_.getMessage()
         if deviceStatus != nil {
            try! deviceStatusBuilder_.mergeFrom(deviceStatus)
         }
      }
      return deviceStatusBuilder_
    }
    public func setDeviceStatus(_ value:DeviceStatus!) -> Presence.Builder {
      self.deviceStatus = value
      return self
    }
    public func mergeDeviceStatus(_ value:DeviceStatus) throws -> Presence.Builder {
      if builderResult.hasDeviceStatus {
        builderResult.deviceStatus = try DeviceStatus.builderWithPrototype(builderResult.deviceStatus).mergeFrom(value).buildPartial()
      } else {
        builderResult.deviceStatus = value
      }
      builderResult.hasDeviceStatus = true
      return self
    }
    public func clearDeviceStatus() -> Presence.Builder {
      deviceStatusBuilder_ = nil
      builderResult.hasDeviceStatus = false
      builderResult.deviceStatus = nil
      return self
    }
    public var hasMoodMessage:Bool {
         get {
             return builderResult.hasMoodMessage
         }
    }
    public var moodMessage:MoodMessage! {
         get {
             if moodMessageBuilder_ != nil {
                builderResult.moodMessage = moodMessageBuilder_.getMessage()
             }
             return builderResult.moodMessage
         }
         set (value) {
             builderResult.hasMoodMessage = true
             builderResult.moodMessage = value
         }
    }
    private var moodMessageBuilder_:MoodMessage.Builder! {
         didSet {
            builderResult.hasMoodMessage = true
         }
    }
    public func getMoodMessageBuilder() -> MoodMessage.Builder {
      if moodMessageBuilder_ == nil {
         moodMessageBuilder_ = MoodMessage.Builder()
         builderResult.moodMessage = moodMessageBuilder_.getMessage()
         if moodMessage != nil {
            try! moodMessageBuilder_.mergeFrom(moodMessage)
         }
      }
      return moodMessageBuilder_
    }
    public func setMoodMessage(_ value:MoodMessage!) -> Presence.Builder {
      self.moodMessage = value
      return self
    }
    public func mergeMoodMessage(_ value:MoodMessage) throws -> Presence.Builder {
      if builderResult.hasMoodMessage {
        builderResult.moodMessage = try MoodMessage.builderWithPrototype(builderResult.moodMessage).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodMessage = value
      }
      builderResult.hasMoodMessage = true
      return self
    }
    public func clearMoodMessage() -> Presence.Builder {
      moodMessageBuilder_ = nil
      builderResult.hasMoodMessage = false
      builderResult.moodMessage = nil
      return self
    }
    public var hasLastSeen:Bool {
         get {
             return builderResult.hasLastSeen
         }
    }
    public var lastSeen:LastSeen! {
         get {
             if lastSeenBuilder_ != nil {
                builderResult.lastSeen = lastSeenBuilder_.getMessage()
             }
             return builderResult.lastSeen
         }
         set (value) {
             builderResult.hasLastSeen = true
             builderResult.lastSeen = value
         }
    }
    private var lastSeenBuilder_:LastSeen.Builder! {
         didSet {
            builderResult.hasLastSeen = true
         }
    }
    public func getLastSeenBuilder() -> LastSeen.Builder {
      if lastSeenBuilder_ == nil {
         lastSeenBuilder_ = LastSeen.Builder()
         builderResult.lastSeen = lastSeenBuilder_.getMessage()
         if lastSeen != nil {
            try! lastSeenBuilder_.mergeFrom(lastSeen)
         }
      }
      return lastSeenBuilder_
    }
    public func setLastSeen(_ value:LastSeen!) -> Presence.Builder {
      self.lastSeen = value
      return self
    }
    public func mergeLastSeen(_ value:LastSeen) throws -> Presence.Builder {
      if builderResult.hasLastSeen {
        builderResult.lastSeen = try LastSeen.builderWithPrototype(builderResult.lastSeen).mergeFrom(value).buildPartial()
      } else {
        builderResult.lastSeen = value
      }
      builderResult.hasLastSeen = true
      return self
    }
    public func clearLastSeen() -> Presence.Builder {
      lastSeenBuilder_ = nil
      builderResult.hasLastSeen = false
      builderResult.lastSeen = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Presence.Builder {
      builderResult = Presence()
      return self
    }
    public override func clone() throws -> Presence.Builder {
      return try Presence.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Presence {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Presence {
      let returnMe:Presence = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Presence) throws -> Presence.Builder {
      if other == Presence() {
       return self
      }
      if other.hasReachable {
           reachable = other.reachable
      }
      if other.hasAvailable {
           available = other.available
      }
      if (other.hasDeviceStatus) {
          try mergeDeviceStatus(other.deviceStatus)
      }
      if (other.hasMoodMessage) {
          try mergeMoodMessage(other.moodMessage)
      }
      if (other.hasLastSeen) {
          try mergeLastSeen(other.lastSeen)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Presence.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Presence.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          reachable = try input.readBool()

        case 16:
          available = try input.readBool()

        case 50:
          let subBuilder:DeviceStatus.Builder = DeviceStatus.Builder()
          if hasDeviceStatus {
            try subBuilder.mergeFrom(deviceStatus)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deviceStatus = subBuilder.buildPartial()

        case 74:
          let subBuilder:MoodMessage.Builder = MoodMessage.Builder()
          if hasMoodMessage {
            try subBuilder.mergeFrom(moodMessage)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodMessage = subBuilder.buildPartial()

        case 82:
          let subBuilder:LastSeen.Builder = LastSeen.Builder()
          if hasLastSeen {
            try subBuilder.mergeFrom(lastSeen)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          lastSeen = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PresenceResult : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var userId:ParticipantId!
  public private(set) var hasUserId:Bool = false
  public private(set) var presence:Presence!
  public private(set) var hasPresence:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasPresence {
     if !presence.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasUserId {
      try output.writeMessage(1, value:userId)
    }
    if hasPresence {
      try output.writeMessage(2, value:presence)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUserId {
        if let varSizeuserId = userId?.computeMessageSize(1) {
            serialize_size += varSizeuserId
        }
    }
    if hasPresence {
        if let varSizepresence = presence?.computeMessageSize(2) {
            serialize_size += varSizepresence
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PresenceResult> {
    var mergedArray = Array<PresenceResult>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PresenceResult? {
    return try PresenceResult.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceResult {
    return try PresenceResult.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PresenceResult.Builder {
    return PresenceResult.classBuilder() as! PresenceResult.Builder
  }
  public func getBuilder() -> PresenceResult.Builder {
    return classBuilder() as! PresenceResult.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PresenceResult.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PresenceResult.Builder()
  }
  public func toBuilder() throws -> PresenceResult.Builder {
    return try PresenceResult.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PresenceResult) throws -> PresenceResult.Builder {
    return try PresenceResult.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasUserId {
      output += "\(indent) userId {\n"
      if let outDescUserId = userId {
        output += try outDescUserId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPresence {
      output += "\(indent) presence {\n"
      if let outDescPresence = presence {
        output += try outDescPresence.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUserId {
              if let hashValueuserId = userId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuserId
              }
          }
          if hasPresence {
              if let hashValuepresence = presence?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepresence
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PresenceResult"
  }
  override public func className() -> String {
      return "PresenceResult"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PresenceResult.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PresenceResult = PresenceResult()
    public func getMessage() -> PresenceResult {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUserId:Bool {
         get {
             return builderResult.hasUserId
         }
    }
    public var userId:ParticipantId! {
         get {
             if userIdBuilder_ != nil {
                builderResult.userId = userIdBuilder_.getMessage()
             }
             return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    private var userIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasUserId = true
         }
    }
    public func getUserIdBuilder() -> ParticipantId.Builder {
      if userIdBuilder_ == nil {
         userIdBuilder_ = ParticipantId.Builder()
         builderResult.userId = userIdBuilder_.getMessage()
         if userId != nil {
            try! userIdBuilder_.mergeFrom(userId)
         }
      }
      return userIdBuilder_
    }
    public func setUserId(_ value:ParticipantId!) -> PresenceResult.Builder {
      self.userId = value
      return self
    }
    public func mergeUserId(_ value:ParticipantId) throws -> PresenceResult.Builder {
      if builderResult.hasUserId {
        builderResult.userId = try ParticipantId.builderWithPrototype(builderResult.userId).mergeFrom(value).buildPartial()
      } else {
        builderResult.userId = value
      }
      builderResult.hasUserId = true
      return self
    }
    public func clearUserId() -> PresenceResult.Builder {
      userIdBuilder_ = nil
      builderResult.hasUserId = false
      builderResult.userId = nil
      return self
    }
    public var hasPresence:Bool {
         get {
             return builderResult.hasPresence
         }
    }
    public var presence:Presence! {
         get {
             if presenceBuilder_ != nil {
                builderResult.presence = presenceBuilder_.getMessage()
             }
             return builderResult.presence
         }
         set (value) {
             builderResult.hasPresence = true
             builderResult.presence = value
         }
    }
    private var presenceBuilder_:Presence.Builder! {
         didSet {
            builderResult.hasPresence = true
         }
    }
    public func getPresenceBuilder() -> Presence.Builder {
      if presenceBuilder_ == nil {
         presenceBuilder_ = Presence.Builder()
         builderResult.presence = presenceBuilder_.getMessage()
         if presence != nil {
            try! presenceBuilder_.mergeFrom(presence)
         }
      }
      return presenceBuilder_
    }
    public func setPresence(_ value:Presence!) -> PresenceResult.Builder {
      self.presence = value
      return self
    }
    public func mergePresence(_ value:Presence) throws -> PresenceResult.Builder {
      if builderResult.hasPresence {
        builderResult.presence = try Presence.builderWithPrototype(builderResult.presence).mergeFrom(value).buildPartial()
      } else {
        builderResult.presence = value
      }
      builderResult.hasPresence = true
      return self
    }
    public func clearPresence() -> PresenceResult.Builder {
      presenceBuilder_ = nil
      builderResult.hasPresence = false
      builderResult.presence = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PresenceResult.Builder {
      builderResult = PresenceResult()
      return self
    }
    public override func clone() throws -> PresenceResult.Builder {
      return try PresenceResult.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PresenceResult {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PresenceResult {
      let returnMe:PresenceResult = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PresenceResult) throws -> PresenceResult.Builder {
      if other == PresenceResult() {
       return self
      }
      if (other.hasUserId) {
          try mergeUserId(other.userId)
      }
      if (other.hasPresence) {
          try mergePresence(other.presence)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceResult.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceResult.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasUserId {
            try subBuilder.mergeFrom(userId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          userId = subBuilder.buildPartial()

        case 18:
          let subBuilder:Presence.Builder = Presence.Builder()
          if hasPresence {
            try subBuilder.mergeFrom(presence)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          presence = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ClientIdentifier : GeneratedMessage, GeneratedMessageProtocol {
  // (client_id in hangups).
  public private(set) var resource:String = ""

  public private(set) var hasResource:Bool = false
  // unknown (header_id in hangups).
  public private(set) var headerId:String = ""

  public private(set) var hasHeaderId:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResource {
      try output.writeString(1, value:resource)
    }
    if hasHeaderId {
      try output.writeString(2, value:headerId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResource {
      serialize_size += resource.computeStringSize(1)
    }
    if hasHeaderId {
      serialize_size += headerId.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ClientIdentifier> {
    var mergedArray = Array<ClientIdentifier>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ClientIdentifier? {
    return try ClientIdentifier.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientIdentifier {
    return try ClientIdentifier.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ClientIdentifier.Builder {
    return ClientIdentifier.classBuilder() as! ClientIdentifier.Builder
  }
  public func getBuilder() -> ClientIdentifier.Builder {
    return classBuilder() as! ClientIdentifier.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ClientIdentifier.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ClientIdentifier.Builder()
  }
  public func toBuilder() throws -> ClientIdentifier.Builder {
    return try ClientIdentifier.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ClientIdentifier) throws -> ClientIdentifier.Builder {
    return try ClientIdentifier.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResource {
      output += "\(indent) resource: \(resource) \n"
    }
    if hasHeaderId {
      output += "\(indent) headerId: \(headerId) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResource {
             hashCode = (hashCode &* 31) &+ resource.hashValue
          }
          if hasHeaderId {
             hashCode = (hashCode &* 31) &+ headerId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ClientIdentifier"
  }
  override public func className() -> String {
      return "ClientIdentifier"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ClientIdentifier.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ClientIdentifier = ClientIdentifier()
    public func getMessage() -> ClientIdentifier {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResource:Bool {
         get {
              return builderResult.hasResource
         }
    }
    public var resource:String {
         get {
              return builderResult.resource
         }
         set (value) {
             builderResult.hasResource = true
             builderResult.resource = value
         }
    }
    public func setResource(_ value:String) -> ClientIdentifier.Builder {
      self.resource = value
      return self
    }
    public func clearResource() -> ClientIdentifier.Builder{
         builderResult.hasResource = false
         builderResult.resource = ""
         return self
    }
    public var hasHeaderId:Bool {
         get {
              return builderResult.hasHeaderId
         }
    }
    public var headerId:String {
         get {
              return builderResult.headerId
         }
         set (value) {
             builderResult.hasHeaderId = true
             builderResult.headerId = value
         }
    }
    public func setHeaderId(_ value:String) -> ClientIdentifier.Builder {
      self.headerId = value
      return self
    }
    public func clearHeaderId() -> ClientIdentifier.Builder{
         builderResult.hasHeaderId = false
         builderResult.headerId = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ClientIdentifier.Builder {
      builderResult = ClientIdentifier()
      return self
    }
    public override func clone() throws -> ClientIdentifier.Builder {
      return try ClientIdentifier.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ClientIdentifier {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ClientIdentifier {
      let returnMe:ClientIdentifier = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ClientIdentifier) throws -> ClientIdentifier.Builder {
      if other == ClientIdentifier() {
       return self
      }
      if other.hasResource {
           resource = other.resource
      }
      if other.hasHeaderId {
           headerId = other.headerId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ClientIdentifier.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientIdentifier.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          resource = try input.readString()

        case 18:
          headerId = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ClientPresenceState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var identifier:ClientIdentifier!
  public private(set) var hasIdentifier:Bool = false
  public private(set) var state:ClientPresenceStateType = ClientPresenceStateType.ClientPresenceStateUnknown
  public private(set) var hasState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasIdentifier {
      try output.writeMessage(1, value:identifier)
    }
    if hasState {
      try output.writeEnum(2, value:state.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasIdentifier {
        if let varSizeidentifier = identifier?.computeMessageSize(1) {
            serialize_size += varSizeidentifier
        }
    }
    if (hasState) {
      serialize_size += state.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ClientPresenceState> {
    var mergedArray = Array<ClientPresenceState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ClientPresenceState? {
    return try ClientPresenceState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientPresenceState {
    return try ClientPresenceState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ClientPresenceState.Builder {
    return ClientPresenceState.classBuilder() as! ClientPresenceState.Builder
  }
  public func getBuilder() -> ClientPresenceState.Builder {
    return classBuilder() as! ClientPresenceState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ClientPresenceState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ClientPresenceState.Builder()
  }
  public func toBuilder() throws -> ClientPresenceState.Builder {
    return try ClientPresenceState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ClientPresenceState) throws -> ClientPresenceState.Builder {
    return try ClientPresenceState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasIdentifier {
      output += "\(indent) identifier {\n"
      if let outDescIdentifier = identifier {
        output += try outDescIdentifier.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasState) {
      output += "\(indent) state: \(state.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasIdentifier {
              if let hashValueidentifier = identifier?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueidentifier
              }
          }
          if hasState {
             hashCode = (hashCode &* 31) &+ Int(state.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ClientPresenceState"
  }
  override public func className() -> String {
      return "ClientPresenceState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ClientPresenceState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ClientPresenceState = ClientPresenceState()
    public func getMessage() -> ClientPresenceState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasIdentifier:Bool {
         get {
             return builderResult.hasIdentifier
         }
    }
    public var identifier:ClientIdentifier! {
         get {
             if identifierBuilder_ != nil {
                builderResult.identifier = identifierBuilder_.getMessage()
             }
             return builderResult.identifier
         }
         set (value) {
             builderResult.hasIdentifier = true
             builderResult.identifier = value
         }
    }
    private var identifierBuilder_:ClientIdentifier.Builder! {
         didSet {
            builderResult.hasIdentifier = true
         }
    }
    public func getIdentifierBuilder() -> ClientIdentifier.Builder {
      if identifierBuilder_ == nil {
         identifierBuilder_ = ClientIdentifier.Builder()
         builderResult.identifier = identifierBuilder_.getMessage()
         if identifier != nil {
            try! identifierBuilder_.mergeFrom(identifier)
         }
      }
      return identifierBuilder_
    }
    public func setIdentifier(_ value:ClientIdentifier!) -> ClientPresenceState.Builder {
      self.identifier = value
      return self
    }
    public func mergeIdentifier(_ value:ClientIdentifier) throws -> ClientPresenceState.Builder {
      if builderResult.hasIdentifier {
        builderResult.identifier = try ClientIdentifier.builderWithPrototype(builderResult.identifier).mergeFrom(value).buildPartial()
      } else {
        builderResult.identifier = value
      }
      builderResult.hasIdentifier = true
      return self
    }
    public func clearIdentifier() -> ClientPresenceState.Builder {
      identifierBuilder_ = nil
      builderResult.hasIdentifier = false
      builderResult.identifier = nil
      return self
    }
      public var hasState:Bool{
          get {
              return builderResult.hasState
          }
      }
      public var state:ClientPresenceStateType {
          get {
              return builderResult.state
          }
          set (value) {
              builderResult.hasState = true
              builderResult.state = value
          }
      }
      public func setState(_ value:ClientPresenceStateType) -> ClientPresenceState.Builder {
        self.state = value
        return self
      }
      public func clearState() -> ClientPresenceState.Builder {
         builderResult.hasState = false
         builderResult.state = .ClientPresenceStateUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ClientPresenceState.Builder {
      builderResult = ClientPresenceState()
      return self
    }
    public override func clone() throws -> ClientPresenceState.Builder {
      return try ClientPresenceState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ClientPresenceState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ClientPresenceState {
      let returnMe:ClientPresenceState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ClientPresenceState) throws -> ClientPresenceState.Builder {
      if other == ClientPresenceState() {
       return self
      }
      if (other.hasIdentifier) {
          try mergeIdentifier(other.identifier)
      }
      if other.hasState {
           state = other.state
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ClientPresenceState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientPresenceState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ClientIdentifier.Builder = ClientIdentifier.Builder()
          if hasIdentifier {
            try subBuilder.mergeFrom(identifier)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          identifier = subBuilder.buildPartial()

        case 16:
          let valueIntstate = try input.readEnum()
          if let enumsstate = ClientPresenceStateType(rawValue:valueIntstate){
               state = enumsstate
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntstate))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserEventState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var userId:ParticipantId!
  public private(set) var hasUserId:Bool = false
  public private(set) var clientGeneratedId:String = ""

  public private(set) var hasClientGeneratedId:Bool = false
  public private(set) var notificationLevel:NotificationLevel = NotificationLevel.NotificationLevelUnknown
  public private(set) var hasNotificationLevel:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasUserId {
      try output.writeMessage(1, value:userId)
    }
    if hasClientGeneratedId {
      try output.writeString(2, value:clientGeneratedId)
    }
    if hasNotificationLevel {
      try output.writeEnum(3, value:notificationLevel.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUserId {
        if let varSizeuserId = userId?.computeMessageSize(1) {
            serialize_size += varSizeuserId
        }
    }
    if hasClientGeneratedId {
      serialize_size += clientGeneratedId.computeStringSize(2)
    }
    if (hasNotificationLevel) {
      serialize_size += notificationLevel.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<UserEventState> {
    var mergedArray = Array<UserEventState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> UserEventState? {
    return try UserEventState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserEventState {
    return try UserEventState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserEventState.Builder {
    return UserEventState.classBuilder() as! UserEventState.Builder
  }
  public func getBuilder() -> UserEventState.Builder {
    return classBuilder() as! UserEventState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserEventState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserEventState.Builder()
  }
  public func toBuilder() throws -> UserEventState.Builder {
    return try UserEventState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:UserEventState) throws -> UserEventState.Builder {
    return try UserEventState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasUserId {
      output += "\(indent) userId {\n"
      if let outDescUserId = userId {
        output += try outDescUserId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasClientGeneratedId {
      output += "\(indent) clientGeneratedId: \(clientGeneratedId) \n"
    }
    if (hasNotificationLevel) {
      output += "\(indent) notificationLevel: \(notificationLevel.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUserId {
              if let hashValueuserId = userId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuserId
              }
          }
          if hasClientGeneratedId {
             hashCode = (hashCode &* 31) &+ clientGeneratedId.hashValue
          }
          if hasNotificationLevel {
             hashCode = (hashCode &* 31) &+ Int(notificationLevel.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserEventState"
  }
  override public func className() -> String {
      return "UserEventState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserEventState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserEventState = UserEventState()
    public func getMessage() -> UserEventState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUserId:Bool {
         get {
             return builderResult.hasUserId
         }
    }
    public var userId:ParticipantId! {
         get {
             if userIdBuilder_ != nil {
                builderResult.userId = userIdBuilder_.getMessage()
             }
             return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    private var userIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasUserId = true
         }
    }
    public func getUserIdBuilder() -> ParticipantId.Builder {
      if userIdBuilder_ == nil {
         userIdBuilder_ = ParticipantId.Builder()
         builderResult.userId = userIdBuilder_.getMessage()
         if userId != nil {
            try! userIdBuilder_.mergeFrom(userId)
         }
      }
      return userIdBuilder_
    }
    public func setUserId(_ value:ParticipantId!) -> UserEventState.Builder {
      self.userId = value
      return self
    }
    public func mergeUserId(_ value:ParticipantId) throws -> UserEventState.Builder {
      if builderResult.hasUserId {
        builderResult.userId = try ParticipantId.builderWithPrototype(builderResult.userId).mergeFrom(value).buildPartial()
      } else {
        builderResult.userId = value
      }
      builderResult.hasUserId = true
      return self
    }
    public func clearUserId() -> UserEventState.Builder {
      userIdBuilder_ = nil
      builderResult.hasUserId = false
      builderResult.userId = nil
      return self
    }
    public var hasClientGeneratedId:Bool {
         get {
              return builderResult.hasClientGeneratedId
         }
    }
    public var clientGeneratedId:String {
         get {
              return builderResult.clientGeneratedId
         }
         set (value) {
             builderResult.hasClientGeneratedId = true
             builderResult.clientGeneratedId = value
         }
    }
    public func setClientGeneratedId(_ value:String) -> UserEventState.Builder {
      self.clientGeneratedId = value
      return self
    }
    public func clearClientGeneratedId() -> UserEventState.Builder{
         builderResult.hasClientGeneratedId = false
         builderResult.clientGeneratedId = ""
         return self
    }
      public var hasNotificationLevel:Bool{
          get {
              return builderResult.hasNotificationLevel
          }
      }
      public var notificationLevel:NotificationLevel {
          get {
              return builderResult.notificationLevel
          }
          set (value) {
              builderResult.hasNotificationLevel = true
              builderResult.notificationLevel = value
          }
      }
      public func setNotificationLevel(_ value:NotificationLevel) -> UserEventState.Builder {
        self.notificationLevel = value
        return self
      }
      public func clearNotificationLevel() -> UserEventState.Builder {
         builderResult.hasNotificationLevel = false
         builderResult.notificationLevel = .NotificationLevelUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserEventState.Builder {
      builderResult = UserEventState()
      return self
    }
    public override func clone() throws -> UserEventState.Builder {
      return try UserEventState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserEventState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserEventState {
      let returnMe:UserEventState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:UserEventState) throws -> UserEventState.Builder {
      if other == UserEventState() {
       return self
      }
      if (other.hasUserId) {
          try mergeUserId(other.userId)
      }
      if other.hasClientGeneratedId {
           clientGeneratedId = other.clientGeneratedId
      }
      if other.hasNotificationLevel {
           notificationLevel = other.notificationLevel
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> UserEventState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserEventState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasUserId {
            try subBuilder.mergeFrom(userId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          userId = subBuilder.buildPartial()

        case 18:
          clientGeneratedId = try input.readString()

        case 24:
          let valueIntnotificationLevel = try input.readEnum()
          if let enumsnotificationLevel = NotificationLevel(rawValue:valueIntnotificationLevel){
               notificationLevel = enumsnotificationLevel
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntnotificationLevel))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Formatting : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var bold:Bool = false

  public private(set) var hasBold:Bool = false
  public private(set) var italic:Bool = false

  public private(set) var hasItalic:Bool = false
  public private(set) var strikethrough:Bool = false

  public private(set) var hasStrikethrough:Bool = false
  public private(set) var underline:Bool = false

  public private(set) var hasUnderline:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBold {
      try output.writeBool(1, value:bold)
    }
    if hasItalic {
      try output.writeBool(2, value:italic)
    }
    if hasStrikethrough {
      try output.writeBool(3, value:strikethrough)
    }
    if hasUnderline {
      try output.writeBool(4, value:underline)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBold {
      serialize_size += bold.computeBoolSize(1)
    }
    if hasItalic {
      serialize_size += italic.computeBoolSize(2)
    }
    if hasStrikethrough {
      serialize_size += strikethrough.computeBoolSize(3)
    }
    if hasUnderline {
      serialize_size += underline.computeBoolSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Formatting> {
    var mergedArray = Array<Formatting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Formatting? {
    return try Formatting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Formatting {
    return try Formatting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Formatting {
    return try Formatting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Formatting {
    return try Formatting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Formatting {
    return try Formatting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Formatting {
    return try Formatting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Formatting {
    return try Formatting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Formatting.Builder {
    return Formatting.classBuilder() as! Formatting.Builder
  }
  public func getBuilder() -> Formatting.Builder {
    return classBuilder() as! Formatting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Formatting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Formatting.Builder()
  }
  public func toBuilder() throws -> Formatting.Builder {
    return try Formatting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Formatting) throws -> Formatting.Builder {
    return try Formatting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasBold {
      output += "\(indent) bold: \(bold) \n"
    }
    if hasItalic {
      output += "\(indent) italic: \(italic) \n"
    }
    if hasStrikethrough {
      output += "\(indent) strikethrough: \(strikethrough) \n"
    }
    if hasUnderline {
      output += "\(indent) underline: \(underline) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBold {
             hashCode = (hashCode &* 31) &+ bold.hashValue
          }
          if hasItalic {
             hashCode = (hashCode &* 31) &+ italic.hashValue
          }
          if hasStrikethrough {
             hashCode = (hashCode &* 31) &+ strikethrough.hashValue
          }
          if hasUnderline {
             hashCode = (hashCode &* 31) &+ underline.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Formatting"
  }
  override public func className() -> String {
      return "Formatting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Formatting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Formatting = Formatting()
    public func getMessage() -> Formatting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBold:Bool {
         get {
              return builderResult.hasBold
         }
    }
    public var bold:Bool {
         get {
              return builderResult.bold
         }
         set (value) {
             builderResult.hasBold = true
             builderResult.bold = value
         }
    }
    public func setBold(_ value:Bool) -> Formatting.Builder {
      self.bold = value
      return self
    }
    public func clearBold() -> Formatting.Builder{
         builderResult.hasBold = false
         builderResult.bold = false
         return self
    }
    public var hasItalic:Bool {
         get {
              return builderResult.hasItalic
         }
    }
    public var italic:Bool {
         get {
              return builderResult.italic
         }
         set (value) {
             builderResult.hasItalic = true
             builderResult.italic = value
         }
    }
    public func setItalic(_ value:Bool) -> Formatting.Builder {
      self.italic = value
      return self
    }
    public func clearItalic() -> Formatting.Builder{
         builderResult.hasItalic = false
         builderResult.italic = false
         return self
    }
    public var hasStrikethrough:Bool {
         get {
              return builderResult.hasStrikethrough
         }
    }
    public var strikethrough:Bool {
         get {
              return builderResult.strikethrough
         }
         set (value) {
             builderResult.hasStrikethrough = true
             builderResult.strikethrough = value
         }
    }
    public func setStrikethrough(_ value:Bool) -> Formatting.Builder {
      self.strikethrough = value
      return self
    }
    public func clearStrikethrough() -> Formatting.Builder{
         builderResult.hasStrikethrough = false
         builderResult.strikethrough = false
         return self
    }
    public var hasUnderline:Bool {
         get {
              return builderResult.hasUnderline
         }
    }
    public var underline:Bool {
         get {
              return builderResult.underline
         }
         set (value) {
             builderResult.hasUnderline = true
             builderResult.underline = value
         }
    }
    public func setUnderline(_ value:Bool) -> Formatting.Builder {
      self.underline = value
      return self
    }
    public func clearUnderline() -> Formatting.Builder{
         builderResult.hasUnderline = false
         builderResult.underline = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Formatting.Builder {
      builderResult = Formatting()
      return self
    }
    public override func clone() throws -> Formatting.Builder {
      return try Formatting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Formatting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Formatting {
      let returnMe:Formatting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Formatting) throws -> Formatting.Builder {
      if other == Formatting() {
       return self
      }
      if other.hasBold {
           bold = other.bold
      }
      if other.hasItalic {
           italic = other.italic
      }
      if other.hasStrikethrough {
           strikethrough = other.strikethrough
      }
      if other.hasUnderline {
           underline = other.underline
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Formatting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Formatting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bold = try input.readBool()

        case 16:
          italic = try input.readBool()

        case 24:
          strikethrough = try input.readBool()

        case 32:
          underline = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class LinkData : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var linkTarget:String = ""

  public private(set) var hasLinkTarget:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasLinkTarget {
      try output.writeString(1, value:linkTarget)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLinkTarget {
      serialize_size += linkTarget.computeStringSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<LinkData> {
    var mergedArray = Array<LinkData>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> LinkData? {
    return try LinkData.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> LinkData {
    return try LinkData.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> LinkData {
    return try LinkData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> LinkData {
    return try LinkData.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> LinkData {
    return try LinkData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> LinkData {
    return try LinkData.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LinkData {
    return try LinkData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> LinkData.Builder {
    return LinkData.classBuilder() as! LinkData.Builder
  }
  public func getBuilder() -> LinkData.Builder {
    return classBuilder() as! LinkData.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return LinkData.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return LinkData.Builder()
  }
  public func toBuilder() throws -> LinkData.Builder {
    return try LinkData.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:LinkData) throws -> LinkData.Builder {
    return try LinkData.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasLinkTarget {
      output += "\(indent) linkTarget: \(linkTarget) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLinkTarget {
             hashCode = (hashCode &* 31) &+ linkTarget.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "LinkData"
  }
  override public func className() -> String {
      return "LinkData"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return LinkData.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:LinkData = LinkData()
    public func getMessage() -> LinkData {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasLinkTarget:Bool {
         get {
              return builderResult.hasLinkTarget
         }
    }
    public var linkTarget:String {
         get {
              return builderResult.linkTarget
         }
         set (value) {
             builderResult.hasLinkTarget = true
             builderResult.linkTarget = value
         }
    }
    public func setLinkTarget(_ value:String) -> LinkData.Builder {
      self.linkTarget = value
      return self
    }
    public func clearLinkTarget() -> LinkData.Builder{
         builderResult.hasLinkTarget = false
         builderResult.linkTarget = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> LinkData.Builder {
      builderResult = LinkData()
      return self
    }
    public override func clone() throws -> LinkData.Builder {
      return try LinkData.builderWithPrototype(builderResult)
    }
    public override func build() throws -> LinkData {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> LinkData {
      let returnMe:LinkData = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:LinkData) throws -> LinkData.Builder {
      if other == LinkData() {
       return self
      }
      if other.hasLinkTarget {
           linkTarget = other.linkTarget
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> LinkData.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LinkData.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          linkTarget = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// A segment of a message. Message are broken into segments that may be of
// different types and have different formatting.
final public class Segment : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var types:SegmentType = SegmentType.SegmentTypeText
  public private(set) var hasTypes:Bool = false
  // The segment text. For line breaks, may either be empty or contain new line
  // character.
  public private(set) var text:String = ""

  public private(set) var hasText:Bool = false
  public private(set) var formatting:Formatting!
  public private(set) var hasFormatting:Bool = false
  public private(set) var linkData:LinkData!
  public private(set) var hasLinkData:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasTypes {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    if hasText {
      try output.writeString(2, value:text)
    }
    if hasFormatting {
      try output.writeMessage(3, value:formatting)
    }
    if hasLinkData {
      try output.writeMessage(4, value:linkData)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    if hasText {
      serialize_size += text.computeStringSize(2)
    }
    if hasFormatting {
        if let varSizeformatting = formatting?.computeMessageSize(3) {
            serialize_size += varSizeformatting
        }
    }
    if hasLinkData {
        if let varSizelinkData = linkData?.computeMessageSize(4) {
            serialize_size += varSizelinkData
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Segment> {
    var mergedArray = Array<Segment>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Segment? {
    return try Segment.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Segment {
    return try Segment.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Segment {
    return try Segment.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Segment {
    return try Segment.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Segment {
    return try Segment.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Segment {
    return try Segment.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Segment {
    return try Segment.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Segment.Builder {
    return Segment.classBuilder() as! Segment.Builder
  }
  public func getBuilder() -> Segment.Builder {
    return classBuilder() as! Segment.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Segment.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Segment.Builder()
  }
  public func toBuilder() throws -> Segment.Builder {
    return try Segment.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Segment) throws -> Segment.Builder {
    return try Segment.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasText {
      output += "\(indent) text: \(text) \n"
    }
    if hasFormatting {
      output += "\(indent) formatting {\n"
      if let outDescFormatting = formatting {
        output += try outDescFormatting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLinkData {
      output += "\(indent) linkData {\n"
      if let outDescLinkData = linkData {
        output += try outDescLinkData.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasText {
             hashCode = (hashCode &* 31) &+ text.hashValue
          }
          if hasFormatting {
              if let hashValueformatting = formatting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueformatting
              }
          }
          if hasLinkData {
              if let hashValuelinkData = linkData?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuelinkData
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Segment"
  }
  override public func className() -> String {
      return "Segment"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Segment.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Segment = Segment()
    public func getMessage() -> Segment {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:SegmentType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:SegmentType) -> Segment.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> Segment.Builder {
         builderResult.hasTypes = false
         builderResult.types = .SegmentTypeText
         return self
      }
    public var hasText:Bool {
         get {
              return builderResult.hasText
         }
    }
    public var text:String {
         get {
              return builderResult.text
         }
         set (value) {
             builderResult.hasText = true
             builderResult.text = value
         }
    }
    public func setText(_ value:String) -> Segment.Builder {
      self.text = value
      return self
    }
    public func clearText() -> Segment.Builder{
         builderResult.hasText = false
         builderResult.text = ""
         return self
    }
    public var hasFormatting:Bool {
         get {
             return builderResult.hasFormatting
         }
    }
    public var formatting:Formatting! {
         get {
             if formattingBuilder_ != nil {
                builderResult.formatting = formattingBuilder_.getMessage()
             }
             return builderResult.formatting
         }
         set (value) {
             builderResult.hasFormatting = true
             builderResult.formatting = value
         }
    }
    private var formattingBuilder_:Formatting.Builder! {
         didSet {
            builderResult.hasFormatting = true
         }
    }
    public func getFormattingBuilder() -> Formatting.Builder {
      if formattingBuilder_ == nil {
         formattingBuilder_ = Formatting.Builder()
         builderResult.formatting = formattingBuilder_.getMessage()
         if formatting != nil {
            try! formattingBuilder_.mergeFrom(formatting)
         }
      }
      return formattingBuilder_
    }
    public func setFormatting(_ value:Formatting!) -> Segment.Builder {
      self.formatting = value
      return self
    }
    public func mergeFormatting(_ value:Formatting) throws -> Segment.Builder {
      if builderResult.hasFormatting {
        builderResult.formatting = try Formatting.builderWithPrototype(builderResult.formatting).mergeFrom(value).buildPartial()
      } else {
        builderResult.formatting = value
      }
      builderResult.hasFormatting = true
      return self
    }
    public func clearFormatting() -> Segment.Builder {
      formattingBuilder_ = nil
      builderResult.hasFormatting = false
      builderResult.formatting = nil
      return self
    }
    public var hasLinkData:Bool {
         get {
             return builderResult.hasLinkData
         }
    }
    public var linkData:LinkData! {
         get {
             if linkDataBuilder_ != nil {
                builderResult.linkData = linkDataBuilder_.getMessage()
             }
             return builderResult.linkData
         }
         set (value) {
             builderResult.hasLinkData = true
             builderResult.linkData = value
         }
    }
    private var linkDataBuilder_:LinkData.Builder! {
         didSet {
            builderResult.hasLinkData = true
         }
    }
    public func getLinkDataBuilder() -> LinkData.Builder {
      if linkDataBuilder_ == nil {
         linkDataBuilder_ = LinkData.Builder()
         builderResult.linkData = linkDataBuilder_.getMessage()
         if linkData != nil {
            try! linkDataBuilder_.mergeFrom(linkData)
         }
      }
      return linkDataBuilder_
    }
    public func setLinkData(_ value:LinkData!) -> Segment.Builder {
      self.linkData = value
      return self
    }
    public func mergeLinkData(_ value:LinkData) throws -> Segment.Builder {
      if builderResult.hasLinkData {
        builderResult.linkData = try LinkData.builderWithPrototype(builderResult.linkData).mergeFrom(value).buildPartial()
      } else {
        builderResult.linkData = value
      }
      builderResult.hasLinkData = true
      return self
    }
    public func clearLinkData() -> Segment.Builder {
      linkDataBuilder_ = nil
      builderResult.hasLinkData = false
      builderResult.linkData = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Segment.Builder {
      builderResult = Segment()
      return self
    }
    public override func clone() throws -> Segment.Builder {
      return try Segment.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Segment {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Segment {
      let returnMe:Segment = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Segment) throws -> Segment.Builder {
      if other == Segment() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasText {
           text = other.text
      }
      if (other.hasFormatting) {
          try mergeFormatting(other.formatting)
      }
      if (other.hasLinkData) {
          try mergeLinkData(other.linkData)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Segment.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Segment.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = SegmentType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 18:
          text = try input.readString()

        case 26:
          let subBuilder:Formatting.Builder = Formatting.Builder()
          if hasFormatting {
            try subBuilder.mergeFrom(formatting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          formatting = subBuilder.buildPartial()

        case 34:
          let subBuilder:LinkData.Builder = LinkData.Builder()
          if hasLinkData {
            try subBuilder.mergeFrom(linkData)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          linkData = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Google Plus photo that can be embedded in a chat message.
final public class PlusPhoto : GeneratedMessage, GeneratedMessageProtocol {


  //Nested type declaration start

    // Metadata for displaying an image thumbnail.
    final public class Thumbnail : GeneratedMessage, GeneratedMessageProtocol {
      // URL to navigate to when thumbnail is selected (a Google Plus album
      // page).
      public private(set) var url:String = ""

      public private(set) var hasUrl:Bool = false
      // URL of thumbnail image.
      public private(set) var imageUrl:String = ""

      public private(set) var hasImageUrl:Bool = false
      // Image width in pixels.
      public private(set) var widthPx:UInt64 = UInt64(0)

      public private(set) var hasWidthPx:Bool = false
      // Image height in pixels.
      public private(set) var heightPx:UInt64 = UInt64(0)

      public private(set) var hasHeightPx:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
        if hasUrl {
          try output.writeString(1, value:url)
        }
        if hasImageUrl {
          try output.writeString(4, value:imageUrl)
        }
        if hasWidthPx {
          try output.writeUInt64(10, value:widthPx)
        }
        if hasHeightPx {
          try output.writeUInt64(11, value:heightPx)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUrl {
          serialize_size += url.computeStringSize(1)
        }
        if hasImageUrl {
          serialize_size += imageUrl.computeStringSize(4)
        }
        if hasWidthPx {
          serialize_size += widthPx.computeUInt64Size(10)
        }
        if hasHeightPx {
          serialize_size += heightPx.computeUInt64Size(11)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PlusPhoto.Thumbnail> {
        var mergedArray = Array<PlusPhoto.Thumbnail>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PlusPhoto.Thumbnail? {
        return try PlusPhoto.Thumbnail.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(_ data:NSData) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(_ input:NSInputStream) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto.Thumbnail {
        return try PlusPhoto.Thumbnail.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> PlusPhoto.Thumbnail.Builder {
        return PlusPhoto.Thumbnail.classBuilder() as! PlusPhoto.Thumbnail.Builder
      }
      public func getBuilder() -> PlusPhoto.Thumbnail.Builder {
        return classBuilder() as! PlusPhoto.Thumbnail.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return PlusPhoto.Thumbnail.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return PlusPhoto.Thumbnail.Builder()
      }
      public func toBuilder() throws -> PlusPhoto.Thumbnail.Builder {
        return try PlusPhoto.Thumbnail.builderWithPrototype(self)
      }
      public class func builderWithPrototype(_ prototype:PlusPhoto.Thumbnail) throws -> PlusPhoto.Thumbnail.Builder {
        return try PlusPhoto.Thumbnail.Builder().mergeFrom(prototype)
      }
      override public func getDescription(_ indent:String) throws -> String {
        var output:String = ""
        if hasUrl {
          output += "\(indent) url: \(url) \n"
        }
        if hasImageUrl {
          output += "\(indent) imageUrl: \(imageUrl) \n"
        }
        if hasWidthPx {
          output += "\(indent) widthPx: \(widthPx) \n"
        }
        if hasHeightPx {
          output += "\(indent) heightPx: \(heightPx) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUrl {
                 hashCode = (hashCode &* 31) &+ url.hashValue
              }
              if hasImageUrl {
                 hashCode = (hashCode &* 31) &+ imageUrl.hashValue
              }
              if hasWidthPx {
                 hashCode = (hashCode &* 31) &+ widthPx.hashValue
              }
              if hasHeightPx {
                 hashCode = (hashCode &* 31) &+ heightPx.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "PlusPhoto.Thumbnail"
      }
      override public func className() -> String {
          return "PlusPhoto.Thumbnail"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return PlusPhoto.Thumbnail.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:PlusPhoto.Thumbnail = PlusPhoto.Thumbnail()
        public func getMessage() -> PlusPhoto.Thumbnail {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUrl:Bool {
             get {
                  return builderResult.hasUrl
             }
        }
        public var url:String {
             get {
                  return builderResult.url
             }
             set (value) {
                 builderResult.hasUrl = true
                 builderResult.url = value
             }
        }
        public func setUrl(_ value:String) -> PlusPhoto.Thumbnail.Builder {
          self.url = value
          return self
        }
        public func clearUrl() -> PlusPhoto.Thumbnail.Builder{
             builderResult.hasUrl = false
             builderResult.url = ""
             return self
        }
        public var hasImageUrl:Bool {
             get {
                  return builderResult.hasImageUrl
             }
        }
        public var imageUrl:String {
             get {
                  return builderResult.imageUrl
             }
             set (value) {
                 builderResult.hasImageUrl = true
                 builderResult.imageUrl = value
             }
        }
        public func setImageUrl(_ value:String) -> PlusPhoto.Thumbnail.Builder {
          self.imageUrl = value
          return self
        }
        public func clearImageUrl() -> PlusPhoto.Thumbnail.Builder{
             builderResult.hasImageUrl = false
             builderResult.imageUrl = ""
             return self
        }
        public var hasWidthPx:Bool {
             get {
                  return builderResult.hasWidthPx
             }
        }
        public var widthPx:UInt64 {
             get {
                  return builderResult.widthPx
             }
             set (value) {
                 builderResult.hasWidthPx = true
                 builderResult.widthPx = value
             }
        }
        public func setWidthPx(_ value:UInt64) -> PlusPhoto.Thumbnail.Builder {
          self.widthPx = value
          return self
        }
        public func clearWidthPx() -> PlusPhoto.Thumbnail.Builder{
             builderResult.hasWidthPx = false
             builderResult.widthPx = UInt64(0)
             return self
        }
        public var hasHeightPx:Bool {
             get {
                  return builderResult.hasHeightPx
             }
        }
        public var heightPx:UInt64 {
             get {
                  return builderResult.heightPx
             }
             set (value) {
                 builderResult.hasHeightPx = true
                 builderResult.heightPx = value
             }
        }
        public func setHeightPx(_ value:UInt64) -> PlusPhoto.Thumbnail.Builder {
          self.heightPx = value
          return self
        }
        public func clearHeightPx() -> PlusPhoto.Thumbnail.Builder{
             builderResult.hasHeightPx = false
             builderResult.heightPx = UInt64(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> PlusPhoto.Thumbnail.Builder {
          builderResult = PlusPhoto.Thumbnail()
          return self
        }
        public override func clone() throws -> PlusPhoto.Thumbnail.Builder {
          return try PlusPhoto.Thumbnail.builderWithPrototype(builderResult)
        }
        public override func build() throws -> PlusPhoto.Thumbnail {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> PlusPhoto.Thumbnail {
          let returnMe:PlusPhoto.Thumbnail = builderResult
          return returnMe
        }
        public func mergeFrom(_ other:PlusPhoto.Thumbnail) throws -> PlusPhoto.Thumbnail.Builder {
          if other == PlusPhoto.Thumbnail() {
           return self
          }
          if other.hasUrl {
               url = other.url
          }
          if other.hasImageUrl {
               imageUrl = other.imageUrl
          }
          if other.hasWidthPx {
               widthPx = other.widthPx
          }
          if other.hasHeightPx {
               heightPx = other.heightPx
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PlusPhoto.Thumbnail.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto.Thumbnail.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10:
              url = try input.readString()

            case 34:
              imageUrl = try input.readString()

            case 80:
              widthPx = try input.readUInt64()

            case 88:
              heightPx = try input.readUInt64()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



    //Enum type declaration start 

    // Media type.
    public enum MediaType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case MediaTypeUnknown = 0
      case MediaTypePhoto = 1
      case MediaTypeAnimatedPhoto = 4

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .MediaTypeUnknown: return ".MediaTypeUnknown"
              case .MediaTypePhoto: return ".MediaTypePhoto"
              case .MediaTypeAnimatedPhoto: return ".MediaTypeAnimatedPhoto"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var thumbnail:Thumbnail!
  public private(set) var hasThumbnail:Bool = false
  // Owner obfuscated ID.
  public private(set) var ownerObfuscatedId:String = ""

  public private(set) var hasOwnerObfuscatedId:Bool = false
  // Album ID.
  public private(set) var albumId:String = ""

  public private(set) var hasAlbumId:Bool = false
  // Photo ID.
  public private(set) var photoId:String = ""

  public private(set) var hasPhotoId:Bool = false
  // URL of full-sized image.
  public private(set) var url:String = ""

  public private(set) var hasUrl:Bool = false
  // URL of image thumbnail.
  public private(set) var originalContentUrl:String = ""

  public private(set) var hasOriginalContentUrl:Bool = false
  public private(set) var mediaType = PlusPhoto.MediaType.MediaTypeUnknown
  public private(set) var hasMediaType:Bool = false
  // List of stream ID parameters.
  public private(set) var streamId:Array<String> = Array<String>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasThumbnail {
      try output.writeMessage(1, value:thumbnail)
    }
    if hasOwnerObfuscatedId {
      try output.writeString(2, value:ownerObfuscatedId)
    }
    if hasAlbumId {
      try output.writeString(3, value:albumId)
    }
    if hasPhotoId {
      try output.writeString(4, value:photoId)
    }
    if hasUrl {
      try output.writeString(6, value:url)
    }
    if hasOriginalContentUrl {
      try output.writeString(10, value:originalContentUrl)
    }
    if hasMediaType {
      try output.writeEnum(13, value:mediaType.rawValue)
    }
    if !streamId.isEmpty {
      for oneValuestreamId in streamId {
        try output.writeString(14, value:oneValuestreamId)
      }
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasThumbnail {
        if let varSizethumbnail = thumbnail?.computeMessageSize(1) {
            serialize_size += varSizethumbnail
        }
    }
    if hasOwnerObfuscatedId {
      serialize_size += ownerObfuscatedId.computeStringSize(2)
    }
    if hasAlbumId {
      serialize_size += albumId.computeStringSize(3)
    }
    if hasPhotoId {
      serialize_size += photoId.computeStringSize(4)
    }
    if hasUrl {
      serialize_size += url.computeStringSize(6)
    }
    if hasOriginalContentUrl {
      serialize_size += originalContentUrl.computeStringSize(10)
    }
    if (hasMediaType) {
      serialize_size += mediaType.rawValue.computeEnumSize(13)
    }
    var dataSizeStreamId:Int32 = 0
    for oneValuestreamId in streamId {
        dataSizeStreamId += oneValuestreamId.computeStringSizeNoTag()
    }
    serialize_size += dataSizeStreamId
    serialize_size += 1 * Int32(streamId.count)
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PlusPhoto> {
    var mergedArray = Array<PlusPhoto>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PlusPhoto? {
    return try PlusPhoto.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto {
    return try PlusPhoto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PlusPhoto.Builder {
    return PlusPhoto.classBuilder() as! PlusPhoto.Builder
  }
  public func getBuilder() -> PlusPhoto.Builder {
    return classBuilder() as! PlusPhoto.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PlusPhoto.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PlusPhoto.Builder()
  }
  public func toBuilder() throws -> PlusPhoto.Builder {
    return try PlusPhoto.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PlusPhoto) throws -> PlusPhoto.Builder {
    return try PlusPhoto.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasThumbnail {
      output += "\(indent) thumbnail {\n"
      if let outDescThumbnail = thumbnail {
        output += try outDescThumbnail.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasOwnerObfuscatedId {
      output += "\(indent) ownerObfuscatedId: \(ownerObfuscatedId) \n"
    }
    if hasAlbumId {
      output += "\(indent) albumId: \(albumId) \n"
    }
    if hasPhotoId {
      output += "\(indent) photoId: \(photoId) \n"
    }
    if hasUrl {
      output += "\(indent) url: \(url) \n"
    }
    if hasOriginalContentUrl {
      output += "\(indent) originalContentUrl: \(originalContentUrl) \n"
    }
    if (hasMediaType) {
      output += "\(indent) mediaType: \(mediaType.description)\n"
    }
    var streamIdElementIndex:Int = 0
    for oneValuestreamId in streamId  {
        output += "\(indent) streamId[\(streamIdElementIndex)]: \(oneValuestreamId)\n"
        streamIdElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasThumbnail {
              if let hashValuethumbnail = thumbnail?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuethumbnail
              }
          }
          if hasOwnerObfuscatedId {
             hashCode = (hashCode &* 31) &+ ownerObfuscatedId.hashValue
          }
          if hasAlbumId {
             hashCode = (hashCode &* 31) &+ albumId.hashValue
          }
          if hasPhotoId {
             hashCode = (hashCode &* 31) &+ photoId.hashValue
          }
          if hasUrl {
             hashCode = (hashCode &* 31) &+ url.hashValue
          }
          if hasOriginalContentUrl {
             hashCode = (hashCode &* 31) &+ originalContentUrl.hashValue
          }
          if hasMediaType {
             hashCode = (hashCode &* 31) &+ Int(mediaType.rawValue)
          }
          for oneValuestreamId in streamId {
              hashCode = (hashCode &* 31) &+ oneValuestreamId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PlusPhoto"
  }
  override public func className() -> String {
      return "PlusPhoto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PlusPhoto.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PlusPhoto = PlusPhoto()
    public func getMessage() -> PlusPhoto {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasThumbnail:Bool {
         get {
             return builderResult.hasThumbnail
         }
    }
    public var thumbnail:PlusPhoto.Thumbnail! {
         get {
             if thumbnailBuilder_ != nil {
                builderResult.thumbnail = thumbnailBuilder_.getMessage()
             }
             return builderResult.thumbnail
         }
         set (value) {
             builderResult.hasThumbnail = true
             builderResult.thumbnail = value
         }
    }
    private var thumbnailBuilder_:PlusPhoto.Thumbnail.Builder! {
         didSet {
            builderResult.hasThumbnail = true
         }
    }
    public func getThumbnailBuilder() -> PlusPhoto.Thumbnail.Builder {
      if thumbnailBuilder_ == nil {
         thumbnailBuilder_ = PlusPhoto.Thumbnail.Builder()
         builderResult.thumbnail = thumbnailBuilder_.getMessage()
         if thumbnail != nil {
            try! thumbnailBuilder_.mergeFrom(thumbnail)
         }
      }
      return thumbnailBuilder_
    }
    public func setThumbnail(_ value:PlusPhoto.Thumbnail!) -> PlusPhoto.Builder {
      self.thumbnail = value
      return self
    }
    public func mergeThumbnail(_ value:PlusPhoto.Thumbnail) throws -> PlusPhoto.Builder {
      if builderResult.hasThumbnail {
        builderResult.thumbnail = try PlusPhoto.Thumbnail.builderWithPrototype(builderResult.thumbnail).mergeFrom(value).buildPartial()
      } else {
        builderResult.thumbnail = value
      }
      builderResult.hasThumbnail = true
      return self
    }
    public func clearThumbnail() -> PlusPhoto.Builder {
      thumbnailBuilder_ = nil
      builderResult.hasThumbnail = false
      builderResult.thumbnail = nil
      return self
    }
    public var hasOwnerObfuscatedId:Bool {
         get {
              return builderResult.hasOwnerObfuscatedId
         }
    }
    public var ownerObfuscatedId:String {
         get {
              return builderResult.ownerObfuscatedId
         }
         set (value) {
             builderResult.hasOwnerObfuscatedId = true
             builderResult.ownerObfuscatedId = value
         }
    }
    public func setOwnerObfuscatedId(_ value:String) -> PlusPhoto.Builder {
      self.ownerObfuscatedId = value
      return self
    }
    public func clearOwnerObfuscatedId() -> PlusPhoto.Builder{
         builderResult.hasOwnerObfuscatedId = false
         builderResult.ownerObfuscatedId = ""
         return self
    }
    public var hasAlbumId:Bool {
         get {
              return builderResult.hasAlbumId
         }
    }
    public var albumId:String {
         get {
              return builderResult.albumId
         }
         set (value) {
             builderResult.hasAlbumId = true
             builderResult.albumId = value
         }
    }
    public func setAlbumId(_ value:String) -> PlusPhoto.Builder {
      self.albumId = value
      return self
    }
    public func clearAlbumId() -> PlusPhoto.Builder{
         builderResult.hasAlbumId = false
         builderResult.albumId = ""
         return self
    }
    public var hasPhotoId:Bool {
         get {
              return builderResult.hasPhotoId
         }
    }
    public var photoId:String {
         get {
              return builderResult.photoId
         }
         set (value) {
             builderResult.hasPhotoId = true
             builderResult.photoId = value
         }
    }
    public func setPhotoId(_ value:String) -> PlusPhoto.Builder {
      self.photoId = value
      return self
    }
    public func clearPhotoId() -> PlusPhoto.Builder{
         builderResult.hasPhotoId = false
         builderResult.photoId = ""
         return self
    }
    public var hasUrl:Bool {
         get {
              return builderResult.hasUrl
         }
    }
    public var url:String {
         get {
              return builderResult.url
         }
         set (value) {
             builderResult.hasUrl = true
             builderResult.url = value
         }
    }
    public func setUrl(_ value:String) -> PlusPhoto.Builder {
      self.url = value
      return self
    }
    public func clearUrl() -> PlusPhoto.Builder{
         builderResult.hasUrl = false
         builderResult.url = ""
         return self
    }
    public var hasOriginalContentUrl:Bool {
         get {
              return builderResult.hasOriginalContentUrl
         }
    }
    public var originalContentUrl:String {
         get {
              return builderResult.originalContentUrl
         }
         set (value) {
             builderResult.hasOriginalContentUrl = true
             builderResult.originalContentUrl = value
         }
    }
    public func setOriginalContentUrl(_ value:String) -> PlusPhoto.Builder {
      self.originalContentUrl = value
      return self
    }
    public func clearOriginalContentUrl() -> PlusPhoto.Builder{
         builderResult.hasOriginalContentUrl = false
         builderResult.originalContentUrl = ""
         return self
    }
      public var hasMediaType:Bool{
          get {
              return builderResult.hasMediaType
          }
      }
      public var mediaType:PlusPhoto.MediaType {
          get {
              return builderResult.mediaType
          }
          set (value) {
              builderResult.hasMediaType = true
              builderResult.mediaType = value
          }
      }
      public func setMediaType(_ value:PlusPhoto.MediaType) -> PlusPhoto.Builder {
        self.mediaType = value
        return self
      }
      public func clearMediaType() -> PlusPhoto.Builder {
         builderResult.hasMediaType = false
         builderResult.mediaType = .MediaTypeUnknown
         return self
      }
    public var streamId:Array<String> {
         get {
             return builderResult.streamId
         }
         set (array) {
             builderResult.streamId = array
         }
    }
    public func setStreamId(_ value:Array<String>) -> PlusPhoto.Builder {
      self.streamId = value
      return self
    }
    public func clearStreamId() -> PlusPhoto.Builder {
       builderResult.streamId.removeAll(keepingCapacity: false)
       return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PlusPhoto.Builder {
      builderResult = PlusPhoto()
      return self
    }
    public override func clone() throws -> PlusPhoto.Builder {
      return try PlusPhoto.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PlusPhoto {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PlusPhoto {
      let returnMe:PlusPhoto = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PlusPhoto) throws -> PlusPhoto.Builder {
      if other == PlusPhoto() {
       return self
      }
      if (other.hasThumbnail) {
          try mergeThumbnail(other.thumbnail)
      }
      if other.hasOwnerObfuscatedId {
           ownerObfuscatedId = other.ownerObfuscatedId
      }
      if other.hasAlbumId {
           albumId = other.albumId
      }
      if other.hasPhotoId {
           photoId = other.photoId
      }
      if other.hasUrl {
           url = other.url
      }
      if other.hasOriginalContentUrl {
           originalContentUrl = other.originalContentUrl
      }
      if other.hasMediaType {
           mediaType = other.mediaType
      }
      if !other.streamId.isEmpty {
          builderResult.streamId += other.streamId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PlusPhoto.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlusPhoto.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PlusPhoto.Thumbnail.Builder = PlusPhoto.Thumbnail.Builder()
          if hasThumbnail {
            try subBuilder.mergeFrom(thumbnail)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          thumbnail = subBuilder.buildPartial()

        case 18:
          ownerObfuscatedId = try input.readString()

        case 26:
          albumId = try input.readString()

        case 34:
          photoId = try input.readString()

        case 50:
          url = try input.readString()

        case 82:
          originalContentUrl = try input.readString()

        case 104:
          let valueIntmediaType = try input.readEnum()
          if let enumsmediaType = PlusPhoto.MediaType(rawValue:valueIntmediaType){
               mediaType = enumsmediaType
          } else {
               try unknownFieldsBuilder.mergeVarintField(13, value:Int64(valueIntmediaType))
          }

        case 114:
          streamId += [try input.readString()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Place that can be embedded in a chat message via Google Maps.
final public class Place : GeneratedMessage, GeneratedMessageProtocol {


  //Nested type declaration start

    // Representative image of a place.
    final public class RepresentativeImage : GeneratedMessage, GeneratedMessageProtocol {
      // URL of image.
      public private(set) var url:String = ""

      public private(set) var hasUrl:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
        if hasUrl {
          try output.writeString(2, value:url)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUrl {
          serialize_size += url.computeStringSize(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Place.RepresentativeImage> {
        var mergedArray = Array<Place.RepresentativeImage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Place.RepresentativeImage? {
        return try Place.RepresentativeImage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(_ data:NSData) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(_ input:NSInputStream) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Place.RepresentativeImage {
        return try Place.RepresentativeImage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> Place.RepresentativeImage.Builder {
        return Place.RepresentativeImage.classBuilder() as! Place.RepresentativeImage.Builder
      }
      public func getBuilder() -> Place.RepresentativeImage.Builder {
        return classBuilder() as! Place.RepresentativeImage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return Place.RepresentativeImage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return Place.RepresentativeImage.Builder()
      }
      public func toBuilder() throws -> Place.RepresentativeImage.Builder {
        return try Place.RepresentativeImage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(_ prototype:Place.RepresentativeImage) throws -> Place.RepresentativeImage.Builder {
        return try Place.RepresentativeImage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(_ indent:String) throws -> String {
        var output:String = ""
        if hasUrl {
          output += "\(indent) url: \(url) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUrl {
                 hashCode = (hashCode &* 31) &+ url.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "Place.RepresentativeImage"
      }
      override public func className() -> String {
          return "Place.RepresentativeImage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return Place.RepresentativeImage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:Place.RepresentativeImage = Place.RepresentativeImage()
        public func getMessage() -> Place.RepresentativeImage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUrl:Bool {
             get {
                  return builderResult.hasUrl
             }
        }
        public var url:String {
             get {
                  return builderResult.url
             }
             set (value) {
                 builderResult.hasUrl = true
                 builderResult.url = value
             }
        }
        public func setUrl(_ value:String) -> Place.RepresentativeImage.Builder {
          self.url = value
          return self
        }
        public func clearUrl() -> Place.RepresentativeImage.Builder{
             builderResult.hasUrl = false
             builderResult.url = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> Place.RepresentativeImage.Builder {
          builderResult = Place.RepresentativeImage()
          return self
        }
        public override func clone() throws -> Place.RepresentativeImage.Builder {
          return try Place.RepresentativeImage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> Place.RepresentativeImage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> Place.RepresentativeImage {
          let returnMe:Place.RepresentativeImage = builderResult
          return returnMe
        }
        public func mergeFrom(_ other:Place.RepresentativeImage) throws -> Place.RepresentativeImage.Builder {
          if other == Place.RepresentativeImage() {
           return self
          }
          if other.hasUrl {
               url = other.url
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Place.RepresentativeImage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Place.RepresentativeImage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 18:
              url = try input.readString()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end

  // Google Maps URL pointing to the map coordinates.
  public private(set) var url:String = ""

  public private(set) var hasUrl:Bool = false
  // Name of map location.
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var representativeImage:RepresentativeImage!
  public private(set) var hasRepresentativeImage:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasUrl {
      try output.writeString(1, value:url)
    }
    if hasName {
      try output.writeString(3, value:name)
    }
    if hasRepresentativeImage {
      try output.writeMessage(185, value:representativeImage)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUrl {
      serialize_size += url.computeStringSize(1)
    }
    if hasName {
      serialize_size += name.computeStringSize(3)
    }
    if hasRepresentativeImage {
        if let varSizerepresentativeImage = representativeImage?.computeMessageSize(185) {
            serialize_size += varSizerepresentativeImage
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Place> {
    var mergedArray = Array<Place>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Place? {
    return try Place.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Place {
    return try Place.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Place {
    return try Place.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Place {
    return try Place.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Place {
    return try Place.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Place {
    return try Place.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Place {
    return try Place.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Place.Builder {
    return Place.classBuilder() as! Place.Builder
  }
  public func getBuilder() -> Place.Builder {
    return classBuilder() as! Place.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Place.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Place.Builder()
  }
  public func toBuilder() throws -> Place.Builder {
    return try Place.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Place) throws -> Place.Builder {
    return try Place.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasUrl {
      output += "\(indent) url: \(url) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasRepresentativeImage {
      output += "\(indent) representativeImage {\n"
      if let outDescRepresentativeImage = representativeImage {
        output += try outDescRepresentativeImage.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUrl {
             hashCode = (hashCode &* 31) &+ url.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasRepresentativeImage {
              if let hashValuerepresentativeImage = representativeImage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerepresentativeImage
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Place"
  }
  override public func className() -> String {
      return "Place"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Place.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Place = Place()
    public func getMessage() -> Place {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUrl:Bool {
         get {
              return builderResult.hasUrl
         }
    }
    public var url:String {
         get {
              return builderResult.url
         }
         set (value) {
             builderResult.hasUrl = true
             builderResult.url = value
         }
    }
    public func setUrl(_ value:String) -> Place.Builder {
      self.url = value
      return self
    }
    public func clearUrl() -> Place.Builder{
         builderResult.hasUrl = false
         builderResult.url = ""
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> Place.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Place.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasRepresentativeImage:Bool {
         get {
             return builderResult.hasRepresentativeImage
         }
    }
    public var representativeImage:Place.RepresentativeImage! {
         get {
             if representativeImageBuilder_ != nil {
                builderResult.representativeImage = representativeImageBuilder_.getMessage()
             }
             return builderResult.representativeImage
         }
         set (value) {
             builderResult.hasRepresentativeImage = true
             builderResult.representativeImage = value
         }
    }
    private var representativeImageBuilder_:Place.RepresentativeImage.Builder! {
         didSet {
            builderResult.hasRepresentativeImage = true
         }
    }
    public func getRepresentativeImageBuilder() -> Place.RepresentativeImage.Builder {
      if representativeImageBuilder_ == nil {
         representativeImageBuilder_ = Place.RepresentativeImage.Builder()
         builderResult.representativeImage = representativeImageBuilder_.getMessage()
         if representativeImage != nil {
            try! representativeImageBuilder_.mergeFrom(representativeImage)
         }
      }
      return representativeImageBuilder_
    }
    public func setRepresentativeImage(_ value:Place.RepresentativeImage!) -> Place.Builder {
      self.representativeImage = value
      return self
    }
    public func mergeRepresentativeImage(_ value:Place.RepresentativeImage) throws -> Place.Builder {
      if builderResult.hasRepresentativeImage {
        builderResult.representativeImage = try Place.RepresentativeImage.builderWithPrototype(builderResult.representativeImage).mergeFrom(value).buildPartial()
      } else {
        builderResult.representativeImage = value
      }
      builderResult.hasRepresentativeImage = true
      return self
    }
    public func clearRepresentativeImage() -> Place.Builder {
      representativeImageBuilder_ = nil
      builderResult.hasRepresentativeImage = false
      builderResult.representativeImage = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Place.Builder {
      builderResult = Place()
      return self
    }
    public override func clone() throws -> Place.Builder {
      return try Place.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Place {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Place {
      let returnMe:Place = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Place) throws -> Place.Builder {
      if other == Place() {
       return self
      }
      if other.hasUrl {
           url = other.url
      }
      if other.hasName {
           name = other.name
      }
      if (other.hasRepresentativeImage) {
          try mergeRepresentativeImage(other.representativeImage)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Place.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Place.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          url = try input.readString()

        case 26:
          name = try input.readString()

        case 1482:
          let subBuilder:Place.RepresentativeImage.Builder = Place.RepresentativeImage.Builder()
          if hasRepresentativeImage {
            try subBuilder.mergeFrom(representativeImage)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          representativeImage = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// An item of some type embedded in a chat message.
final public class EmbedItem : GeneratedMessage, GeneratedMessageProtocol {
  private var typesMemoizedSerializedSize:Int32 = 0
  public private(set) var types:Array<ItemType> = Array<ItemType>()
  // For photos this is not given, for maps, it's the URL of the map.
  public private(set) var id:String = ""

  public private(set) var hasId:Bool = false
  public private(set) var plusPhoto:PlusPhoto!
  public private(set) var hasPlusPhoto:Bool = false
  public private(set) var place:Place!
  public private(set) var hasPlace:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneValueOftypes in types {
        try output.writeEnum(1, value:oneValueOftypes.rawValue)
    }
    if hasId {
      try output.writeString(2, value:id)
    }
    if hasPlusPhoto {
      try output.writeMessage(27639957, value:plusPhoto)
    }
    if hasPlace {
      try output.writeMessage(35825640, value:place)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    var dataSizetypes:Int32 = 0
    for oneValueOftypes in types {
        dataSizetypes += oneValueOftypes.rawValue.computeEnumSizeNoTag()
    }
    serialize_size += dataSizetypes
    serialize_size += (1 * Int32(types.count))
    if hasId {
      serialize_size += id.computeStringSize(2)
    }
    if hasPlusPhoto {
        if let varSizeplusPhoto = plusPhoto?.computeMessageSize(27639957) {
            serialize_size += varSizeplusPhoto
        }
    }
    if hasPlace {
        if let varSizeplace = place?.computeMessageSize(35825640) {
            serialize_size += varSizeplace
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EmbedItem> {
    var mergedArray = Array<EmbedItem>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EmbedItem? {
    return try EmbedItem.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EmbedItem {
    return try EmbedItem.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EmbedItem.Builder {
    return EmbedItem.classBuilder() as! EmbedItem.Builder
  }
  public func getBuilder() -> EmbedItem.Builder {
    return classBuilder() as! EmbedItem.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EmbedItem.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EmbedItem.Builder()
  }
  public func toBuilder() throws -> EmbedItem.Builder {
    return try EmbedItem.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EmbedItem) throws -> EmbedItem.Builder {
    return try EmbedItem.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var typesElementIndex:Int = 0
    for oneValueOftypes in types {
        output += "\(indent) types[\(typesElementIndex)]: \(oneValueOftypes.description)\n"
        typesElementIndex += 1
    }
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasPlusPhoto {
      output += "\(indent) plusPhoto {\n"
      if let outDescPlusPhoto = plusPhoto {
        output += try outDescPlusPhoto.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPlace {
      output += "\(indent) place {\n"
      if let outDescPlace = place {
        output += try outDescPlace.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneValueOftypes in types {
              hashCode = (hashCode &* 31) &+ Int(oneValueOftypes.rawValue)
          }
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasPlusPhoto {
              if let hashValueplusPhoto = plusPhoto?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueplusPhoto
              }
          }
          if hasPlace {
              if let hashValueplace = place?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueplace
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EmbedItem"
  }
  override public func className() -> String {
      return "EmbedItem"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EmbedItem.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EmbedItem = EmbedItem()
    public func getMessage() -> EmbedItem {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var types:Array<ItemType> {
        get {
            return builderResult.types
        }
        set (value) {
            builderResult.types = value
        }
    }
    public func setTypes(_ value:Array<ItemType>) -> EmbedItem.Builder {
      self.types = value
      return self
    }
    public func clearTypes() -> EmbedItem.Builder {
      builderResult.types.removeAll(keepingCapacity: false)
      return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:String {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(_ value:String) -> EmbedItem.Builder {
      self.id = value
      return self
    }
    public func clearId() -> EmbedItem.Builder{
         builderResult.hasId = false
         builderResult.id = ""
         return self
    }
    public var hasPlusPhoto:Bool {
         get {
             return builderResult.hasPlusPhoto
         }
    }
    public var plusPhoto:PlusPhoto! {
         get {
             if plusPhotoBuilder_ != nil {
                builderResult.plusPhoto = plusPhotoBuilder_.getMessage()
             }
             return builderResult.plusPhoto
         }
         set (value) {
             builderResult.hasPlusPhoto = true
             builderResult.plusPhoto = value
         }
    }
    private var plusPhotoBuilder_:PlusPhoto.Builder! {
         didSet {
            builderResult.hasPlusPhoto = true
         }
    }
    public func getPlusPhotoBuilder() -> PlusPhoto.Builder {
      if plusPhotoBuilder_ == nil {
         plusPhotoBuilder_ = PlusPhoto.Builder()
         builderResult.plusPhoto = plusPhotoBuilder_.getMessage()
         if plusPhoto != nil {
            try! plusPhotoBuilder_.mergeFrom(plusPhoto)
         }
      }
      return plusPhotoBuilder_
    }
    public func setPlusPhoto(_ value:PlusPhoto!) -> EmbedItem.Builder {
      self.plusPhoto = value
      return self
    }
    public func mergePlusPhoto(_ value:PlusPhoto) throws -> EmbedItem.Builder {
      if builderResult.hasPlusPhoto {
        builderResult.plusPhoto = try PlusPhoto.builderWithPrototype(builderResult.plusPhoto).mergeFrom(value).buildPartial()
      } else {
        builderResult.plusPhoto = value
      }
      builderResult.hasPlusPhoto = true
      return self
    }
    public func clearPlusPhoto() -> EmbedItem.Builder {
      plusPhotoBuilder_ = nil
      builderResult.hasPlusPhoto = false
      builderResult.plusPhoto = nil
      return self
    }
    public var hasPlace:Bool {
         get {
             return builderResult.hasPlace
         }
    }
    public var place:Place! {
         get {
             if placeBuilder_ != nil {
                builderResult.place = placeBuilder_.getMessage()
             }
             return builderResult.place
         }
         set (value) {
             builderResult.hasPlace = true
             builderResult.place = value
         }
    }
    private var placeBuilder_:Place.Builder! {
         didSet {
            builderResult.hasPlace = true
         }
    }
    public func getPlaceBuilder() -> Place.Builder {
      if placeBuilder_ == nil {
         placeBuilder_ = Place.Builder()
         builderResult.place = placeBuilder_.getMessage()
         if place != nil {
            try! placeBuilder_.mergeFrom(place)
         }
      }
      return placeBuilder_
    }
    public func setPlace(_ value:Place!) -> EmbedItem.Builder {
      self.place = value
      return self
    }
    public func mergePlace(_ value:Place) throws -> EmbedItem.Builder {
      if builderResult.hasPlace {
        builderResult.place = try Place.builderWithPrototype(builderResult.place).mergeFrom(value).buildPartial()
      } else {
        builderResult.place = value
      }
      builderResult.hasPlace = true
      return self
    }
    public func clearPlace() -> EmbedItem.Builder {
      placeBuilder_ = nil
      builderResult.hasPlace = false
      builderResult.place = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EmbedItem.Builder {
      builderResult = EmbedItem()
      return self
    }
    public override func clone() throws -> EmbedItem.Builder {
      return try EmbedItem.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EmbedItem {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EmbedItem {
      let returnMe:EmbedItem = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EmbedItem) throws -> EmbedItem.Builder {
      if other == EmbedItem() {
       return self
      }
      if !other.types.isEmpty {
         builderResult.types += other.types
      }
      if other.hasId {
           id = other.id
      }
      if (other.hasPlusPhoto) {
          try mergePlusPhoto(other.plusPhoto)
      }
      if (other.hasPlace) {
          try mergePlace(other.place)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EmbedItem.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EmbedItem.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ItemType(rawValue:valueInttypes) {
               builderResult.types += [enumstypes]
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 18:
          id = try input.readString()

        case 221119658:
          let subBuilder:PlusPhoto.Builder = PlusPhoto.Builder()
          if hasPlusPhoto {
            try subBuilder.mergeFrom(plusPhoto)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          plusPhoto = subBuilder.buildPartial()

        case 286605122:
          let subBuilder:Place.Builder = Place.Builder()
          if hasPlace {
            try subBuilder.mergeFrom(place)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          place = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// An attachment for a chat message.
final public class Attachment : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var embedItem:EmbedItem!
  public private(set) var hasEmbedItem:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEmbedItem {
      try output.writeMessage(1, value:embedItem)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEmbedItem {
        if let varSizeembedItem = embedItem?.computeMessageSize(1) {
            serialize_size += varSizeembedItem
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Attachment> {
    var mergedArray = Array<Attachment>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Attachment? {
    return try Attachment.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Attachment {
    return try Attachment.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Attachment {
    return try Attachment.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Attachment {
    return try Attachment.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Attachment {
    return try Attachment.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Attachment {
    return try Attachment.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Attachment {
    return try Attachment.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Attachment.Builder {
    return Attachment.classBuilder() as! Attachment.Builder
  }
  public func getBuilder() -> Attachment.Builder {
    return classBuilder() as! Attachment.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Attachment.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Attachment.Builder()
  }
  public func toBuilder() throws -> Attachment.Builder {
    return try Attachment.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Attachment) throws -> Attachment.Builder {
    return try Attachment.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasEmbedItem {
      output += "\(indent) embedItem {\n"
      if let outDescEmbedItem = embedItem {
        output += try outDescEmbedItem.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEmbedItem {
              if let hashValueembedItem = embedItem?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueembedItem
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Attachment"
  }
  override public func className() -> String {
      return "Attachment"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Attachment.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Attachment = Attachment()
    public func getMessage() -> Attachment {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEmbedItem:Bool {
         get {
             return builderResult.hasEmbedItem
         }
    }
    public var embedItem:EmbedItem! {
         get {
             if embedItemBuilder_ != nil {
                builderResult.embedItem = embedItemBuilder_.getMessage()
             }
             return builderResult.embedItem
         }
         set (value) {
             builderResult.hasEmbedItem = true
             builderResult.embedItem = value
         }
    }
    private var embedItemBuilder_:EmbedItem.Builder! {
         didSet {
            builderResult.hasEmbedItem = true
         }
    }
    public func getEmbedItemBuilder() -> EmbedItem.Builder {
      if embedItemBuilder_ == nil {
         embedItemBuilder_ = EmbedItem.Builder()
         builderResult.embedItem = embedItemBuilder_.getMessage()
         if embedItem != nil {
            try! embedItemBuilder_.mergeFrom(embedItem)
         }
      }
      return embedItemBuilder_
    }
    public func setEmbedItem(_ value:EmbedItem!) -> Attachment.Builder {
      self.embedItem = value
      return self
    }
    public func mergeEmbedItem(_ value:EmbedItem) throws -> Attachment.Builder {
      if builderResult.hasEmbedItem {
        builderResult.embedItem = try EmbedItem.builderWithPrototype(builderResult.embedItem).mergeFrom(value).buildPartial()
      } else {
        builderResult.embedItem = value
      }
      builderResult.hasEmbedItem = true
      return self
    }
    public func clearEmbedItem() -> Attachment.Builder {
      embedItemBuilder_ = nil
      builderResult.hasEmbedItem = false
      builderResult.embedItem = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Attachment.Builder {
      builderResult = Attachment()
      return self
    }
    public override func clone() throws -> Attachment.Builder {
      return try Attachment.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Attachment {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Attachment {
      let returnMe:Attachment = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Attachment) throws -> Attachment.Builder {
      if other == Attachment() {
       return self
      }
      if (other.hasEmbedItem) {
          try mergeEmbedItem(other.embedItem)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Attachment.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Attachment.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:EmbedItem.Builder = EmbedItem.Builder()
          if hasEmbedItem {
            try subBuilder.mergeFrom(embedItem)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          embedItem = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Chat message content.
final public class MessageContent : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var segment:Array<Segment>  = Array<Segment>()
  public private(set) var attachment:Array<Attachment>  = Array<Attachment>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitsegment:Bool = true
    for oneElementsegment in segment {
        if (!oneElementsegment.isInitialized()) {
            isInitsegment = false
            break 
        }
    }
    if !isInitsegment {
     return isInitsegment
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementsegment in segment {
        try output.writeMessage(1, value:oneElementsegment)
    }
    for oneElementattachment in attachment {
        try output.writeMessage(2, value:oneElementattachment)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementsegment in segment {
        serialize_size += oneElementsegment.computeMessageSize(1)
    }
    for oneElementattachment in attachment {
        serialize_size += oneElementattachment.computeMessageSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MessageContent> {
    var mergedArray = Array<MessageContent>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MessageContent? {
    return try MessageContent.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageContent {
    return try MessageContent.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MessageContent.Builder {
    return MessageContent.classBuilder() as! MessageContent.Builder
  }
  public func getBuilder() -> MessageContent.Builder {
    return classBuilder() as! MessageContent.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MessageContent.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MessageContent.Builder()
  }
  public func toBuilder() throws -> MessageContent.Builder {
    return try MessageContent.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MessageContent) throws -> MessageContent.Builder {
    return try MessageContent.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var segmentElementIndex:Int = 0
    for oneElementsegment in segment {
        output += "\(indent) segment[\(segmentElementIndex)] {\n"
        output += try oneElementsegment.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        segmentElementIndex += 1
    }
    var attachmentElementIndex:Int = 0
    for oneElementattachment in attachment {
        output += "\(indent) attachment[\(attachmentElementIndex)] {\n"
        output += try oneElementattachment.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        attachmentElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementsegment in segment {
              hashCode = (hashCode &* 31) &+ oneElementsegment.hashValue
          }
          for oneElementattachment in attachment {
              hashCode = (hashCode &* 31) &+ oneElementattachment.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MessageContent"
  }
  override public func className() -> String {
      return "MessageContent"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MessageContent.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MessageContent = MessageContent()
    public func getMessage() -> MessageContent {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var segment:Array<Segment> {
         get {
             return builderResult.segment
         }
         set (value) {
             builderResult.segment = value
         }
    }
    public func setSegment(_ value:Array<Segment>) -> MessageContent.Builder {
      self.segment = value
      return self
    }
    public func clearSegment() -> MessageContent.Builder {
      builderResult.segment.removeAll(keepingCapacity: false)
      return self
    }
    public var attachment:Array<Attachment> {
         get {
             return builderResult.attachment
         }
         set (value) {
             builderResult.attachment = value
         }
    }
    public func setAttachment(_ value:Array<Attachment>) -> MessageContent.Builder {
      self.attachment = value
      return self
    }
    public func clearAttachment() -> MessageContent.Builder {
      builderResult.attachment.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MessageContent.Builder {
      builderResult = MessageContent()
      return self
    }
    public override func clone() throws -> MessageContent.Builder {
      return try MessageContent.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MessageContent {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MessageContent {
      let returnMe:MessageContent = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MessageContent) throws -> MessageContent.Builder {
      if other == MessageContent() {
       return self
      }
      if !other.segment.isEmpty  {
         builderResult.segment += other.segment
      }
      if !other.attachment.isEmpty  {
         builderResult.attachment += other.attachment
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MessageContent.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageContent.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = Segment.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          segment += [subBuilder.buildPartial()]

        case 18:
          let subBuilder = Attachment.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          attachment += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Annotation that can be applied to a chat message event. The only known use
// for this is "\me" actions supported by the Chrome client (type 4).
final public class EventAnnotation : GeneratedMessage, GeneratedMessageProtocol {
  // Annotation type.
  public private(set) var types:Int32 = Int32(0)

  public private(set) var hasTypes:Bool = false
  // Optional annotation string value.
  public private(set) var value:String = ""

  public private(set) var hasValue:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeInt32(1, value:types)
    }
    if hasValue {
      try output.writeString(2, value:value)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTypes {
      serialize_size += types.computeInt32Size(1)
    }
    if hasValue {
      serialize_size += value.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EventAnnotation> {
    var mergedArray = Array<EventAnnotation>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EventAnnotation? {
    return try EventAnnotation.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventAnnotation {
    return try EventAnnotation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EventAnnotation.Builder {
    return EventAnnotation.classBuilder() as! EventAnnotation.Builder
  }
  public func getBuilder() -> EventAnnotation.Builder {
    return classBuilder() as! EventAnnotation.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EventAnnotation.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EventAnnotation.Builder()
  }
  public func toBuilder() throws -> EventAnnotation.Builder {
    return try EventAnnotation.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EventAnnotation) throws -> EventAnnotation.Builder {
    return try EventAnnotation.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasTypes {
      output += "\(indent) types: \(types) \n"
    }
    if hasValue {
      output += "\(indent) value: \(value) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ types.hashValue
          }
          if hasValue {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EventAnnotation"
  }
  override public func className() -> String {
      return "EventAnnotation"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EventAnnotation.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EventAnnotation = EventAnnotation()
    public func getMessage() -> EventAnnotation {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasTypes:Bool {
         get {
              return builderResult.hasTypes
         }
    }
    public var types:Int32 {
         get {
              return builderResult.types
         }
         set (value) {
             builderResult.hasTypes = true
             builderResult.types = value
         }
    }
    public func setTypes(_ value:Int32) -> EventAnnotation.Builder {
      self.types = value
      return self
    }
    public func clearTypes() -> EventAnnotation.Builder{
         builderResult.hasTypes = false
         builderResult.types = Int32(0)
         return self
    }
    public var hasValue:Bool {
         get {
              return builderResult.hasValue
         }
    }
    public var value:String {
         get {
              return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    public func setValue(_ value:String) -> EventAnnotation.Builder {
      self.value = value
      return self
    }
    public func clearValue() -> EventAnnotation.Builder{
         builderResult.hasValue = false
         builderResult.value = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EventAnnotation.Builder {
      builderResult = EventAnnotation()
      return self
    }
    public override func clone() throws -> EventAnnotation.Builder {
      return try EventAnnotation.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EventAnnotation {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EventAnnotation {
      let returnMe:EventAnnotation = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EventAnnotation) throws -> EventAnnotation.Builder {
      if other == EventAnnotation() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasValue {
           value = other.value
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EventAnnotation.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventAnnotation.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          types = try input.readInt32()

        case 18:
          value = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// A chat message in a conversation.
final public class ChatMessage : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var annotation:Array<EventAnnotation>  = Array<EventAnnotation>()
  public private(set) var messageContent:MessageContent!
  public private(set) var hasMessageContent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMessageContent {
     if !messageContent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementannotation in annotation {
        try output.writeMessage(2, value:oneElementannotation)
    }
    if hasMessageContent {
      try output.writeMessage(3, value:messageContent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementannotation in annotation {
        serialize_size += oneElementannotation.computeMessageSize(2)
    }
    if hasMessageContent {
        if let varSizemessageContent = messageContent?.computeMessageSize(3) {
            serialize_size += varSizemessageContent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ChatMessage> {
    var mergedArray = Array<ChatMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ChatMessage? {
    return try ChatMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessage {
    return try ChatMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ChatMessage.Builder {
    return ChatMessage.classBuilder() as! ChatMessage.Builder
  }
  public func getBuilder() -> ChatMessage.Builder {
    return classBuilder() as! ChatMessage.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ChatMessage.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ChatMessage.Builder()
  }
  public func toBuilder() throws -> ChatMessage.Builder {
    return try ChatMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ChatMessage) throws -> ChatMessage.Builder {
    return try ChatMessage.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var annotationElementIndex:Int = 0
    for oneElementannotation in annotation {
        output += "\(indent) annotation[\(annotationElementIndex)] {\n"
        output += try oneElementannotation.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        annotationElementIndex += 1
    }
    if hasMessageContent {
      output += "\(indent) messageContent {\n"
      if let outDescMessageContent = messageContent {
        output += try outDescMessageContent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementannotation in annotation {
              hashCode = (hashCode &* 31) &+ oneElementannotation.hashValue
          }
          if hasMessageContent {
              if let hashValuemessageContent = messageContent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemessageContent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ChatMessage"
  }
  override public func className() -> String {
      return "ChatMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ChatMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ChatMessage = ChatMessage()
    public func getMessage() -> ChatMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var annotation:Array<EventAnnotation> {
         get {
             return builderResult.annotation
         }
         set (value) {
             builderResult.annotation = value
         }
    }
    public func setAnnotation(_ value:Array<EventAnnotation>) -> ChatMessage.Builder {
      self.annotation = value
      return self
    }
    public func clearAnnotation() -> ChatMessage.Builder {
      builderResult.annotation.removeAll(keepingCapacity: false)
      return self
    }
    public var hasMessageContent:Bool {
         get {
             return builderResult.hasMessageContent
         }
    }
    public var messageContent:MessageContent! {
         get {
             if messageContentBuilder_ != nil {
                builderResult.messageContent = messageContentBuilder_.getMessage()
             }
             return builderResult.messageContent
         }
         set (value) {
             builderResult.hasMessageContent = true
             builderResult.messageContent = value
         }
    }
    private var messageContentBuilder_:MessageContent.Builder! {
         didSet {
            builderResult.hasMessageContent = true
         }
    }
    public func getMessageContentBuilder() -> MessageContent.Builder {
      if messageContentBuilder_ == nil {
         messageContentBuilder_ = MessageContent.Builder()
         builderResult.messageContent = messageContentBuilder_.getMessage()
         if messageContent != nil {
            try! messageContentBuilder_.mergeFrom(messageContent)
         }
      }
      return messageContentBuilder_
    }
    public func setMessageContent(_ value:MessageContent!) -> ChatMessage.Builder {
      self.messageContent = value
      return self
    }
    public func mergeMessageContent(_ value:MessageContent) throws -> ChatMessage.Builder {
      if builderResult.hasMessageContent {
        builderResult.messageContent = try MessageContent.builderWithPrototype(builderResult.messageContent).mergeFrom(value).buildPartial()
      } else {
        builderResult.messageContent = value
      }
      builderResult.hasMessageContent = true
      return self
    }
    public func clearMessageContent() -> ChatMessage.Builder {
      messageContentBuilder_ = nil
      builderResult.hasMessageContent = false
      builderResult.messageContent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ChatMessage.Builder {
      builderResult = ChatMessage()
      return self
    }
    public override func clone() throws -> ChatMessage.Builder {
      return try ChatMessage.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ChatMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ChatMessage {
      let returnMe:ChatMessage = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ChatMessage) throws -> ChatMessage.Builder {
      if other == ChatMessage() {
       return self
      }
      if !other.annotation.isEmpty  {
         builderResult.annotation += other.annotation
      }
      if (other.hasMessageContent) {
          try mergeMessageContent(other.messageContent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ChatMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 18:
          let subBuilder = EventAnnotation.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          annotation += [subBuilder.buildPartial()]

        case 26:
          let subBuilder:MessageContent.Builder = MessageContent.Builder()
          if hasMessageContent {
            try subBuilder.mergeFrom(messageContent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          messageContent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class MembershipChange : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var types:MembershipChangeType = MembershipChangeType.MembershipChangeTypeJoin
  public private(set) var hasTypes:Bool = false
  public private(set) var participantIds:Array<ParticipantId>  = Array<ParticipantId>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    for oneElementparticipantIds in participantIds {
        try output.writeMessage(3, value:oneElementparticipantIds)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    for oneElementparticipantIds in participantIds {
        serialize_size += oneElementparticipantIds.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MembershipChange> {
    var mergedArray = Array<MembershipChange>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MembershipChange? {
    return try MembershipChange.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MembershipChange {
    return try MembershipChange.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MembershipChange.Builder {
    return MembershipChange.classBuilder() as! MembershipChange.Builder
  }
  public func getBuilder() -> MembershipChange.Builder {
    return classBuilder() as! MembershipChange.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MembershipChange.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MembershipChange.Builder()
  }
  public func toBuilder() throws -> MembershipChange.Builder {
    return try MembershipChange.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MembershipChange) throws -> MembershipChange.Builder {
    return try MembershipChange.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    var participantIdsElementIndex:Int = 0
    for oneElementparticipantIds in participantIds {
        output += "\(indent) participantIds[\(participantIdsElementIndex)] {\n"
        output += try oneElementparticipantIds.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        participantIdsElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          for oneElementparticipantIds in participantIds {
              hashCode = (hashCode &* 31) &+ oneElementparticipantIds.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MembershipChange"
  }
  override public func className() -> String {
      return "MembershipChange"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MembershipChange.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MembershipChange = MembershipChange()
    public func getMessage() -> MembershipChange {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:MembershipChangeType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:MembershipChangeType) -> MembershipChange.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> MembershipChange.Builder {
         builderResult.hasTypes = false
         builderResult.types = .MembershipChangeTypeJoin
         return self
      }
    public var participantIds:Array<ParticipantId> {
         get {
             return builderResult.participantIds
         }
         set (value) {
             builderResult.participantIds = value
         }
    }
    public func setParticipantIds(_ value:Array<ParticipantId>) -> MembershipChange.Builder {
      self.participantIds = value
      return self
    }
    public func clearParticipantIds() -> MembershipChange.Builder {
      builderResult.participantIds.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MembershipChange.Builder {
      builderResult = MembershipChange()
      return self
    }
    public override func clone() throws -> MembershipChange.Builder {
      return try MembershipChange.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MembershipChange {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MembershipChange {
      let returnMe:MembershipChange = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MembershipChange) throws -> MembershipChange.Builder {
      if other == MembershipChange() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if !other.participantIds.isEmpty  {
         builderResult.participantIds += other.participantIds
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MembershipChange.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MembershipChange.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = MembershipChangeType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 26:
          let subBuilder = ParticipantId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          participantIds += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConversationRename : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var newName:String = ""

  public private(set) var hasNewName:Bool = false
  public private(set) var oldName:String = ""

  public private(set) var hasOldName:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasNewName {
      try output.writeString(1, value:newName)
    }
    if hasOldName {
      try output.writeString(2, value:oldName)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasNewName {
      serialize_size += newName.computeStringSize(1)
    }
    if hasOldName {
      serialize_size += oldName.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationRename> {
    var mergedArray = Array<ConversationRename>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationRename? {
    return try ConversationRename.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationRename {
    return try ConversationRename.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationRename.Builder {
    return ConversationRename.classBuilder() as! ConversationRename.Builder
  }
  public func getBuilder() -> ConversationRename.Builder {
    return classBuilder() as! ConversationRename.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationRename.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationRename.Builder()
  }
  public func toBuilder() throws -> ConversationRename.Builder {
    return try ConversationRename.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationRename) throws -> ConversationRename.Builder {
    return try ConversationRename.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasNewName {
      output += "\(indent) newName: \(newName) \n"
    }
    if hasOldName {
      output += "\(indent) oldName: \(oldName) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasNewName {
             hashCode = (hashCode &* 31) &+ newName.hashValue
          }
          if hasOldName {
             hashCode = (hashCode &* 31) &+ oldName.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationRename"
  }
  override public func className() -> String {
      return "ConversationRename"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationRename.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationRename = ConversationRename()
    public func getMessage() -> ConversationRename {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasNewName:Bool {
         get {
              return builderResult.hasNewName
         }
    }
    public var newName:String {
         get {
              return builderResult.newName
         }
         set (value) {
             builderResult.hasNewName = true
             builderResult.newName = value
         }
    }
    public func setNewName(_ value:String) -> ConversationRename.Builder {
      self.newName = value
      return self
    }
    public func clearNewName() -> ConversationRename.Builder{
         builderResult.hasNewName = false
         builderResult.newName = ""
         return self
    }
    public var hasOldName:Bool {
         get {
              return builderResult.hasOldName
         }
    }
    public var oldName:String {
         get {
              return builderResult.oldName
         }
         set (value) {
             builderResult.hasOldName = true
             builderResult.oldName = value
         }
    }
    public func setOldName(_ value:String) -> ConversationRename.Builder {
      self.oldName = value
      return self
    }
    public func clearOldName() -> ConversationRename.Builder{
         builderResult.hasOldName = false
         builderResult.oldName = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationRename.Builder {
      builderResult = ConversationRename()
      return self
    }
    public override func clone() throws -> ConversationRename.Builder {
      return try ConversationRename.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationRename {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationRename {
      let returnMe:ConversationRename = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationRename) throws -> ConversationRename.Builder {
      if other == ConversationRename() {
       return self
      }
      if other.hasNewName {
           newName = other.newName
      }
      if other.hasOldName {
           oldName = other.oldName
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationRename.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationRename.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          newName = try input.readString()

        case 18:
          oldName = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class HangoutEvent : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var eventType:HangoutEventType = HangoutEventType.HangoutEventTypeUnknown
  public private(set) var hasEventType:Bool = false
  public private(set) var participantId:Array<ParticipantId>  = Array<ParticipantId>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEventType {
      try output.writeEnum(1, value:eventType.rawValue)
    }
    for oneElementparticipantId in participantId {
        try output.writeMessage(2, value:oneElementparticipantId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasEventType) {
      serialize_size += eventType.rawValue.computeEnumSize(1)
    }
    for oneElementparticipantId in participantId {
        serialize_size += oneElementparticipantId.computeMessageSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<HangoutEvent> {
    var mergedArray = Array<HangoutEvent>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> HangoutEvent? {
    return try HangoutEvent.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> HangoutEvent {
    return try HangoutEvent.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> HangoutEvent.Builder {
    return HangoutEvent.classBuilder() as! HangoutEvent.Builder
  }
  public func getBuilder() -> HangoutEvent.Builder {
    return classBuilder() as! HangoutEvent.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return HangoutEvent.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return HangoutEvent.Builder()
  }
  public func toBuilder() throws -> HangoutEvent.Builder {
    return try HangoutEvent.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:HangoutEvent) throws -> HangoutEvent.Builder {
    return try HangoutEvent.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasEventType) {
      output += "\(indent) eventType: \(eventType.description)\n"
    }
    var participantIdElementIndex:Int = 0
    for oneElementparticipantId in participantId {
        output += "\(indent) participantId[\(participantIdElementIndex)] {\n"
        output += try oneElementparticipantId.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        participantIdElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEventType {
             hashCode = (hashCode &* 31) &+ Int(eventType.rawValue)
          }
          for oneElementparticipantId in participantId {
              hashCode = (hashCode &* 31) &+ oneElementparticipantId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "HangoutEvent"
  }
  override public func className() -> String {
      return "HangoutEvent"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return HangoutEvent.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:HangoutEvent = HangoutEvent()
    public func getMessage() -> HangoutEvent {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasEventType:Bool{
          get {
              return builderResult.hasEventType
          }
      }
      public var eventType:HangoutEventType {
          get {
              return builderResult.eventType
          }
          set (value) {
              builderResult.hasEventType = true
              builderResult.eventType = value
          }
      }
      public func setEventType(_ value:HangoutEventType) -> HangoutEvent.Builder {
        self.eventType = value
        return self
      }
      public func clearEventType() -> HangoutEvent.Builder {
         builderResult.hasEventType = false
         builderResult.eventType = .HangoutEventTypeUnknown
         return self
      }
    public var participantId:Array<ParticipantId> {
         get {
             return builderResult.participantId
         }
         set (value) {
             builderResult.participantId = value
         }
    }
    public func setParticipantId(_ value:Array<ParticipantId>) -> HangoutEvent.Builder {
      self.participantId = value
      return self
    }
    public func clearParticipantId() -> HangoutEvent.Builder {
      builderResult.participantId.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> HangoutEvent.Builder {
      builderResult = HangoutEvent()
      return self
    }
    public override func clone() throws -> HangoutEvent.Builder {
      return try HangoutEvent.builderWithPrototype(builderResult)
    }
    public override func build() throws -> HangoutEvent {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> HangoutEvent {
      let returnMe:HangoutEvent = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:HangoutEvent) throws -> HangoutEvent.Builder {
      if other == HangoutEvent() {
       return self
      }
      if other.hasEventType {
           eventType = other.eventType
      }
      if !other.participantId.isEmpty  {
         builderResult.participantId += other.participantId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> HangoutEvent.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> HangoutEvent.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInteventType = try input.readEnum()
          if let enumseventType = HangoutEventType(rawValue:valueInteventType){
               eventType = enumseventType
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInteventType))
          }

        case 18:
          let subBuilder = ParticipantId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          participantId += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Otrmodification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var oldOtrStatus:OffTheRecordStatus = OffTheRecordStatus.OffTheRecordStatusUnknown
  public private(set) var hasOldOtrStatus:Bool = false
  public private(set) var newOtrStatus:OffTheRecordStatus = OffTheRecordStatus.OffTheRecordStatusUnknown
  public private(set) var hasNewOtrStatus:Bool = false
  public private(set) var oldOtrToggle:OffTheRecordToggle = OffTheRecordToggle.OffTheRecordToggleUnknown
  public private(set) var hasOldOtrToggle:Bool = false
  public private(set) var newOtrToggle:OffTheRecordToggle = OffTheRecordToggle.OffTheRecordToggleUnknown
  public private(set) var hasNewOtrToggle:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasOldOtrStatus {
      try output.writeEnum(1, value:oldOtrStatus.rawValue)
    }
    if hasNewOtrStatus {
      try output.writeEnum(2, value:newOtrStatus.rawValue)
    }
    if hasOldOtrToggle {
      try output.writeEnum(3, value:oldOtrToggle.rawValue)
    }
    if hasNewOtrToggle {
      try output.writeEnum(4, value:newOtrToggle.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasOldOtrStatus) {
      serialize_size += oldOtrStatus.rawValue.computeEnumSize(1)
    }
    if (hasNewOtrStatus) {
      serialize_size += newOtrStatus.rawValue.computeEnumSize(2)
    }
    if (hasOldOtrToggle) {
      serialize_size += oldOtrToggle.rawValue.computeEnumSize(3)
    }
    if (hasNewOtrToggle) {
      serialize_size += newOtrToggle.rawValue.computeEnumSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Otrmodification> {
    var mergedArray = Array<Otrmodification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Otrmodification? {
    return try Otrmodification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Otrmodification {
    return try Otrmodification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Otrmodification.Builder {
    return Otrmodification.classBuilder() as! Otrmodification.Builder
  }
  public func getBuilder() -> Otrmodification.Builder {
    return classBuilder() as! Otrmodification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Otrmodification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Otrmodification.Builder()
  }
  public func toBuilder() throws -> Otrmodification.Builder {
    return try Otrmodification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Otrmodification) throws -> Otrmodification.Builder {
    return try Otrmodification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasOldOtrStatus) {
      output += "\(indent) oldOtrStatus: \(oldOtrStatus.description)\n"
    }
    if (hasNewOtrStatus) {
      output += "\(indent) newOtrStatus: \(newOtrStatus.description)\n"
    }
    if (hasOldOtrToggle) {
      output += "\(indent) oldOtrToggle: \(oldOtrToggle.description)\n"
    }
    if (hasNewOtrToggle) {
      output += "\(indent) newOtrToggle: \(newOtrToggle.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOldOtrStatus {
             hashCode = (hashCode &* 31) &+ Int(oldOtrStatus.rawValue)
          }
          if hasNewOtrStatus {
             hashCode = (hashCode &* 31) &+ Int(newOtrStatus.rawValue)
          }
          if hasOldOtrToggle {
             hashCode = (hashCode &* 31) &+ Int(oldOtrToggle.rawValue)
          }
          if hasNewOtrToggle {
             hashCode = (hashCode &* 31) &+ Int(newOtrToggle.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Otrmodification"
  }
  override public func className() -> String {
      return "Otrmodification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Otrmodification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Otrmodification = Otrmodification()
    public func getMessage() -> Otrmodification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasOldOtrStatus:Bool{
          get {
              return builderResult.hasOldOtrStatus
          }
      }
      public var oldOtrStatus:OffTheRecordStatus {
          get {
              return builderResult.oldOtrStatus
          }
          set (value) {
              builderResult.hasOldOtrStatus = true
              builderResult.oldOtrStatus = value
          }
      }
      public func setOldOtrStatus(_ value:OffTheRecordStatus) -> Otrmodification.Builder {
        self.oldOtrStatus = value
        return self
      }
      public func clearOldOtrStatus() -> Otrmodification.Builder {
         builderResult.hasOldOtrStatus = false
         builderResult.oldOtrStatus = .OffTheRecordStatusUnknown
         return self
      }
      public var hasNewOtrStatus:Bool{
          get {
              return builderResult.hasNewOtrStatus
          }
      }
      public var newOtrStatus:OffTheRecordStatus {
          get {
              return builderResult.newOtrStatus
          }
          set (value) {
              builderResult.hasNewOtrStatus = true
              builderResult.newOtrStatus = value
          }
      }
      public func setNewOtrStatus(_ value:OffTheRecordStatus) -> Otrmodification.Builder {
        self.newOtrStatus = value
        return self
      }
      public func clearNewOtrStatus() -> Otrmodification.Builder {
         builderResult.hasNewOtrStatus = false
         builderResult.newOtrStatus = .OffTheRecordStatusUnknown
         return self
      }
      public var hasOldOtrToggle:Bool{
          get {
              return builderResult.hasOldOtrToggle
          }
      }
      public var oldOtrToggle:OffTheRecordToggle {
          get {
              return builderResult.oldOtrToggle
          }
          set (value) {
              builderResult.hasOldOtrToggle = true
              builderResult.oldOtrToggle = value
          }
      }
      public func setOldOtrToggle(_ value:OffTheRecordToggle) -> Otrmodification.Builder {
        self.oldOtrToggle = value
        return self
      }
      public func clearOldOtrToggle() -> Otrmodification.Builder {
         builderResult.hasOldOtrToggle = false
         builderResult.oldOtrToggle = .OffTheRecordToggleUnknown
         return self
      }
      public var hasNewOtrToggle:Bool{
          get {
              return builderResult.hasNewOtrToggle
          }
      }
      public var newOtrToggle:OffTheRecordToggle {
          get {
              return builderResult.newOtrToggle
          }
          set (value) {
              builderResult.hasNewOtrToggle = true
              builderResult.newOtrToggle = value
          }
      }
      public func setNewOtrToggle(_ value:OffTheRecordToggle) -> Otrmodification.Builder {
        self.newOtrToggle = value
        return self
      }
      public func clearNewOtrToggle() -> Otrmodification.Builder {
         builderResult.hasNewOtrToggle = false
         builderResult.newOtrToggle = .OffTheRecordToggleUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Otrmodification.Builder {
      builderResult = Otrmodification()
      return self
    }
    public override func clone() throws -> Otrmodification.Builder {
      return try Otrmodification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Otrmodification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Otrmodification {
      let returnMe:Otrmodification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Otrmodification) throws -> Otrmodification.Builder {
      if other == Otrmodification() {
       return self
      }
      if other.hasOldOtrStatus {
           oldOtrStatus = other.oldOtrStatus
      }
      if other.hasNewOtrStatus {
           newOtrStatus = other.newOtrStatus
      }
      if other.hasOldOtrToggle {
           oldOtrToggle = other.oldOtrToggle
      }
      if other.hasNewOtrToggle {
           newOtrToggle = other.newOtrToggle
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Otrmodification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Otrmodification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntoldOtrStatus = try input.readEnum()
          if let enumsoldOtrStatus = OffTheRecordStatus(rawValue:valueIntoldOtrStatus){
               oldOtrStatus = enumsoldOtrStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntoldOtrStatus))
          }

        case 16:
          let valueIntnewOtrStatus = try input.readEnum()
          if let enumsnewOtrStatus = OffTheRecordStatus(rawValue:valueIntnewOtrStatus){
               newOtrStatus = enumsnewOtrStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntnewOtrStatus))
          }

        case 24:
          let valueIntoldOtrToggle = try input.readEnum()
          if let enumsoldOtrToggle = OffTheRecordToggle(rawValue:valueIntoldOtrToggle){
               oldOtrToggle = enumsoldOtrToggle
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntoldOtrToggle))
          }

        case 32:
          let valueIntnewOtrToggle = try input.readEnum()
          if let enumsnewOtrToggle = OffTheRecordToggle(rawValue:valueIntnewOtrToggle){
               newOtrToggle = enumsnewOtrToggle
          } else {
               try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntnewOtrToggle))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class HashModifier : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var updateId:String = ""

  public private(set) var hasUpdateId:Bool = false
  public private(set) var hashDiff:UInt64 = UInt64(0)

  public private(set) var hasHashDiff:Bool = false
  public private(set) var version:UInt64 = UInt64(0)

  public private(set) var hasVersion:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasUpdateId {
      try output.writeString(1, value:updateId)
    }
    if hasHashDiff {
      try output.writeUInt64(2, value:hashDiff)
    }
    if hasVersion {
      try output.writeUInt64(4, value:version)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUpdateId {
      serialize_size += updateId.computeStringSize(1)
    }
    if hasHashDiff {
      serialize_size += hashDiff.computeUInt64Size(2)
    }
    if hasVersion {
      serialize_size += version.computeUInt64Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<HashModifier> {
    var mergedArray = Array<HashModifier>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> HashModifier? {
    return try HashModifier.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> HashModifier {
    return try HashModifier.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> HashModifier.Builder {
    return HashModifier.classBuilder() as! HashModifier.Builder
  }
  public func getBuilder() -> HashModifier.Builder {
    return classBuilder() as! HashModifier.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return HashModifier.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return HashModifier.Builder()
  }
  public func toBuilder() throws -> HashModifier.Builder {
    return try HashModifier.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:HashModifier) throws -> HashModifier.Builder {
    return try HashModifier.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasUpdateId {
      output += "\(indent) updateId: \(updateId) \n"
    }
    if hasHashDiff {
      output += "\(indent) hashDiff: \(hashDiff) \n"
    }
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUpdateId {
             hashCode = (hashCode &* 31) &+ updateId.hashValue
          }
          if hasHashDiff {
             hashCode = (hashCode &* 31) &+ hashDiff.hashValue
          }
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "HashModifier"
  }
  override public func className() -> String {
      return "HashModifier"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return HashModifier.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:HashModifier = HashModifier()
    public func getMessage() -> HashModifier {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUpdateId:Bool {
         get {
              return builderResult.hasUpdateId
         }
    }
    public var updateId:String {
         get {
              return builderResult.updateId
         }
         set (value) {
             builderResult.hasUpdateId = true
             builderResult.updateId = value
         }
    }
    public func setUpdateId(_ value:String) -> HashModifier.Builder {
      self.updateId = value
      return self
    }
    public func clearUpdateId() -> HashModifier.Builder{
         builderResult.hasUpdateId = false
         builderResult.updateId = ""
         return self
    }
    public var hasHashDiff:Bool {
         get {
              return builderResult.hasHashDiff
         }
    }
    public var hashDiff:UInt64 {
         get {
              return builderResult.hashDiff
         }
         set (value) {
             builderResult.hasHashDiff = true
             builderResult.hashDiff = value
         }
    }
    public func setHashDiff(_ value:UInt64) -> HashModifier.Builder {
      self.hashDiff = value
      return self
    }
    public func clearHashDiff() -> HashModifier.Builder{
         builderResult.hasHashDiff = false
         builderResult.hashDiff = UInt64(0)
         return self
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt64 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(_ value:UInt64) -> HashModifier.Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> HashModifier.Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> HashModifier.Builder {
      builderResult = HashModifier()
      return self
    }
    public override func clone() throws -> HashModifier.Builder {
      return try HashModifier.builderWithPrototype(builderResult)
    }
    public override func build() throws -> HashModifier {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> HashModifier {
      let returnMe:HashModifier = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:HashModifier) throws -> HashModifier.Builder {
      if other == HashModifier() {
       return self
      }
      if other.hasUpdateId {
           updateId = other.updateId
      }
      if other.hasHashDiff {
           hashDiff = other.hashDiff
      }
      if other.hasVersion {
           version = other.version
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> HashModifier.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> HashModifier.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          updateId = try input.readString()

        case 16:
          hashDiff = try input.readUInt64()

        case 32:
          version = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Event that becomes part of a conversation's history.
final public class Event : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var senderId:ParticipantId!
  public private(set) var hasSenderId:Bool = false
  // Timestamp when the event occurred.
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  public private(set) var selfEventState:UserEventState!
  public private(set) var hasSelfEventState:Bool = false
  public private(set) var sourceType:SourceType = SourceType.SourceTypeUnknown
  public private(set) var hasSourceType:Bool = false
  public private(set) var chatMessage:ChatMessage!
  public private(set) var hasChatMessage:Bool = false
  public private(set) var membershipChange:MembershipChange!
  public private(set) var hasMembershipChange:Bool = false
  public private(set) var conversationRename:ConversationRename!
  public private(set) var hasConversationRename:Bool = false
  public private(set) var hangoutEvent:HangoutEvent!
  public private(set) var hasHangoutEvent:Bool = false
  // Unique ID for the event.
  public private(set) var eventId:String = ""

  public private(set) var hasEventId:Bool = false
  public private(set) var expirationTimestamp:UInt64 = UInt64(0)

  public private(set) var hasExpirationTimestamp:Bool = false
  public private(set) var otrModification:Otrmodification!
  public private(set) var hasOtrModification:Bool = false
  public private(set) var advancesSortTimestamp:Bool = false

  public private(set) var hasAdvancesSortTimestamp:Bool = false
  public private(set) var otrStatus:OffTheRecordStatus = OffTheRecordStatus.OffTheRecordStatusUnknown
  public private(set) var hasOtrStatus:Bool = false
  public private(set) var persisted:Bool = false

  public private(set) var hasPersisted:Bool = false
  public private(set) var mediumType:DeliveryMedium!
  public private(set) var hasMediumType:Bool = false
  public private(set) var eventType:EventType = EventType.EventTypeUnknown
  public private(set) var hasEventType:Bool = false
  // Event version timestamp.
  public private(set) var eventVersion:UInt64 = UInt64(0)

  public private(set) var hasEventVersion:Bool = false
  public private(set) var hashModifier:HashModifier!
  public private(set) var hasHashModifier:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasChatMessage {
     if !chatMessage.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasSenderId {
      try output.writeMessage(2, value:senderId)
    }
    if hasTimestamp {
      try output.writeUInt64(3, value:timestamp)
    }
    if hasSelfEventState {
      try output.writeMessage(4, value:selfEventState)
    }
    if hasSourceType {
      try output.writeEnum(6, value:sourceType.rawValue)
    }
    if hasChatMessage {
      try output.writeMessage(7, value:chatMessage)
    }
    if hasMembershipChange {
      try output.writeMessage(9, value:membershipChange)
    }
    if hasConversationRename {
      try output.writeMessage(10, value:conversationRename)
    }
    if hasHangoutEvent {
      try output.writeMessage(11, value:hangoutEvent)
    }
    if hasEventId {
      try output.writeString(12, value:eventId)
    }
    if hasExpirationTimestamp {
      try output.writeUInt64(13, value:expirationTimestamp)
    }
    if hasOtrModification {
      try output.writeMessage(14, value:otrModification)
    }
    if hasAdvancesSortTimestamp {
      try output.writeBool(15, value:advancesSortTimestamp)
    }
    if hasOtrStatus {
      try output.writeEnum(16, value:otrStatus.rawValue)
    }
    if hasPersisted {
      try output.writeBool(17, value:persisted)
    }
    if hasMediumType {
      try output.writeMessage(20, value:mediumType)
    }
    if hasEventType {
      try output.writeEnum(23, value:eventType.rawValue)
    }
    if hasEventVersion {
      try output.writeUInt64(24, value:eventVersion)
    }
    if hasHashModifier {
      try output.writeMessage(26, value:hashModifier)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasSenderId {
        if let varSizesenderId = senderId?.computeMessageSize(2) {
            serialize_size += varSizesenderId
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(3)
    }
    if hasSelfEventState {
        if let varSizeselfEventState = selfEventState?.computeMessageSize(4) {
            serialize_size += varSizeselfEventState
        }
    }
    if (hasSourceType) {
      serialize_size += sourceType.rawValue.computeEnumSize(6)
    }
    if hasChatMessage {
        if let varSizechatMessage = chatMessage?.computeMessageSize(7) {
            serialize_size += varSizechatMessage
        }
    }
    if hasMembershipChange {
        if let varSizemembershipChange = membershipChange?.computeMessageSize(9) {
            serialize_size += varSizemembershipChange
        }
    }
    if hasConversationRename {
        if let varSizeconversationRename = conversationRename?.computeMessageSize(10) {
            serialize_size += varSizeconversationRename
        }
    }
    if hasHangoutEvent {
        if let varSizehangoutEvent = hangoutEvent?.computeMessageSize(11) {
            serialize_size += varSizehangoutEvent
        }
    }
    if hasEventId {
      serialize_size += eventId.computeStringSize(12)
    }
    if hasExpirationTimestamp {
      serialize_size += expirationTimestamp.computeUInt64Size(13)
    }
    if hasOtrModification {
        if let varSizeotrModification = otrModification?.computeMessageSize(14) {
            serialize_size += varSizeotrModification
        }
    }
    if hasAdvancesSortTimestamp {
      serialize_size += advancesSortTimestamp.computeBoolSize(15)
    }
    if (hasOtrStatus) {
      serialize_size += otrStatus.rawValue.computeEnumSize(16)
    }
    if hasPersisted {
      serialize_size += persisted.computeBoolSize(17)
    }
    if hasMediumType {
        if let varSizemediumType = mediumType?.computeMessageSize(20) {
            serialize_size += varSizemediumType
        }
    }
    if (hasEventType) {
      serialize_size += eventType.rawValue.computeEnumSize(23)
    }
    if hasEventVersion {
      serialize_size += eventVersion.computeUInt64Size(24)
    }
    if hasHashModifier {
        if let varSizehashModifier = hashModifier?.computeMessageSize(26) {
            serialize_size += varSizehashModifier
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Event> {
    var mergedArray = Array<Event>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Event? {
    return try Event.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Event {
    return try Event.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Event {
    return try Event.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Event {
    return try Event.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Event {
    return try Event.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Event {
    return try Event.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Event {
    return try Event.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Event.Builder {
    return Event.classBuilder() as! Event.Builder
  }
  public func getBuilder() -> Event.Builder {
    return classBuilder() as! Event.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Event.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Event.Builder()
  }
  public func toBuilder() throws -> Event.Builder {
    return try Event.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Event) throws -> Event.Builder {
    return try Event.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSenderId {
      output += "\(indent) senderId {\n"
      if let outDescSenderId = senderId {
        output += try outDescSenderId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    if hasSelfEventState {
      output += "\(indent) selfEventState {\n"
      if let outDescSelfEventState = selfEventState {
        output += try outDescSelfEventState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasSourceType) {
      output += "\(indent) sourceType: \(sourceType.description)\n"
    }
    if hasChatMessage {
      output += "\(indent) chatMessage {\n"
      if let outDescChatMessage = chatMessage {
        output += try outDescChatMessage.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMembershipChange {
      output += "\(indent) membershipChange {\n"
      if let outDescMembershipChange = membershipChange {
        output += try outDescMembershipChange.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationRename {
      output += "\(indent) conversationRename {\n"
      if let outDescConversationRename = conversationRename {
        output += try outDescConversationRename.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasHangoutEvent {
      output += "\(indent) hangoutEvent {\n"
      if let outDescHangoutEvent = hangoutEvent {
        output += try outDescHangoutEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEventId {
      output += "\(indent) eventId: \(eventId) \n"
    }
    if hasExpirationTimestamp {
      output += "\(indent) expirationTimestamp: \(expirationTimestamp) \n"
    }
    if hasOtrModification {
      output += "\(indent) otrModification {\n"
      if let outDescOtrModification = otrModification {
        output += try outDescOtrModification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasAdvancesSortTimestamp {
      output += "\(indent) advancesSortTimestamp: \(advancesSortTimestamp) \n"
    }
    if (hasOtrStatus) {
      output += "\(indent) otrStatus: \(otrStatus.description)\n"
    }
    if hasPersisted {
      output += "\(indent) persisted: \(persisted) \n"
    }
    if hasMediumType {
      output += "\(indent) mediumType {\n"
      if let outDescMediumType = mediumType {
        output += try outDescMediumType.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasEventType) {
      output += "\(indent) eventType: \(eventType.description)\n"
    }
    if hasEventVersion {
      output += "\(indent) eventVersion: \(eventVersion) \n"
    }
    if hasHashModifier {
      output += "\(indent) hashModifier {\n"
      if let outDescHashModifier = hashModifier {
        output += try outDescHashModifier.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasSenderId {
              if let hashValuesenderId = senderId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesenderId
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          if hasSelfEventState {
              if let hashValueselfEventState = selfEventState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueselfEventState
              }
          }
          if hasSourceType {
             hashCode = (hashCode &* 31) &+ Int(sourceType.rawValue)
          }
          if hasChatMessage {
              if let hashValuechatMessage = chatMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuechatMessage
              }
          }
          if hasMembershipChange {
              if let hashValuemembershipChange = membershipChange?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemembershipChange
              }
          }
          if hasConversationRename {
              if let hashValueconversationRename = conversationRename?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationRename
              }
          }
          if hasHangoutEvent {
              if let hashValuehangoutEvent = hangoutEvent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuehangoutEvent
              }
          }
          if hasEventId {
             hashCode = (hashCode &* 31) &+ eventId.hashValue
          }
          if hasExpirationTimestamp {
             hashCode = (hashCode &* 31) &+ expirationTimestamp.hashValue
          }
          if hasOtrModification {
              if let hashValueotrModification = otrModification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueotrModification
              }
          }
          if hasAdvancesSortTimestamp {
             hashCode = (hashCode &* 31) &+ advancesSortTimestamp.hashValue
          }
          if hasOtrStatus {
             hashCode = (hashCode &* 31) &+ Int(otrStatus.rawValue)
          }
          if hasPersisted {
             hashCode = (hashCode &* 31) &+ persisted.hashValue
          }
          if hasMediumType {
              if let hashValuemediumType = mediumType?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemediumType
              }
          }
          if hasEventType {
             hashCode = (hashCode &* 31) &+ Int(eventType.rawValue)
          }
          if hasEventVersion {
             hashCode = (hashCode &* 31) &+ eventVersion.hashValue
          }
          if hasHashModifier {
              if let hashValuehashModifier = hashModifier?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuehashModifier
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Event"
  }
  override public func className() -> String {
      return "Event"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Event.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Event = Event()
    public func getMessage() -> Event {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> Event.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> Event.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> Event.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasSenderId:Bool {
         get {
             return builderResult.hasSenderId
         }
    }
    public var senderId:ParticipantId! {
         get {
             if senderIdBuilder_ != nil {
                builderResult.senderId = senderIdBuilder_.getMessage()
             }
             return builderResult.senderId
         }
         set (value) {
             builderResult.hasSenderId = true
             builderResult.senderId = value
         }
    }
    private var senderIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasSenderId = true
         }
    }
    public func getSenderIdBuilder() -> ParticipantId.Builder {
      if senderIdBuilder_ == nil {
         senderIdBuilder_ = ParticipantId.Builder()
         builderResult.senderId = senderIdBuilder_.getMessage()
         if senderId != nil {
            try! senderIdBuilder_.mergeFrom(senderId)
         }
      }
      return senderIdBuilder_
    }
    public func setSenderId(_ value:ParticipantId!) -> Event.Builder {
      self.senderId = value
      return self
    }
    public func mergeSenderId(_ value:ParticipantId) throws -> Event.Builder {
      if builderResult.hasSenderId {
        builderResult.senderId = try ParticipantId.builderWithPrototype(builderResult.senderId).mergeFrom(value).buildPartial()
      } else {
        builderResult.senderId = value
      }
      builderResult.hasSenderId = true
      return self
    }
    public func clearSenderId() -> Event.Builder {
      senderIdBuilder_ = nil
      builderResult.hasSenderId = false
      builderResult.senderId = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> Event.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> Event.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    public var hasSelfEventState:Bool {
         get {
             return builderResult.hasSelfEventState
         }
    }
    public var selfEventState:UserEventState! {
         get {
             if selfEventStateBuilder_ != nil {
                builderResult.selfEventState = selfEventStateBuilder_.getMessage()
             }
             return builderResult.selfEventState
         }
         set (value) {
             builderResult.hasSelfEventState = true
             builderResult.selfEventState = value
         }
    }
    private var selfEventStateBuilder_:UserEventState.Builder! {
         didSet {
            builderResult.hasSelfEventState = true
         }
    }
    public func getSelfEventStateBuilder() -> UserEventState.Builder {
      if selfEventStateBuilder_ == nil {
         selfEventStateBuilder_ = UserEventState.Builder()
         builderResult.selfEventState = selfEventStateBuilder_.getMessage()
         if selfEventState != nil {
            try! selfEventStateBuilder_.mergeFrom(selfEventState)
         }
      }
      return selfEventStateBuilder_
    }
    public func setSelfEventState(_ value:UserEventState!) -> Event.Builder {
      self.selfEventState = value
      return self
    }
    public func mergeSelfEventState(_ value:UserEventState) throws -> Event.Builder {
      if builderResult.hasSelfEventState {
        builderResult.selfEventState = try UserEventState.builderWithPrototype(builderResult.selfEventState).mergeFrom(value).buildPartial()
      } else {
        builderResult.selfEventState = value
      }
      builderResult.hasSelfEventState = true
      return self
    }
    public func clearSelfEventState() -> Event.Builder {
      selfEventStateBuilder_ = nil
      builderResult.hasSelfEventState = false
      builderResult.selfEventState = nil
      return self
    }
      public var hasSourceType:Bool{
          get {
              return builderResult.hasSourceType
          }
      }
      public var sourceType:SourceType {
          get {
              return builderResult.sourceType
          }
          set (value) {
              builderResult.hasSourceType = true
              builderResult.sourceType = value
          }
      }
      public func setSourceType(_ value:SourceType) -> Event.Builder {
        self.sourceType = value
        return self
      }
      public func clearSourceType() -> Event.Builder {
         builderResult.hasSourceType = false
         builderResult.sourceType = .SourceTypeUnknown
         return self
      }
    public var hasChatMessage:Bool {
         get {
             return builderResult.hasChatMessage
         }
    }
    public var chatMessage:ChatMessage! {
         get {
             if chatMessageBuilder_ != nil {
                builderResult.chatMessage = chatMessageBuilder_.getMessage()
             }
             return builderResult.chatMessage
         }
         set (value) {
             builderResult.hasChatMessage = true
             builderResult.chatMessage = value
         }
    }
    private var chatMessageBuilder_:ChatMessage.Builder! {
         didSet {
            builderResult.hasChatMessage = true
         }
    }
    public func getChatMessageBuilder() -> ChatMessage.Builder {
      if chatMessageBuilder_ == nil {
         chatMessageBuilder_ = ChatMessage.Builder()
         builderResult.chatMessage = chatMessageBuilder_.getMessage()
         if chatMessage != nil {
            try! chatMessageBuilder_.mergeFrom(chatMessage)
         }
      }
      return chatMessageBuilder_
    }
    public func setChatMessage(_ value:ChatMessage!) -> Event.Builder {
      self.chatMessage = value
      return self
    }
    public func mergeChatMessage(_ value:ChatMessage) throws -> Event.Builder {
      if builderResult.hasChatMessage {
        builderResult.chatMessage = try ChatMessage.builderWithPrototype(builderResult.chatMessage).mergeFrom(value).buildPartial()
      } else {
        builderResult.chatMessage = value
      }
      builderResult.hasChatMessage = true
      return self
    }
    public func clearChatMessage() -> Event.Builder {
      chatMessageBuilder_ = nil
      builderResult.hasChatMessage = false
      builderResult.chatMessage = nil
      return self
    }
    public var hasMembershipChange:Bool {
         get {
             return builderResult.hasMembershipChange
         }
    }
    public var membershipChange:MembershipChange! {
         get {
             if membershipChangeBuilder_ != nil {
                builderResult.membershipChange = membershipChangeBuilder_.getMessage()
             }
             return builderResult.membershipChange
         }
         set (value) {
             builderResult.hasMembershipChange = true
             builderResult.membershipChange = value
         }
    }
    private var membershipChangeBuilder_:MembershipChange.Builder! {
         didSet {
            builderResult.hasMembershipChange = true
         }
    }
    public func getMembershipChangeBuilder() -> MembershipChange.Builder {
      if membershipChangeBuilder_ == nil {
         membershipChangeBuilder_ = MembershipChange.Builder()
         builderResult.membershipChange = membershipChangeBuilder_.getMessage()
         if membershipChange != nil {
            try! membershipChangeBuilder_.mergeFrom(membershipChange)
         }
      }
      return membershipChangeBuilder_
    }
    public func setMembershipChange(_ value:MembershipChange!) -> Event.Builder {
      self.membershipChange = value
      return self
    }
    public func mergeMembershipChange(_ value:MembershipChange) throws -> Event.Builder {
      if builderResult.hasMembershipChange {
        builderResult.membershipChange = try MembershipChange.builderWithPrototype(builderResult.membershipChange).mergeFrom(value).buildPartial()
      } else {
        builderResult.membershipChange = value
      }
      builderResult.hasMembershipChange = true
      return self
    }
    public func clearMembershipChange() -> Event.Builder {
      membershipChangeBuilder_ = nil
      builderResult.hasMembershipChange = false
      builderResult.membershipChange = nil
      return self
    }
    public var hasConversationRename:Bool {
         get {
             return builderResult.hasConversationRename
         }
    }
    public var conversationRename:ConversationRename! {
         get {
             if conversationRenameBuilder_ != nil {
                builderResult.conversationRename = conversationRenameBuilder_.getMessage()
             }
             return builderResult.conversationRename
         }
         set (value) {
             builderResult.hasConversationRename = true
             builderResult.conversationRename = value
         }
    }
    private var conversationRenameBuilder_:ConversationRename.Builder! {
         didSet {
            builderResult.hasConversationRename = true
         }
    }
    public func getConversationRenameBuilder() -> ConversationRename.Builder {
      if conversationRenameBuilder_ == nil {
         conversationRenameBuilder_ = ConversationRename.Builder()
         builderResult.conversationRename = conversationRenameBuilder_.getMessage()
         if conversationRename != nil {
            try! conversationRenameBuilder_.mergeFrom(conversationRename)
         }
      }
      return conversationRenameBuilder_
    }
    public func setConversationRename(_ value:ConversationRename!) -> Event.Builder {
      self.conversationRename = value
      return self
    }
    public func mergeConversationRename(_ value:ConversationRename) throws -> Event.Builder {
      if builderResult.hasConversationRename {
        builderResult.conversationRename = try ConversationRename.builderWithPrototype(builderResult.conversationRename).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationRename = value
      }
      builderResult.hasConversationRename = true
      return self
    }
    public func clearConversationRename() -> Event.Builder {
      conversationRenameBuilder_ = nil
      builderResult.hasConversationRename = false
      builderResult.conversationRename = nil
      return self
    }
    public var hasHangoutEvent:Bool {
         get {
             return builderResult.hasHangoutEvent
         }
    }
    public var hangoutEvent:HangoutEvent! {
         get {
             if hangoutEventBuilder_ != nil {
                builderResult.hangoutEvent = hangoutEventBuilder_.getMessage()
             }
             return builderResult.hangoutEvent
         }
         set (value) {
             builderResult.hasHangoutEvent = true
             builderResult.hangoutEvent = value
         }
    }
    private var hangoutEventBuilder_:HangoutEvent.Builder! {
         didSet {
            builderResult.hasHangoutEvent = true
         }
    }
    public func getHangoutEventBuilder() -> HangoutEvent.Builder {
      if hangoutEventBuilder_ == nil {
         hangoutEventBuilder_ = HangoutEvent.Builder()
         builderResult.hangoutEvent = hangoutEventBuilder_.getMessage()
         if hangoutEvent != nil {
            try! hangoutEventBuilder_.mergeFrom(hangoutEvent)
         }
      }
      return hangoutEventBuilder_
    }
    public func setHangoutEvent(_ value:HangoutEvent!) -> Event.Builder {
      self.hangoutEvent = value
      return self
    }
    public func mergeHangoutEvent(_ value:HangoutEvent) throws -> Event.Builder {
      if builderResult.hasHangoutEvent {
        builderResult.hangoutEvent = try HangoutEvent.builderWithPrototype(builderResult.hangoutEvent).mergeFrom(value).buildPartial()
      } else {
        builderResult.hangoutEvent = value
      }
      builderResult.hasHangoutEvent = true
      return self
    }
    public func clearHangoutEvent() -> Event.Builder {
      hangoutEventBuilder_ = nil
      builderResult.hasHangoutEvent = false
      builderResult.hangoutEvent = nil
      return self
    }
    public var hasEventId:Bool {
         get {
              return builderResult.hasEventId
         }
    }
    public var eventId:String {
         get {
              return builderResult.eventId
         }
         set (value) {
             builderResult.hasEventId = true
             builderResult.eventId = value
         }
    }
    public func setEventId(_ value:String) -> Event.Builder {
      self.eventId = value
      return self
    }
    public func clearEventId() -> Event.Builder{
         builderResult.hasEventId = false
         builderResult.eventId = ""
         return self
    }
    public var hasExpirationTimestamp:Bool {
         get {
              return builderResult.hasExpirationTimestamp
         }
    }
    public var expirationTimestamp:UInt64 {
         get {
              return builderResult.expirationTimestamp
         }
         set (value) {
             builderResult.hasExpirationTimestamp = true
             builderResult.expirationTimestamp = value
         }
    }
    public func setExpirationTimestamp(_ value:UInt64) -> Event.Builder {
      self.expirationTimestamp = value
      return self
    }
    public func clearExpirationTimestamp() -> Event.Builder{
         builderResult.hasExpirationTimestamp = false
         builderResult.expirationTimestamp = UInt64(0)
         return self
    }
    public var hasOtrModification:Bool {
         get {
             return builderResult.hasOtrModification
         }
    }
    public var otrModification:Otrmodification! {
         get {
             if otrModificationBuilder_ != nil {
                builderResult.otrModification = otrModificationBuilder_.getMessage()
             }
             return builderResult.otrModification
         }
         set (value) {
             builderResult.hasOtrModification = true
             builderResult.otrModification = value
         }
    }
    private var otrModificationBuilder_:Otrmodification.Builder! {
         didSet {
            builderResult.hasOtrModification = true
         }
    }
    public func getOtrModificationBuilder() -> Otrmodification.Builder {
      if otrModificationBuilder_ == nil {
         otrModificationBuilder_ = Otrmodification.Builder()
         builderResult.otrModification = otrModificationBuilder_.getMessage()
         if otrModification != nil {
            try! otrModificationBuilder_.mergeFrom(otrModification)
         }
      }
      return otrModificationBuilder_
    }
    public func setOtrModification(_ value:Otrmodification!) -> Event.Builder {
      self.otrModification = value
      return self
    }
    public func mergeOtrModification(_ value:Otrmodification) throws -> Event.Builder {
      if builderResult.hasOtrModification {
        builderResult.otrModification = try Otrmodification.builderWithPrototype(builderResult.otrModification).mergeFrom(value).buildPartial()
      } else {
        builderResult.otrModification = value
      }
      builderResult.hasOtrModification = true
      return self
    }
    public func clearOtrModification() -> Event.Builder {
      otrModificationBuilder_ = nil
      builderResult.hasOtrModification = false
      builderResult.otrModification = nil
      return self
    }
    public var hasAdvancesSortTimestamp:Bool {
         get {
              return builderResult.hasAdvancesSortTimestamp
         }
    }
    public var advancesSortTimestamp:Bool {
         get {
              return builderResult.advancesSortTimestamp
         }
         set (value) {
             builderResult.hasAdvancesSortTimestamp = true
             builderResult.advancesSortTimestamp = value
         }
    }
    public func setAdvancesSortTimestamp(_ value:Bool) -> Event.Builder {
      self.advancesSortTimestamp = value
      return self
    }
    public func clearAdvancesSortTimestamp() -> Event.Builder{
         builderResult.hasAdvancesSortTimestamp = false
         builderResult.advancesSortTimestamp = false
         return self
    }
      public var hasOtrStatus:Bool{
          get {
              return builderResult.hasOtrStatus
          }
      }
      public var otrStatus:OffTheRecordStatus {
          get {
              return builderResult.otrStatus
          }
          set (value) {
              builderResult.hasOtrStatus = true
              builderResult.otrStatus = value
          }
      }
      public func setOtrStatus(_ value:OffTheRecordStatus) -> Event.Builder {
        self.otrStatus = value
        return self
      }
      public func clearOtrStatus() -> Event.Builder {
         builderResult.hasOtrStatus = false
         builderResult.otrStatus = .OffTheRecordStatusUnknown
         return self
      }
    public var hasPersisted:Bool {
         get {
              return builderResult.hasPersisted
         }
    }
    public var persisted:Bool {
         get {
              return builderResult.persisted
         }
         set (value) {
             builderResult.hasPersisted = true
             builderResult.persisted = value
         }
    }
    public func setPersisted(_ value:Bool) -> Event.Builder {
      self.persisted = value
      return self
    }
    public func clearPersisted() -> Event.Builder{
         builderResult.hasPersisted = false
         builderResult.persisted = false
         return self
    }
    public var hasMediumType:Bool {
         get {
             return builderResult.hasMediumType
         }
    }
    public var mediumType:DeliveryMedium! {
         get {
             if mediumTypeBuilder_ != nil {
                builderResult.mediumType = mediumTypeBuilder_.getMessage()
             }
             return builderResult.mediumType
         }
         set (value) {
             builderResult.hasMediumType = true
             builderResult.mediumType = value
         }
    }
    private var mediumTypeBuilder_:DeliveryMedium.Builder! {
         didSet {
            builderResult.hasMediumType = true
         }
    }
    public func getMediumTypeBuilder() -> DeliveryMedium.Builder {
      if mediumTypeBuilder_ == nil {
         mediumTypeBuilder_ = DeliveryMedium.Builder()
         builderResult.mediumType = mediumTypeBuilder_.getMessage()
         if mediumType != nil {
            try! mediumTypeBuilder_.mergeFrom(mediumType)
         }
      }
      return mediumTypeBuilder_
    }
    public func setMediumType(_ value:DeliveryMedium!) -> Event.Builder {
      self.mediumType = value
      return self
    }
    public func mergeMediumType(_ value:DeliveryMedium) throws -> Event.Builder {
      if builderResult.hasMediumType {
        builderResult.mediumType = try DeliveryMedium.builderWithPrototype(builderResult.mediumType).mergeFrom(value).buildPartial()
      } else {
        builderResult.mediumType = value
      }
      builderResult.hasMediumType = true
      return self
    }
    public func clearMediumType() -> Event.Builder {
      mediumTypeBuilder_ = nil
      builderResult.hasMediumType = false
      builderResult.mediumType = nil
      return self
    }
      public var hasEventType:Bool{
          get {
              return builderResult.hasEventType
          }
      }
      public var eventType:EventType {
          get {
              return builderResult.eventType
          }
          set (value) {
              builderResult.hasEventType = true
              builderResult.eventType = value
          }
      }
      public func setEventType(_ value:EventType) -> Event.Builder {
        self.eventType = value
        return self
      }
      public func clearEventType() -> Event.Builder {
         builderResult.hasEventType = false
         builderResult.eventType = .EventTypeUnknown
         return self
      }
    public var hasEventVersion:Bool {
         get {
              return builderResult.hasEventVersion
         }
    }
    public var eventVersion:UInt64 {
         get {
              return builderResult.eventVersion
         }
         set (value) {
             builderResult.hasEventVersion = true
             builderResult.eventVersion = value
         }
    }
    public func setEventVersion(_ value:UInt64) -> Event.Builder {
      self.eventVersion = value
      return self
    }
    public func clearEventVersion() -> Event.Builder{
         builderResult.hasEventVersion = false
         builderResult.eventVersion = UInt64(0)
         return self
    }
    public var hasHashModifier:Bool {
         get {
             return builderResult.hasHashModifier
         }
    }
    public var hashModifier:HashModifier! {
         get {
             if hashModifierBuilder_ != nil {
                builderResult.hashModifier = hashModifierBuilder_.getMessage()
             }
             return builderResult.hashModifier
         }
         set (value) {
             builderResult.hasHashModifier = true
             builderResult.hashModifier = value
         }
    }
    private var hashModifierBuilder_:HashModifier.Builder! {
         didSet {
            builderResult.hasHashModifier = true
         }
    }
    public func getHashModifierBuilder() -> HashModifier.Builder {
      if hashModifierBuilder_ == nil {
         hashModifierBuilder_ = HashModifier.Builder()
         builderResult.hashModifier = hashModifierBuilder_.getMessage()
         if hashModifier != nil {
            try! hashModifierBuilder_.mergeFrom(hashModifier)
         }
      }
      return hashModifierBuilder_
    }
    public func setHashModifier(_ value:HashModifier!) -> Event.Builder {
      self.hashModifier = value
      return self
    }
    public func mergeHashModifier(_ value:HashModifier) throws -> Event.Builder {
      if builderResult.hasHashModifier {
        builderResult.hashModifier = try HashModifier.builderWithPrototype(builderResult.hashModifier).mergeFrom(value).buildPartial()
      } else {
        builderResult.hashModifier = value
      }
      builderResult.hasHashModifier = true
      return self
    }
    public func clearHashModifier() -> Event.Builder {
      hashModifierBuilder_ = nil
      builderResult.hasHashModifier = false
      builderResult.hashModifier = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Event.Builder {
      builderResult = Event()
      return self
    }
    public override func clone() throws -> Event.Builder {
      return try Event.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Event {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Event {
      let returnMe:Event = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Event) throws -> Event.Builder {
      if other == Event() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasSenderId) {
          try mergeSenderId(other.senderId)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      if (other.hasSelfEventState) {
          try mergeSelfEventState(other.selfEventState)
      }
      if other.hasSourceType {
           sourceType = other.sourceType
      }
      if (other.hasChatMessage) {
          try mergeChatMessage(other.chatMessage)
      }
      if (other.hasMembershipChange) {
          try mergeMembershipChange(other.membershipChange)
      }
      if (other.hasConversationRename) {
          try mergeConversationRename(other.conversationRename)
      }
      if (other.hasHangoutEvent) {
          try mergeHangoutEvent(other.hangoutEvent)
      }
      if other.hasEventId {
           eventId = other.eventId
      }
      if other.hasExpirationTimestamp {
           expirationTimestamp = other.expirationTimestamp
      }
      if (other.hasOtrModification) {
          try mergeOtrModification(other.otrModification)
      }
      if other.hasAdvancesSortTimestamp {
           advancesSortTimestamp = other.advancesSortTimestamp
      }
      if other.hasOtrStatus {
           otrStatus = other.otrStatus
      }
      if other.hasPersisted {
           persisted = other.persisted
      }
      if (other.hasMediumType) {
          try mergeMediumType(other.mediumType)
      }
      if other.hasEventType {
           eventType = other.eventType
      }
      if other.hasEventVersion {
           eventVersion = other.eventVersion
      }
      if (other.hasHashModifier) {
          try mergeHashModifier(other.hashModifier)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Event.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Event.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 18:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasSenderId {
            try subBuilder.mergeFrom(senderId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          senderId = subBuilder.buildPartial()

        case 24:
          timestamp = try input.readUInt64()

        case 34:
          let subBuilder:UserEventState.Builder = UserEventState.Builder()
          if hasSelfEventState {
            try subBuilder.mergeFrom(selfEventState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          selfEventState = subBuilder.buildPartial()

        case 48:
          let valueIntsourceType = try input.readEnum()
          if let enumssourceType = SourceType(rawValue:valueIntsourceType){
               sourceType = enumssourceType
          } else {
               try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntsourceType))
          }

        case 58:
          let subBuilder:ChatMessage.Builder = ChatMessage.Builder()
          if hasChatMessage {
            try subBuilder.mergeFrom(chatMessage)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          chatMessage = subBuilder.buildPartial()

        case 74:
          let subBuilder:MembershipChange.Builder = MembershipChange.Builder()
          if hasMembershipChange {
            try subBuilder.mergeFrom(membershipChange)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          membershipChange = subBuilder.buildPartial()

        case 82:
          let subBuilder:ConversationRename.Builder = ConversationRename.Builder()
          if hasConversationRename {
            try subBuilder.mergeFrom(conversationRename)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationRename = subBuilder.buildPartial()

        case 90:
          let subBuilder:HangoutEvent.Builder = HangoutEvent.Builder()
          if hasHangoutEvent {
            try subBuilder.mergeFrom(hangoutEvent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          hangoutEvent = subBuilder.buildPartial()

        case 98:
          eventId = try input.readString()

        case 104:
          expirationTimestamp = try input.readUInt64()

        case 114:
          let subBuilder:Otrmodification.Builder = Otrmodification.Builder()
          if hasOtrModification {
            try subBuilder.mergeFrom(otrModification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          otrModification = subBuilder.buildPartial()

        case 120:
          advancesSortTimestamp = try input.readBool()

        case 128:
          let valueIntotrStatus = try input.readEnum()
          if let enumsotrStatus = OffTheRecordStatus(rawValue:valueIntotrStatus){
               otrStatus = enumsotrStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(16, value:Int64(valueIntotrStatus))
          }

        case 136:
          persisted = try input.readBool()

        case 162:
          let subBuilder:DeliveryMedium.Builder = DeliveryMedium.Builder()
          if hasMediumType {
            try subBuilder.mergeFrom(mediumType)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          mediumType = subBuilder.buildPartial()

        case 184:
          let valueInteventType = try input.readEnum()
          if let enumseventType = EventType(rawValue:valueInteventType){
               eventType = enumseventType
          } else {
               try unknownFieldsBuilder.mergeVarintField(23, value:Int64(valueInteventType))
          }

        case 192:
          eventVersion = try input.readUInt64()

        case 210:
          let subBuilder:HashModifier.Builder = HashModifier.Builder()
          if hasHashModifier {
            try subBuilder.mergeFrom(hashModifier)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          hashModifier = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserReadState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var participantId:ParticipantId!
  public private(set) var hasParticipantId:Bool = false
  public private(set) var latestReadTimestamp:UInt64 = UInt64(0)

  public private(set) var hasLatestReadTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasParticipantId {
      try output.writeMessage(1, value:participantId)
    }
    if hasLatestReadTimestamp {
      try output.writeUInt64(2, value:latestReadTimestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasParticipantId {
        if let varSizeparticipantId = participantId?.computeMessageSize(1) {
            serialize_size += varSizeparticipantId
        }
    }
    if hasLatestReadTimestamp {
      serialize_size += latestReadTimestamp.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<UserReadState> {
    var mergedArray = Array<UserReadState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> UserReadState? {
    return try UserReadState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserReadState {
    return try UserReadState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserReadState.Builder {
    return UserReadState.classBuilder() as! UserReadState.Builder
  }
  public func getBuilder() -> UserReadState.Builder {
    return classBuilder() as! UserReadState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserReadState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserReadState.Builder()
  }
  public func toBuilder() throws -> UserReadState.Builder {
    return try UserReadState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:UserReadState) throws -> UserReadState.Builder {
    return try UserReadState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasParticipantId {
      output += "\(indent) participantId {\n"
      if let outDescParticipantId = participantId {
        output += try outDescParticipantId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLatestReadTimestamp {
      output += "\(indent) latestReadTimestamp: \(latestReadTimestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasParticipantId {
              if let hashValueparticipantId = participantId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueparticipantId
              }
          }
          if hasLatestReadTimestamp {
             hashCode = (hashCode &* 31) &+ latestReadTimestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserReadState"
  }
  override public func className() -> String {
      return "UserReadState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserReadState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserReadState = UserReadState()
    public func getMessage() -> UserReadState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasParticipantId:Bool {
         get {
             return builderResult.hasParticipantId
         }
    }
    public var participantId:ParticipantId! {
         get {
             if participantIdBuilder_ != nil {
                builderResult.participantId = participantIdBuilder_.getMessage()
             }
             return builderResult.participantId
         }
         set (value) {
             builderResult.hasParticipantId = true
             builderResult.participantId = value
         }
    }
    private var participantIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasParticipantId = true
         }
    }
    public func getParticipantIdBuilder() -> ParticipantId.Builder {
      if participantIdBuilder_ == nil {
         participantIdBuilder_ = ParticipantId.Builder()
         builderResult.participantId = participantIdBuilder_.getMessage()
         if participantId != nil {
            try! participantIdBuilder_.mergeFrom(participantId)
         }
      }
      return participantIdBuilder_
    }
    public func setParticipantId(_ value:ParticipantId!) -> UserReadState.Builder {
      self.participantId = value
      return self
    }
    public func mergeParticipantId(_ value:ParticipantId) throws -> UserReadState.Builder {
      if builderResult.hasParticipantId {
        builderResult.participantId = try ParticipantId.builderWithPrototype(builderResult.participantId).mergeFrom(value).buildPartial()
      } else {
        builderResult.participantId = value
      }
      builderResult.hasParticipantId = true
      return self
    }
    public func clearParticipantId() -> UserReadState.Builder {
      participantIdBuilder_ = nil
      builderResult.hasParticipantId = false
      builderResult.participantId = nil
      return self
    }
    public var hasLatestReadTimestamp:Bool {
         get {
              return builderResult.hasLatestReadTimestamp
         }
    }
    public var latestReadTimestamp:UInt64 {
         get {
              return builderResult.latestReadTimestamp
         }
         set (value) {
             builderResult.hasLatestReadTimestamp = true
             builderResult.latestReadTimestamp = value
         }
    }
    public func setLatestReadTimestamp(_ value:UInt64) -> UserReadState.Builder {
      self.latestReadTimestamp = value
      return self
    }
    public func clearLatestReadTimestamp() -> UserReadState.Builder{
         builderResult.hasLatestReadTimestamp = false
         builderResult.latestReadTimestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserReadState.Builder {
      builderResult = UserReadState()
      return self
    }
    public override func clone() throws -> UserReadState.Builder {
      return try UserReadState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserReadState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserReadState {
      let returnMe:UserReadState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:UserReadState) throws -> UserReadState.Builder {
      if other == UserReadState() {
       return self
      }
      if (other.hasParticipantId) {
          try mergeParticipantId(other.participantId)
      }
      if other.hasLatestReadTimestamp {
           latestReadTimestamp = other.latestReadTimestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> UserReadState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserReadState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasParticipantId {
            try subBuilder.mergeFrom(participantId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          participantId = subBuilder.buildPartial()

        case 16:
          latestReadTimestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeliveryMedium : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var mediumType:DeliveryMediumType = DeliveryMediumType.DeliveryMediumUnknown
  public private(set) var hasMediumType:Bool = false
  public private(set) var phoneNumber:PhoneNumber!
  public private(set) var hasPhoneNumber:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMediumType {
      try output.writeEnum(1, value:mediumType.rawValue)
    }
    if hasPhoneNumber {
      try output.writeMessage(2, value:phoneNumber)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasMediumType) {
      serialize_size += mediumType.rawValue.computeEnumSize(1)
    }
    if hasPhoneNumber {
        if let varSizephoneNumber = phoneNumber?.computeMessageSize(2) {
            serialize_size += varSizephoneNumber
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeliveryMedium> {
    var mergedArray = Array<DeliveryMedium>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeliveryMedium? {
    return try DeliveryMedium.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMedium {
    return try DeliveryMedium.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeliveryMedium.Builder {
    return DeliveryMedium.classBuilder() as! DeliveryMedium.Builder
  }
  public func getBuilder() -> DeliveryMedium.Builder {
    return classBuilder() as! DeliveryMedium.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeliveryMedium.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeliveryMedium.Builder()
  }
  public func toBuilder() throws -> DeliveryMedium.Builder {
    return try DeliveryMedium.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeliveryMedium) throws -> DeliveryMedium.Builder {
    return try DeliveryMedium.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasMediumType) {
      output += "\(indent) mediumType: \(mediumType.description)\n"
    }
    if hasPhoneNumber {
      output += "\(indent) phoneNumber {\n"
      if let outDescPhoneNumber = phoneNumber {
        output += try outDescPhoneNumber.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMediumType {
             hashCode = (hashCode &* 31) &+ Int(mediumType.rawValue)
          }
          if hasPhoneNumber {
              if let hashValuephoneNumber = phoneNumber?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuephoneNumber
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeliveryMedium"
  }
  override public func className() -> String {
      return "DeliveryMedium"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeliveryMedium.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeliveryMedium = DeliveryMedium()
    public func getMessage() -> DeliveryMedium {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasMediumType:Bool{
          get {
              return builderResult.hasMediumType
          }
      }
      public var mediumType:DeliveryMediumType {
          get {
              return builderResult.mediumType
          }
          set (value) {
              builderResult.hasMediumType = true
              builderResult.mediumType = value
          }
      }
      public func setMediumType(_ value:DeliveryMediumType) -> DeliveryMedium.Builder {
        self.mediumType = value
        return self
      }
      public func clearMediumType() -> DeliveryMedium.Builder {
         builderResult.hasMediumType = false
         builderResult.mediumType = .DeliveryMediumUnknown
         return self
      }
    public var hasPhoneNumber:Bool {
         get {
             return builderResult.hasPhoneNumber
         }
    }
    public var phoneNumber:PhoneNumber! {
         get {
             if phoneNumberBuilder_ != nil {
                builderResult.phoneNumber = phoneNumberBuilder_.getMessage()
             }
             return builderResult.phoneNumber
         }
         set (value) {
             builderResult.hasPhoneNumber = true
             builderResult.phoneNumber = value
         }
    }
    private var phoneNumberBuilder_:PhoneNumber.Builder! {
         didSet {
            builderResult.hasPhoneNumber = true
         }
    }
    public func getPhoneNumberBuilder() -> PhoneNumber.Builder {
      if phoneNumberBuilder_ == nil {
         phoneNumberBuilder_ = PhoneNumber.Builder()
         builderResult.phoneNumber = phoneNumberBuilder_.getMessage()
         if phoneNumber != nil {
            try! phoneNumberBuilder_.mergeFrom(phoneNumber)
         }
      }
      return phoneNumberBuilder_
    }
    public func setPhoneNumber(_ value:PhoneNumber!) -> DeliveryMedium.Builder {
      self.phoneNumber = value
      return self
    }
    public func mergePhoneNumber(_ value:PhoneNumber) throws -> DeliveryMedium.Builder {
      if builderResult.hasPhoneNumber {
        builderResult.phoneNumber = try PhoneNumber.builderWithPrototype(builderResult.phoneNumber).mergeFrom(value).buildPartial()
      } else {
        builderResult.phoneNumber = value
      }
      builderResult.hasPhoneNumber = true
      return self
    }
    public func clearPhoneNumber() -> DeliveryMedium.Builder {
      phoneNumberBuilder_ = nil
      builderResult.hasPhoneNumber = false
      builderResult.phoneNumber = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeliveryMedium.Builder {
      builderResult = DeliveryMedium()
      return self
    }
    public override func clone() throws -> DeliveryMedium.Builder {
      return try DeliveryMedium.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeliveryMedium {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeliveryMedium {
      let returnMe:DeliveryMedium = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeliveryMedium) throws -> DeliveryMedium.Builder {
      if other == DeliveryMedium() {
       return self
      }
      if other.hasMediumType {
           mediumType = other.mediumType
      }
      if (other.hasPhoneNumber) {
          try mergePhoneNumber(other.phoneNumber)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeliveryMedium.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMedium.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntmediumType = try input.readEnum()
          if let enumsmediumType = DeliveryMediumType(rawValue:valueIntmediumType){
               mediumType = enumsmediumType
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntmediumType))
          }

        case 18:
          let subBuilder:PhoneNumber.Builder = PhoneNumber.Builder()
          if hasPhoneNumber {
            try subBuilder.mergeFrom(phoneNumber)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          phoneNumber = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeliveryMediumOption : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var deliveryMedium:DeliveryMedium!
  public private(set) var hasDeliveryMedium:Bool = false
  public private(set) var currentDefault:Bool = false

  public private(set) var hasCurrentDefault:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDeliveryMedium {
      try output.writeMessage(1, value:deliveryMedium)
    }
    if hasCurrentDefault {
      try output.writeBool(2, value:currentDefault)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDeliveryMedium {
        if let varSizedeliveryMedium = deliveryMedium?.computeMessageSize(1) {
            serialize_size += varSizedeliveryMedium
        }
    }
    if hasCurrentDefault {
      serialize_size += currentDefault.computeBoolSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeliveryMediumOption> {
    var mergedArray = Array<DeliveryMediumOption>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeliveryMediumOption? {
    return try DeliveryMediumOption.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMediumOption {
    return try DeliveryMediumOption.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeliveryMediumOption.Builder {
    return DeliveryMediumOption.classBuilder() as! DeliveryMediumOption.Builder
  }
  public func getBuilder() -> DeliveryMediumOption.Builder {
    return classBuilder() as! DeliveryMediumOption.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeliveryMediumOption.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeliveryMediumOption.Builder()
  }
  public func toBuilder() throws -> DeliveryMediumOption.Builder {
    return try DeliveryMediumOption.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeliveryMediumOption) throws -> DeliveryMediumOption.Builder {
    return try DeliveryMediumOption.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDeliveryMedium {
      output += "\(indent) deliveryMedium {\n"
      if let outDescDeliveryMedium = deliveryMedium {
        output += try outDescDeliveryMedium.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCurrentDefault {
      output += "\(indent) currentDefault: \(currentDefault) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDeliveryMedium {
              if let hashValuedeliveryMedium = deliveryMedium?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeliveryMedium
              }
          }
          if hasCurrentDefault {
             hashCode = (hashCode &* 31) &+ currentDefault.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeliveryMediumOption"
  }
  override public func className() -> String {
      return "DeliveryMediumOption"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeliveryMediumOption.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeliveryMediumOption = DeliveryMediumOption()
    public func getMessage() -> DeliveryMediumOption {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDeliveryMedium:Bool {
         get {
             return builderResult.hasDeliveryMedium
         }
    }
    public var deliveryMedium:DeliveryMedium! {
         get {
             if deliveryMediumBuilder_ != nil {
                builderResult.deliveryMedium = deliveryMediumBuilder_.getMessage()
             }
             return builderResult.deliveryMedium
         }
         set (value) {
             builderResult.hasDeliveryMedium = true
             builderResult.deliveryMedium = value
         }
    }
    private var deliveryMediumBuilder_:DeliveryMedium.Builder! {
         didSet {
            builderResult.hasDeliveryMedium = true
         }
    }
    public func getDeliveryMediumBuilder() -> DeliveryMedium.Builder {
      if deliveryMediumBuilder_ == nil {
         deliveryMediumBuilder_ = DeliveryMedium.Builder()
         builderResult.deliveryMedium = deliveryMediumBuilder_.getMessage()
         if deliveryMedium != nil {
            try! deliveryMediumBuilder_.mergeFrom(deliveryMedium)
         }
      }
      return deliveryMediumBuilder_
    }
    public func setDeliveryMedium(_ value:DeliveryMedium!) -> DeliveryMediumOption.Builder {
      self.deliveryMedium = value
      return self
    }
    public func mergeDeliveryMedium(_ value:DeliveryMedium) throws -> DeliveryMediumOption.Builder {
      if builderResult.hasDeliveryMedium {
        builderResult.deliveryMedium = try DeliveryMedium.builderWithPrototype(builderResult.deliveryMedium).mergeFrom(value).buildPartial()
      } else {
        builderResult.deliveryMedium = value
      }
      builderResult.hasDeliveryMedium = true
      return self
    }
    public func clearDeliveryMedium() -> DeliveryMediumOption.Builder {
      deliveryMediumBuilder_ = nil
      builderResult.hasDeliveryMedium = false
      builderResult.deliveryMedium = nil
      return self
    }
    public var hasCurrentDefault:Bool {
         get {
              return builderResult.hasCurrentDefault
         }
    }
    public var currentDefault:Bool {
         get {
              return builderResult.currentDefault
         }
         set (value) {
             builderResult.hasCurrentDefault = true
             builderResult.currentDefault = value
         }
    }
    public func setCurrentDefault(_ value:Bool) -> DeliveryMediumOption.Builder {
      self.currentDefault = value
      return self
    }
    public func clearCurrentDefault() -> DeliveryMediumOption.Builder{
         builderResult.hasCurrentDefault = false
         builderResult.currentDefault = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeliveryMediumOption.Builder {
      builderResult = DeliveryMediumOption()
      return self
    }
    public override func clone() throws -> DeliveryMediumOption.Builder {
      return try DeliveryMediumOption.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeliveryMediumOption {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeliveryMediumOption {
      let returnMe:DeliveryMediumOption = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeliveryMediumOption) throws -> DeliveryMediumOption.Builder {
      if other == DeliveryMediumOption() {
       return self
      }
      if (other.hasDeliveryMedium) {
          try mergeDeliveryMedium(other.deliveryMedium)
      }
      if other.hasCurrentDefault {
           currentDefault = other.currentDefault
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeliveryMediumOption.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeliveryMediumOption.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:DeliveryMedium.Builder = DeliveryMedium.Builder()
          if hasDeliveryMedium {
            try subBuilder.mergeFrom(deliveryMedium)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deliveryMedium = subBuilder.buildPartial()

        case 16:
          currentDefault = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserConversationState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var clientGeneratedId:String = ""

  public private(set) var hasClientGeneratedId:Bool = false
  public private(set) var selfReadState:UserReadState!
  public private(set) var hasSelfReadState:Bool = false
  public private(set) var status:ConversationStatus = ConversationStatus.ConversationStatusUnknown
  public private(set) var hasStatus:Bool = false
  public private(set) var notificationLevel:NotificationLevel = NotificationLevel.NotificationLevelUnknown
  public private(set) var hasNotificationLevel:Bool = false
  private var viewMemoizedSerializedSize:Int32 = 0
  public private(set) var view:Array<ConversationView> = Array<ConversationView>()
  public private(set) var inviterId:ParticipantId!
  public private(set) var hasInviterId:Bool = false
  public private(set) var inviteTimestamp:UInt64 = UInt64(0)

  public private(set) var hasInviteTimestamp:Bool = false
  public private(set) var sortTimestamp:UInt64 = UInt64(0)

  public private(set) var hasSortTimestamp:Bool = false
  public private(set) var activeTimestamp:UInt64 = UInt64(0)

  public private(set) var hasActiveTimestamp:Bool = false
  public private(set) var inviteAffinity:InvitationAffinity = InvitationAffinity.InviteAffinityUnknown
  public private(set) var hasInviteAffinity:Bool = false
  public private(set) var deliveryMediumOption:Array<DeliveryMediumOption>  = Array<DeliveryMediumOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasClientGeneratedId {
      try output.writeString(2, value:clientGeneratedId)
    }
    if hasSelfReadState {
      try output.writeMessage(7, value:selfReadState)
    }
    if hasStatus {
      try output.writeEnum(8, value:status.rawValue)
    }
    if hasNotificationLevel {
      try output.writeEnum(9, value:notificationLevel.rawValue)
    }
    for oneValueOfview in view {
        try output.writeEnum(10, value:oneValueOfview.rawValue)
    }
    if hasInviterId {
      try output.writeMessage(11, value:inviterId)
    }
    if hasInviteTimestamp {
      try output.writeUInt64(12, value:inviteTimestamp)
    }
    if hasSortTimestamp {
      try output.writeUInt64(13, value:sortTimestamp)
    }
    if hasActiveTimestamp {
      try output.writeUInt64(14, value:activeTimestamp)
    }
    if hasInviteAffinity {
      try output.writeEnum(15, value:inviteAffinity.rawValue)
    }
    for oneElementdeliveryMediumOption in deliveryMediumOption {
        try output.writeMessage(17, value:oneElementdeliveryMediumOption)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasClientGeneratedId {
      serialize_size += clientGeneratedId.computeStringSize(2)
    }
    if hasSelfReadState {
        if let varSizeselfReadState = selfReadState?.computeMessageSize(7) {
            serialize_size += varSizeselfReadState
        }
    }
    if (hasStatus) {
      serialize_size += status.rawValue.computeEnumSize(8)
    }
    if (hasNotificationLevel) {
      serialize_size += notificationLevel.rawValue.computeEnumSize(9)
    }
    var dataSizeview:Int32 = 0
    for oneValueOfview in view {
        dataSizeview += oneValueOfview.rawValue.computeEnumSizeNoTag()
    }
    serialize_size += dataSizeview
    serialize_size += (1 * Int32(view.count))
    if hasInviterId {
        if let varSizeinviterId = inviterId?.computeMessageSize(11) {
            serialize_size += varSizeinviterId
        }
    }
    if hasInviteTimestamp {
      serialize_size += inviteTimestamp.computeUInt64Size(12)
    }
    if hasSortTimestamp {
      serialize_size += sortTimestamp.computeUInt64Size(13)
    }
    if hasActiveTimestamp {
      serialize_size += activeTimestamp.computeUInt64Size(14)
    }
    if (hasInviteAffinity) {
      serialize_size += inviteAffinity.rawValue.computeEnumSize(15)
    }
    for oneElementdeliveryMediumOption in deliveryMediumOption {
        serialize_size += oneElementdeliveryMediumOption.computeMessageSize(17)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<UserConversationState> {
    var mergedArray = Array<UserConversationState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> UserConversationState? {
    return try UserConversationState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserConversationState {
    return try UserConversationState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserConversationState.Builder {
    return UserConversationState.classBuilder() as! UserConversationState.Builder
  }
  public func getBuilder() -> UserConversationState.Builder {
    return classBuilder() as! UserConversationState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserConversationState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserConversationState.Builder()
  }
  public func toBuilder() throws -> UserConversationState.Builder {
    return try UserConversationState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:UserConversationState) throws -> UserConversationState.Builder {
    return try UserConversationState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasClientGeneratedId {
      output += "\(indent) clientGeneratedId: \(clientGeneratedId) \n"
    }
    if hasSelfReadState {
      output += "\(indent) selfReadState {\n"
      if let outDescSelfReadState = selfReadState {
        output += try outDescSelfReadState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasStatus) {
      output += "\(indent) status: \(status.description)\n"
    }
    if (hasNotificationLevel) {
      output += "\(indent) notificationLevel: \(notificationLevel.description)\n"
    }
    var viewElementIndex:Int = 0
    for oneValueOfview in view {
        output += "\(indent) view[\(viewElementIndex)]: \(oneValueOfview.description)\n"
        viewElementIndex += 1
    }
    if hasInviterId {
      output += "\(indent) inviterId {\n"
      if let outDescInviterId = inviterId {
        output += try outDescInviterId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasInviteTimestamp {
      output += "\(indent) inviteTimestamp: \(inviteTimestamp) \n"
    }
    if hasSortTimestamp {
      output += "\(indent) sortTimestamp: \(sortTimestamp) \n"
    }
    if hasActiveTimestamp {
      output += "\(indent) activeTimestamp: \(activeTimestamp) \n"
    }
    if (hasInviteAffinity) {
      output += "\(indent) inviteAffinity: \(inviteAffinity.description)\n"
    }
    var deliveryMediumOptionElementIndex:Int = 0
    for oneElementdeliveryMediumOption in deliveryMediumOption {
        output += "\(indent) deliveryMediumOption[\(deliveryMediumOptionElementIndex)] {\n"
        output += try oneElementdeliveryMediumOption.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        deliveryMediumOptionElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasClientGeneratedId {
             hashCode = (hashCode &* 31) &+ clientGeneratedId.hashValue
          }
          if hasSelfReadState {
              if let hashValueselfReadState = selfReadState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueselfReadState
              }
          }
          if hasStatus {
             hashCode = (hashCode &* 31) &+ Int(status.rawValue)
          }
          if hasNotificationLevel {
             hashCode = (hashCode &* 31) &+ Int(notificationLevel.rawValue)
          }
          for oneValueOfview in view {
              hashCode = (hashCode &* 31) &+ Int(oneValueOfview.rawValue)
          }
          if hasInviterId {
              if let hashValueinviterId = inviterId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueinviterId
              }
          }
          if hasInviteTimestamp {
             hashCode = (hashCode &* 31) &+ inviteTimestamp.hashValue
          }
          if hasSortTimestamp {
             hashCode = (hashCode &* 31) &+ sortTimestamp.hashValue
          }
          if hasActiveTimestamp {
             hashCode = (hashCode &* 31) &+ activeTimestamp.hashValue
          }
          if hasInviteAffinity {
             hashCode = (hashCode &* 31) &+ Int(inviteAffinity.rawValue)
          }
          for oneElementdeliveryMediumOption in deliveryMediumOption {
              hashCode = (hashCode &* 31) &+ oneElementdeliveryMediumOption.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserConversationState"
  }
  override public func className() -> String {
      return "UserConversationState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserConversationState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserConversationState = UserConversationState()
    public func getMessage() -> UserConversationState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasClientGeneratedId:Bool {
         get {
              return builderResult.hasClientGeneratedId
         }
    }
    public var clientGeneratedId:String {
         get {
              return builderResult.clientGeneratedId
         }
         set (value) {
             builderResult.hasClientGeneratedId = true
             builderResult.clientGeneratedId = value
         }
    }
    public func setClientGeneratedId(_ value:String) -> UserConversationState.Builder {
      self.clientGeneratedId = value
      return self
    }
    public func clearClientGeneratedId() -> UserConversationState.Builder{
         builderResult.hasClientGeneratedId = false
         builderResult.clientGeneratedId = ""
         return self
    }
    public var hasSelfReadState:Bool {
         get {
             return builderResult.hasSelfReadState
         }
    }
    public var selfReadState:UserReadState! {
         get {
             if selfReadStateBuilder_ != nil {
                builderResult.selfReadState = selfReadStateBuilder_.getMessage()
             }
             return builderResult.selfReadState
         }
         set (value) {
             builderResult.hasSelfReadState = true
             builderResult.selfReadState = value
         }
    }
    private var selfReadStateBuilder_:UserReadState.Builder! {
         didSet {
            builderResult.hasSelfReadState = true
         }
    }
    public func getSelfReadStateBuilder() -> UserReadState.Builder {
      if selfReadStateBuilder_ == nil {
         selfReadStateBuilder_ = UserReadState.Builder()
         builderResult.selfReadState = selfReadStateBuilder_.getMessage()
         if selfReadState != nil {
            try! selfReadStateBuilder_.mergeFrom(selfReadState)
         }
      }
      return selfReadStateBuilder_
    }
    public func setSelfReadState(_ value:UserReadState!) -> UserConversationState.Builder {
      self.selfReadState = value
      return self
    }
    public func mergeSelfReadState(_ value:UserReadState) throws -> UserConversationState.Builder {
      if builderResult.hasSelfReadState {
        builderResult.selfReadState = try UserReadState.builderWithPrototype(builderResult.selfReadState).mergeFrom(value).buildPartial()
      } else {
        builderResult.selfReadState = value
      }
      builderResult.hasSelfReadState = true
      return self
    }
    public func clearSelfReadState() -> UserConversationState.Builder {
      selfReadStateBuilder_ = nil
      builderResult.hasSelfReadState = false
      builderResult.selfReadState = nil
      return self
    }
      public var hasStatus:Bool{
          get {
              return builderResult.hasStatus
          }
      }
      public var status:ConversationStatus {
          get {
              return builderResult.status
          }
          set (value) {
              builderResult.hasStatus = true
              builderResult.status = value
          }
      }
      public func setStatus(_ value:ConversationStatus) -> UserConversationState.Builder {
        self.status = value
        return self
      }
      public func clearStatus() -> UserConversationState.Builder {
         builderResult.hasStatus = false
         builderResult.status = .ConversationStatusUnknown
         return self
      }
      public var hasNotificationLevel:Bool{
          get {
              return builderResult.hasNotificationLevel
          }
      }
      public var notificationLevel:NotificationLevel {
          get {
              return builderResult.notificationLevel
          }
          set (value) {
              builderResult.hasNotificationLevel = true
              builderResult.notificationLevel = value
          }
      }
      public func setNotificationLevel(_ value:NotificationLevel) -> UserConversationState.Builder {
        self.notificationLevel = value
        return self
      }
      public func clearNotificationLevel() -> UserConversationState.Builder {
         builderResult.hasNotificationLevel = false
         builderResult.notificationLevel = .NotificationLevelUnknown
         return self
      }
    public var view:Array<ConversationView> {
        get {
            return builderResult.view
        }
        set (value) {
            builderResult.view = value
        }
    }
    public func setView(_ value:Array<ConversationView>) -> UserConversationState.Builder {
      self.view = value
      return self
    }
    public func clearView() -> UserConversationState.Builder {
      builderResult.view.removeAll(keepingCapacity: false)
      return self
    }
    public var hasInviterId:Bool {
         get {
             return builderResult.hasInviterId
         }
    }
    public var inviterId:ParticipantId! {
         get {
             if inviterIdBuilder_ != nil {
                builderResult.inviterId = inviterIdBuilder_.getMessage()
             }
             return builderResult.inviterId
         }
         set (value) {
             builderResult.hasInviterId = true
             builderResult.inviterId = value
         }
    }
    private var inviterIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasInviterId = true
         }
    }
    public func getInviterIdBuilder() -> ParticipantId.Builder {
      if inviterIdBuilder_ == nil {
         inviterIdBuilder_ = ParticipantId.Builder()
         builderResult.inviterId = inviterIdBuilder_.getMessage()
         if inviterId != nil {
            try! inviterIdBuilder_.mergeFrom(inviterId)
         }
      }
      return inviterIdBuilder_
    }
    public func setInviterId(_ value:ParticipantId!) -> UserConversationState.Builder {
      self.inviterId = value
      return self
    }
    public func mergeInviterId(_ value:ParticipantId) throws -> UserConversationState.Builder {
      if builderResult.hasInviterId {
        builderResult.inviterId = try ParticipantId.builderWithPrototype(builderResult.inviterId).mergeFrom(value).buildPartial()
      } else {
        builderResult.inviterId = value
      }
      builderResult.hasInviterId = true
      return self
    }
    public func clearInviterId() -> UserConversationState.Builder {
      inviterIdBuilder_ = nil
      builderResult.hasInviterId = false
      builderResult.inviterId = nil
      return self
    }
    public var hasInviteTimestamp:Bool {
         get {
              return builderResult.hasInviteTimestamp
         }
    }
    public var inviteTimestamp:UInt64 {
         get {
              return builderResult.inviteTimestamp
         }
         set (value) {
             builderResult.hasInviteTimestamp = true
             builderResult.inviteTimestamp = value
         }
    }
    public func setInviteTimestamp(_ value:UInt64) -> UserConversationState.Builder {
      self.inviteTimestamp = value
      return self
    }
    public func clearInviteTimestamp() -> UserConversationState.Builder{
         builderResult.hasInviteTimestamp = false
         builderResult.inviteTimestamp = UInt64(0)
         return self
    }
    public var hasSortTimestamp:Bool {
         get {
              return builderResult.hasSortTimestamp
         }
    }
    public var sortTimestamp:UInt64 {
         get {
              return builderResult.sortTimestamp
         }
         set (value) {
             builderResult.hasSortTimestamp = true
             builderResult.sortTimestamp = value
         }
    }
    public func setSortTimestamp(_ value:UInt64) -> UserConversationState.Builder {
      self.sortTimestamp = value
      return self
    }
    public func clearSortTimestamp() -> UserConversationState.Builder{
         builderResult.hasSortTimestamp = false
         builderResult.sortTimestamp = UInt64(0)
         return self
    }
    public var hasActiveTimestamp:Bool {
         get {
              return builderResult.hasActiveTimestamp
         }
    }
    public var activeTimestamp:UInt64 {
         get {
              return builderResult.activeTimestamp
         }
         set (value) {
             builderResult.hasActiveTimestamp = true
             builderResult.activeTimestamp = value
         }
    }
    public func setActiveTimestamp(_ value:UInt64) -> UserConversationState.Builder {
      self.activeTimestamp = value
      return self
    }
    public func clearActiveTimestamp() -> UserConversationState.Builder{
         builderResult.hasActiveTimestamp = false
         builderResult.activeTimestamp = UInt64(0)
         return self
    }
      public var hasInviteAffinity:Bool{
          get {
              return builderResult.hasInviteAffinity
          }
      }
      public var inviteAffinity:InvitationAffinity {
          get {
              return builderResult.inviteAffinity
          }
          set (value) {
              builderResult.hasInviteAffinity = true
              builderResult.inviteAffinity = value
          }
      }
      public func setInviteAffinity(_ value:InvitationAffinity) -> UserConversationState.Builder {
        self.inviteAffinity = value
        return self
      }
      public func clearInviteAffinity() -> UserConversationState.Builder {
         builderResult.hasInviteAffinity = false
         builderResult.inviteAffinity = .InviteAffinityUnknown
         return self
      }
    public var deliveryMediumOption:Array<DeliveryMediumOption> {
         get {
             return builderResult.deliveryMediumOption
         }
         set (value) {
             builderResult.deliveryMediumOption = value
         }
    }
    public func setDeliveryMediumOption(_ value:Array<DeliveryMediumOption>) -> UserConversationState.Builder {
      self.deliveryMediumOption = value
      return self
    }
    public func clearDeliveryMediumOption() -> UserConversationState.Builder {
      builderResult.deliveryMediumOption.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserConversationState.Builder {
      builderResult = UserConversationState()
      return self
    }
    public override func clone() throws -> UserConversationState.Builder {
      return try UserConversationState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserConversationState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserConversationState {
      let returnMe:UserConversationState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:UserConversationState) throws -> UserConversationState.Builder {
      if other == UserConversationState() {
       return self
      }
      if other.hasClientGeneratedId {
           clientGeneratedId = other.clientGeneratedId
      }
      if (other.hasSelfReadState) {
          try mergeSelfReadState(other.selfReadState)
      }
      if other.hasStatus {
           status = other.status
      }
      if other.hasNotificationLevel {
           notificationLevel = other.notificationLevel
      }
      if !other.view.isEmpty {
         builderResult.view += other.view
      }
      if (other.hasInviterId) {
          try mergeInviterId(other.inviterId)
      }
      if other.hasInviteTimestamp {
           inviteTimestamp = other.inviteTimestamp
      }
      if other.hasSortTimestamp {
           sortTimestamp = other.sortTimestamp
      }
      if other.hasActiveTimestamp {
           activeTimestamp = other.activeTimestamp
      }
      if other.hasInviteAffinity {
           inviteAffinity = other.inviteAffinity
      }
      if !other.deliveryMediumOption.isEmpty  {
         builderResult.deliveryMediumOption += other.deliveryMediumOption
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> UserConversationState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserConversationState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 18:
          clientGeneratedId = try input.readString()

        case 58:
          let subBuilder:UserReadState.Builder = UserReadState.Builder()
          if hasSelfReadState {
            try subBuilder.mergeFrom(selfReadState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          selfReadState = subBuilder.buildPartial()

        case 64:
          let valueIntstatus = try input.readEnum()
          if let enumsstatus = ConversationStatus(rawValue:valueIntstatus){
               status = enumsstatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(8, value:Int64(valueIntstatus))
          }

        case 72:
          let valueIntnotificationLevel = try input.readEnum()
          if let enumsnotificationLevel = NotificationLevel(rawValue:valueIntnotificationLevel){
               notificationLevel = enumsnotificationLevel
          } else {
               try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntnotificationLevel))
          }

        case 80:
          let valueIntview = try input.readEnum()
          if let enumsview = ConversationView(rawValue:valueIntview) {
               builderResult.view += [enumsview]
          } else {
               try unknownFieldsBuilder.mergeVarintField(10, value:Int64(valueIntview))
          }

        case 90:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasInviterId {
            try subBuilder.mergeFrom(inviterId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          inviterId = subBuilder.buildPartial()

        case 96:
          inviteTimestamp = try input.readUInt64()

        case 104:
          sortTimestamp = try input.readUInt64()

        case 112:
          activeTimestamp = try input.readUInt64()

        case 120:
          let valueIntinviteAffinity = try input.readEnum()
          if let enumsinviteAffinity = InvitationAffinity(rawValue:valueIntinviteAffinity){
               inviteAffinity = enumsinviteAffinity
          } else {
               try unknownFieldsBuilder.mergeVarintField(15, value:Int64(valueIntinviteAffinity))
          }

        case 138:
          let subBuilder = DeliveryMediumOption.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          deliveryMediumOption += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConversationParticipantData : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:ParticipantId!
  public private(set) var hasId:Bool = false
  public private(set) var fallbackName:String = ""

  public private(set) var hasFallbackName:Bool = false
  public private(set) var invitationStatus:InvitationStatus = InvitationStatus.InvitationStatusUnknown
  public private(set) var hasInvitationStatus:Bool = false
  public private(set) var participantType:ParticipantType = ParticipantType.ParticipantTypeUnknown
  public private(set) var hasParticipantType:Bool = false
  public private(set) var newInvitationStatus:InvitationStatus = InvitationStatus.InvitationStatusUnknown
  public private(set) var hasNewInvitationStatus:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasId {
      try output.writeMessage(1, value:id)
    }
    if hasFallbackName {
      try output.writeString(2, value:fallbackName)
    }
    if hasInvitationStatus {
      try output.writeEnum(3, value:invitationStatus.rawValue)
    }
    if hasParticipantType {
      try output.writeEnum(5, value:participantType.rawValue)
    }
    if hasNewInvitationStatus {
      try output.writeEnum(6, value:newInvitationStatus.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
        if let varSizeid = id?.computeMessageSize(1) {
            serialize_size += varSizeid
        }
    }
    if hasFallbackName {
      serialize_size += fallbackName.computeStringSize(2)
    }
    if (hasInvitationStatus) {
      serialize_size += invitationStatus.rawValue.computeEnumSize(3)
    }
    if (hasParticipantType) {
      serialize_size += participantType.rawValue.computeEnumSize(5)
    }
    if (hasNewInvitationStatus) {
      serialize_size += newInvitationStatus.rawValue.computeEnumSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationParticipantData> {
    var mergedArray = Array<ConversationParticipantData>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationParticipantData? {
    return try ConversationParticipantData.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationParticipantData {
    return try ConversationParticipantData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationParticipantData.Builder {
    return ConversationParticipantData.classBuilder() as! ConversationParticipantData.Builder
  }
  public func getBuilder() -> ConversationParticipantData.Builder {
    return classBuilder() as! ConversationParticipantData.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationParticipantData.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationParticipantData.Builder()
  }
  public func toBuilder() throws -> ConversationParticipantData.Builder {
    return try ConversationParticipantData.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationParticipantData) throws -> ConversationParticipantData.Builder {
    return try ConversationParticipantData.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id {\n"
      if let outDescId = id {
        output += try outDescId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasFallbackName {
      output += "\(indent) fallbackName: \(fallbackName) \n"
    }
    if (hasInvitationStatus) {
      output += "\(indent) invitationStatus: \(invitationStatus.description)\n"
    }
    if (hasParticipantType) {
      output += "\(indent) participantType: \(participantType.description)\n"
    }
    if (hasNewInvitationStatus) {
      output += "\(indent) newInvitationStatus: \(newInvitationStatus.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
              if let hashValueid = id?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueid
              }
          }
          if hasFallbackName {
             hashCode = (hashCode &* 31) &+ fallbackName.hashValue
          }
          if hasInvitationStatus {
             hashCode = (hashCode &* 31) &+ Int(invitationStatus.rawValue)
          }
          if hasParticipantType {
             hashCode = (hashCode &* 31) &+ Int(participantType.rawValue)
          }
          if hasNewInvitationStatus {
             hashCode = (hashCode &* 31) &+ Int(newInvitationStatus.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationParticipantData"
  }
  override public func className() -> String {
      return "ConversationParticipantData"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationParticipantData.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationParticipantData = ConversationParticipantData()
    public func getMessage() -> ConversationParticipantData {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
             return builderResult.hasId
         }
    }
    public var id:ParticipantId! {
         get {
             if idBuilder_ != nil {
                builderResult.id = idBuilder_.getMessage()
             }
             return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    private var idBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasId = true
         }
    }
    public func getIdBuilder() -> ParticipantId.Builder {
      if idBuilder_ == nil {
         idBuilder_ = ParticipantId.Builder()
         builderResult.id = idBuilder_.getMessage()
         if id != nil {
            try! idBuilder_.mergeFrom(id)
         }
      }
      return idBuilder_
    }
    public func setId(_ value:ParticipantId!) -> ConversationParticipantData.Builder {
      self.id = value
      return self
    }
    public func mergeId(_ value:ParticipantId) throws -> ConversationParticipantData.Builder {
      if builderResult.hasId {
        builderResult.id = try ParticipantId.builderWithPrototype(builderResult.id).mergeFrom(value).buildPartial()
      } else {
        builderResult.id = value
      }
      builderResult.hasId = true
      return self
    }
    public func clearId() -> ConversationParticipantData.Builder {
      idBuilder_ = nil
      builderResult.hasId = false
      builderResult.id = nil
      return self
    }
    public var hasFallbackName:Bool {
         get {
              return builderResult.hasFallbackName
         }
    }
    public var fallbackName:String {
         get {
              return builderResult.fallbackName
         }
         set (value) {
             builderResult.hasFallbackName = true
             builderResult.fallbackName = value
         }
    }
    public func setFallbackName(_ value:String) -> ConversationParticipantData.Builder {
      self.fallbackName = value
      return self
    }
    public func clearFallbackName() -> ConversationParticipantData.Builder{
         builderResult.hasFallbackName = false
         builderResult.fallbackName = ""
         return self
    }
      public var hasInvitationStatus:Bool{
          get {
              return builderResult.hasInvitationStatus
          }
      }
      public var invitationStatus:InvitationStatus {
          get {
              return builderResult.invitationStatus
          }
          set (value) {
              builderResult.hasInvitationStatus = true
              builderResult.invitationStatus = value
          }
      }
      public func setInvitationStatus(_ value:InvitationStatus) -> ConversationParticipantData.Builder {
        self.invitationStatus = value
        return self
      }
      public func clearInvitationStatus() -> ConversationParticipantData.Builder {
         builderResult.hasInvitationStatus = false
         builderResult.invitationStatus = .InvitationStatusUnknown
         return self
      }
      public var hasParticipantType:Bool{
          get {
              return builderResult.hasParticipantType
          }
      }
      public var participantType:ParticipantType {
          get {
              return builderResult.participantType
          }
          set (value) {
              builderResult.hasParticipantType = true
              builderResult.participantType = value
          }
      }
      public func setParticipantType(_ value:ParticipantType) -> ConversationParticipantData.Builder {
        self.participantType = value
        return self
      }
      public func clearParticipantType() -> ConversationParticipantData.Builder {
         builderResult.hasParticipantType = false
         builderResult.participantType = .ParticipantTypeUnknown
         return self
      }
      public var hasNewInvitationStatus:Bool{
          get {
              return builderResult.hasNewInvitationStatus
          }
      }
      public var newInvitationStatus:InvitationStatus {
          get {
              return builderResult.newInvitationStatus
          }
          set (value) {
              builderResult.hasNewInvitationStatus = true
              builderResult.newInvitationStatus = value
          }
      }
      public func setNewInvitationStatus(_ value:InvitationStatus) -> ConversationParticipantData.Builder {
        self.newInvitationStatus = value
        return self
      }
      public func clearNewInvitationStatus() -> ConversationParticipantData.Builder {
         builderResult.hasNewInvitationStatus = false
         builderResult.newInvitationStatus = .InvitationStatusUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationParticipantData.Builder {
      builderResult = ConversationParticipantData()
      return self
    }
    public override func clone() throws -> ConversationParticipantData.Builder {
      return try ConversationParticipantData.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationParticipantData {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationParticipantData {
      let returnMe:ConversationParticipantData = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationParticipantData) throws -> ConversationParticipantData.Builder {
      if other == ConversationParticipantData() {
       return self
      }
      if (other.hasId) {
          try mergeId(other.id)
      }
      if other.hasFallbackName {
           fallbackName = other.fallbackName
      }
      if other.hasInvitationStatus {
           invitationStatus = other.invitationStatus
      }
      if other.hasParticipantType {
           participantType = other.participantType
      }
      if other.hasNewInvitationStatus {
           newInvitationStatus = other.newInvitationStatus
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationParticipantData.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationParticipantData.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasId {
            try subBuilder.mergeFrom(id)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          id = subBuilder.buildPartial()

        case 18:
          fallbackName = try input.readString()

        case 24:
          let valueIntinvitationStatus = try input.readEnum()
          if let enumsinvitationStatus = InvitationStatus(rawValue:valueIntinvitationStatus){
               invitationStatus = enumsinvitationStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntinvitationStatus))
          }

        case 40:
          let valueIntparticipantType = try input.readEnum()
          if let enumsparticipantType = ParticipantType(rawValue:valueIntparticipantType){
               participantType = enumsparticipantType
          } else {
               try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntparticipantType))
          }

        case 48:
          let valueIntnewInvitationStatus = try input.readEnum()
          if let enumsnewInvitationStatus = InvitationStatus(rawValue:valueIntnewInvitationStatus){
               newInvitationStatus = enumsnewInvitationStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntnewInvitationStatus))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// A conversation between two or more users.
final public class Conversation : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var types:ConversationType = ConversationType.ConversationTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var selfConversationState:UserConversationState!
  public private(set) var hasSelfConversationState:Bool = false
  public private(set) var readState:Array<UserReadState>  = Array<UserReadState>()
  // True if the conversation has an active Hangout.
  public private(set) var hasActiveHangout:Bool = false

  public private(set) var hasHasActiveHangout:Bool = false
  public private(set) var otrStatus:OffTheRecordStatus = OffTheRecordStatus.OffTheRecordStatusUnknown
  public private(set) var hasOtrStatus:Bool = false
  public private(set) var otrToggle:OffTheRecordToggle = OffTheRecordToggle.OffTheRecordToggleUnknown
  public private(set) var hasOtrToggle:Bool = false
  public private(set) var conversationHistorySupported:Bool = false

  public private(set) var hasConversationHistorySupported:Bool = false
  public private(set) var currentParticipant:Array<ParticipantId>  = Array<ParticipantId>()
  public private(set) var participantData:Array<ConversationParticipantData>  = Array<ConversationParticipantData>()
  private var networkTypeMemoizedSerializedSize:Int32 = 0
  public private(set) var networkType:Array<NetworkType> = Array<NetworkType>()
  public private(set) var forceHistoryState:ForceHistory = ForceHistory.ForceHistoryUnknown
  public private(set) var hasForceHistoryState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasTypes {
      try output.writeEnum(2, value:types.rawValue)
    }
    if hasName {
      try output.writeString(3, value:name)
    }
    if hasSelfConversationState {
      try output.writeMessage(4, value:selfConversationState)
    }
    for oneElementreadState in readState {
        try output.writeMessage(8, value:oneElementreadState)
    }
    if hasHasActiveHangout {
      try output.writeBool(9, value:hasActiveHangout)
    }
    if hasOtrStatus {
      try output.writeEnum(10, value:otrStatus.rawValue)
    }
    if hasOtrToggle {
      try output.writeEnum(11, value:otrToggle.rawValue)
    }
    if hasConversationHistorySupported {
      try output.writeBool(12, value:conversationHistorySupported)
    }
    for oneElementcurrentParticipant in currentParticipant {
        try output.writeMessage(13, value:oneElementcurrentParticipant)
    }
    for oneElementparticipantData in participantData {
        try output.writeMessage(14, value:oneElementparticipantData)
    }
    for oneValueOfnetworkType in networkType {
        try output.writeEnum(18, value:oneValueOfnetworkType.rawValue)
    }
    if hasForceHistoryState {
      try output.writeEnum(19, value:forceHistoryState.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(2)
    }
    if hasName {
      serialize_size += name.computeStringSize(3)
    }
    if hasSelfConversationState {
        if let varSizeselfConversationState = selfConversationState?.computeMessageSize(4) {
            serialize_size += varSizeselfConversationState
        }
    }
    for oneElementreadState in readState {
        serialize_size += oneElementreadState.computeMessageSize(8)
    }
    if hasHasActiveHangout {
      serialize_size += hasActiveHangout.computeBoolSize(9)
    }
    if (hasOtrStatus) {
      serialize_size += otrStatus.rawValue.computeEnumSize(10)
    }
    if (hasOtrToggle) {
      serialize_size += otrToggle.rawValue.computeEnumSize(11)
    }
    if hasConversationHistorySupported {
      serialize_size += conversationHistorySupported.computeBoolSize(12)
    }
    for oneElementcurrentParticipant in currentParticipant {
        serialize_size += oneElementcurrentParticipant.computeMessageSize(13)
    }
    for oneElementparticipantData in participantData {
        serialize_size += oneElementparticipantData.computeMessageSize(14)
    }
    var dataSizenetworkType:Int32 = 0
    for oneValueOfnetworkType in networkType {
        dataSizenetworkType += oneValueOfnetworkType.rawValue.computeEnumSizeNoTag()
    }
    serialize_size += dataSizenetworkType
    serialize_size += (2 * Int32(networkType.count))
    if (hasForceHistoryState) {
      serialize_size += forceHistoryState.rawValue.computeEnumSize(19)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Conversation> {
    var mergedArray = Array<Conversation>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Conversation? {
    return try Conversation.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Conversation {
    return try Conversation.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Conversation {
    return try Conversation.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Conversation {
    return try Conversation.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Conversation {
    return try Conversation.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Conversation {
    return try Conversation.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Conversation {
    return try Conversation.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Conversation.Builder {
    return Conversation.classBuilder() as! Conversation.Builder
  }
  public func getBuilder() -> Conversation.Builder {
    return classBuilder() as! Conversation.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Conversation.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Conversation.Builder()
  }
  public func toBuilder() throws -> Conversation.Builder {
    return try Conversation.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Conversation) throws -> Conversation.Builder {
    return try Conversation.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasSelfConversationState {
      output += "\(indent) selfConversationState {\n"
      if let outDescSelfConversationState = selfConversationState {
        output += try outDescSelfConversationState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var readStateElementIndex:Int = 0
    for oneElementreadState in readState {
        output += "\(indent) readState[\(readStateElementIndex)] {\n"
        output += try oneElementreadState.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        readStateElementIndex += 1
    }
    if hasHasActiveHangout {
      output += "\(indent) hasActiveHangout: \(hasActiveHangout) \n"
    }
    if (hasOtrStatus) {
      output += "\(indent) otrStatus: \(otrStatus.description)\n"
    }
    if (hasOtrToggle) {
      output += "\(indent) otrToggle: \(otrToggle.description)\n"
    }
    if hasConversationHistorySupported {
      output += "\(indent) conversationHistorySupported: \(conversationHistorySupported) \n"
    }
    var currentParticipantElementIndex:Int = 0
    for oneElementcurrentParticipant in currentParticipant {
        output += "\(indent) currentParticipant[\(currentParticipantElementIndex)] {\n"
        output += try oneElementcurrentParticipant.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        currentParticipantElementIndex += 1
    }
    var participantDataElementIndex:Int = 0
    for oneElementparticipantData in participantData {
        output += "\(indent) participantData[\(participantDataElementIndex)] {\n"
        output += try oneElementparticipantData.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        participantDataElementIndex += 1
    }
    var networkTypeElementIndex:Int = 0
    for oneValueOfnetworkType in networkType {
        output += "\(indent) networkType[\(networkTypeElementIndex)]: \(oneValueOfnetworkType.description)\n"
        networkTypeElementIndex += 1
    }
    if (hasForceHistoryState) {
      output += "\(indent) forceHistoryState: \(forceHistoryState.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasSelfConversationState {
              if let hashValueselfConversationState = selfConversationState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueselfConversationState
              }
          }
          for oneElementreadState in readState {
              hashCode = (hashCode &* 31) &+ oneElementreadState.hashValue
          }
          if hasHasActiveHangout {
             hashCode = (hashCode &* 31) &+ hasActiveHangout.hashValue
          }
          if hasOtrStatus {
             hashCode = (hashCode &* 31) &+ Int(otrStatus.rawValue)
          }
          if hasOtrToggle {
             hashCode = (hashCode &* 31) &+ Int(otrToggle.rawValue)
          }
          if hasConversationHistorySupported {
             hashCode = (hashCode &* 31) &+ conversationHistorySupported.hashValue
          }
          for oneElementcurrentParticipant in currentParticipant {
              hashCode = (hashCode &* 31) &+ oneElementcurrentParticipant.hashValue
          }
          for oneElementparticipantData in participantData {
              hashCode = (hashCode &* 31) &+ oneElementparticipantData.hashValue
          }
          for oneValueOfnetworkType in networkType {
              hashCode = (hashCode &* 31) &+ Int(oneValueOfnetworkType.rawValue)
          }
          if hasForceHistoryState {
             hashCode = (hashCode &* 31) &+ Int(forceHistoryState.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Conversation"
  }
  override public func className() -> String {
      return "Conversation"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Conversation.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Conversation = Conversation()
    public func getMessage() -> Conversation {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> Conversation.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> Conversation.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> Conversation.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ConversationType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ConversationType) -> Conversation.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> Conversation.Builder {
         builderResult.hasTypes = false
         builderResult.types = .ConversationTypeUnknown
         return self
      }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> Conversation.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Conversation.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasSelfConversationState:Bool {
         get {
             return builderResult.hasSelfConversationState
         }
    }
    public var selfConversationState:UserConversationState! {
         get {
             if selfConversationStateBuilder_ != nil {
                builderResult.selfConversationState = selfConversationStateBuilder_.getMessage()
             }
             return builderResult.selfConversationState
         }
         set (value) {
             builderResult.hasSelfConversationState = true
             builderResult.selfConversationState = value
         }
    }
    private var selfConversationStateBuilder_:UserConversationState.Builder! {
         didSet {
            builderResult.hasSelfConversationState = true
         }
    }
    public func getSelfConversationStateBuilder() -> UserConversationState.Builder {
      if selfConversationStateBuilder_ == nil {
         selfConversationStateBuilder_ = UserConversationState.Builder()
         builderResult.selfConversationState = selfConversationStateBuilder_.getMessage()
         if selfConversationState != nil {
            try! selfConversationStateBuilder_.mergeFrom(selfConversationState)
         }
      }
      return selfConversationStateBuilder_
    }
    public func setSelfConversationState(_ value:UserConversationState!) -> Conversation.Builder {
      self.selfConversationState = value
      return self
    }
    public func mergeSelfConversationState(_ value:UserConversationState) throws -> Conversation.Builder {
      if builderResult.hasSelfConversationState {
        builderResult.selfConversationState = try UserConversationState.builderWithPrototype(builderResult.selfConversationState).mergeFrom(value).buildPartial()
      } else {
        builderResult.selfConversationState = value
      }
      builderResult.hasSelfConversationState = true
      return self
    }
    public func clearSelfConversationState() -> Conversation.Builder {
      selfConversationStateBuilder_ = nil
      builderResult.hasSelfConversationState = false
      builderResult.selfConversationState = nil
      return self
    }
    public var readState:Array<UserReadState> {
         get {
             return builderResult.readState
         }
         set (value) {
             builderResult.readState = value
         }
    }
    public func setReadState(_ value:Array<UserReadState>) -> Conversation.Builder {
      self.readState = value
      return self
    }
    public func clearReadState() -> Conversation.Builder {
      builderResult.readState.removeAll(keepingCapacity: false)
      return self
    }
    public var hasHasActiveHangout:Bool {
         get {
              return builderResult.hasHasActiveHangout
         }
    }
    public var hasActiveHangout:Bool {
         get {
              return builderResult.hasActiveHangout
         }
         set (value) {
             builderResult.hasHasActiveHangout = true
             builderResult.hasActiveHangout = value
         }
    }
    public func setHasActiveHangout(_ value:Bool) -> Conversation.Builder {
      self.hasActiveHangout = value
      return self
    }
    public func clearHasActiveHangout() -> Conversation.Builder{
         builderResult.hasHasActiveHangout = false
         builderResult.hasActiveHangout = false
         return self
    }
      public var hasOtrStatus:Bool{
          get {
              return builderResult.hasOtrStatus
          }
      }
      public var otrStatus:OffTheRecordStatus {
          get {
              return builderResult.otrStatus
          }
          set (value) {
              builderResult.hasOtrStatus = true
              builderResult.otrStatus = value
          }
      }
      public func setOtrStatus(_ value:OffTheRecordStatus) -> Conversation.Builder {
        self.otrStatus = value
        return self
      }
      public func clearOtrStatus() -> Conversation.Builder {
         builderResult.hasOtrStatus = false
         builderResult.otrStatus = .OffTheRecordStatusUnknown
         return self
      }
      public var hasOtrToggle:Bool{
          get {
              return builderResult.hasOtrToggle
          }
      }
      public var otrToggle:OffTheRecordToggle {
          get {
              return builderResult.otrToggle
          }
          set (value) {
              builderResult.hasOtrToggle = true
              builderResult.otrToggle = value
          }
      }
      public func setOtrToggle(_ value:OffTheRecordToggle) -> Conversation.Builder {
        self.otrToggle = value
        return self
      }
      public func clearOtrToggle() -> Conversation.Builder {
         builderResult.hasOtrToggle = false
         builderResult.otrToggle = .OffTheRecordToggleUnknown
         return self
      }
    public var hasConversationHistorySupported:Bool {
         get {
              return builderResult.hasConversationHistorySupported
         }
    }
    public var conversationHistorySupported:Bool {
         get {
              return builderResult.conversationHistorySupported
         }
         set (value) {
             builderResult.hasConversationHistorySupported = true
             builderResult.conversationHistorySupported = value
         }
    }
    public func setConversationHistorySupported(_ value:Bool) -> Conversation.Builder {
      self.conversationHistorySupported = value
      return self
    }
    public func clearConversationHistorySupported() -> Conversation.Builder{
         builderResult.hasConversationHistorySupported = false
         builderResult.conversationHistorySupported = false
         return self
    }
    public var currentParticipant:Array<ParticipantId> {
         get {
             return builderResult.currentParticipant
         }
         set (value) {
             builderResult.currentParticipant = value
         }
    }
    public func setCurrentParticipant(_ value:Array<ParticipantId>) -> Conversation.Builder {
      self.currentParticipant = value
      return self
    }
    public func clearCurrentParticipant() -> Conversation.Builder {
      builderResult.currentParticipant.removeAll(keepingCapacity: false)
      return self
    }
    public var participantData:Array<ConversationParticipantData> {
         get {
             return builderResult.participantData
         }
         set (value) {
             builderResult.participantData = value
         }
    }
    public func setParticipantData(_ value:Array<ConversationParticipantData>) -> Conversation.Builder {
      self.participantData = value
      return self
    }
    public func clearParticipantData() -> Conversation.Builder {
      builderResult.participantData.removeAll(keepingCapacity: false)
      return self
    }
    public var networkType:Array<NetworkType> {
        get {
            return builderResult.networkType
        }
        set (value) {
            builderResult.networkType = value
        }
    }
    public func setNetworkType(_ value:Array<NetworkType>) -> Conversation.Builder {
      self.networkType = value
      return self
    }
    public func clearNetworkType() -> Conversation.Builder {
      builderResult.networkType.removeAll(keepingCapacity: false)
      return self
    }
      public var hasForceHistoryState:Bool{
          get {
              return builderResult.hasForceHistoryState
          }
      }
      public var forceHistoryState:ForceHistory {
          get {
              return builderResult.forceHistoryState
          }
          set (value) {
              builderResult.hasForceHistoryState = true
              builderResult.forceHistoryState = value
          }
      }
      public func setForceHistoryState(_ value:ForceHistory) -> Conversation.Builder {
        self.forceHistoryState = value
        return self
      }
      public func clearForceHistoryState() -> Conversation.Builder {
         builderResult.hasForceHistoryState = false
         builderResult.forceHistoryState = .ForceHistoryUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Conversation.Builder {
      builderResult = Conversation()
      return self
    }
    public override func clone() throws -> Conversation.Builder {
      return try Conversation.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Conversation {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Conversation {
      let returnMe:Conversation = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Conversation) throws -> Conversation.Builder {
      if other == Conversation() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasName {
           name = other.name
      }
      if (other.hasSelfConversationState) {
          try mergeSelfConversationState(other.selfConversationState)
      }
      if !other.readState.isEmpty  {
         builderResult.readState += other.readState
      }
      if other.hasHasActiveHangout {
           hasActiveHangout = other.hasActiveHangout
      }
      if other.hasOtrStatus {
           otrStatus = other.otrStatus
      }
      if other.hasOtrToggle {
           otrToggle = other.otrToggle
      }
      if other.hasConversationHistorySupported {
           conversationHistorySupported = other.conversationHistorySupported
      }
      if !other.currentParticipant.isEmpty  {
         builderResult.currentParticipant += other.currentParticipant
      }
      if !other.participantData.isEmpty  {
         builderResult.participantData += other.participantData
      }
      if !other.networkType.isEmpty {
         builderResult.networkType += other.networkType
      }
      if other.hasForceHistoryState {
           forceHistoryState = other.forceHistoryState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Conversation.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Conversation.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 16:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ConversationType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueInttypes))
          }

        case 26:
          name = try input.readString()

        case 34:
          let subBuilder:UserConversationState.Builder = UserConversationState.Builder()
          if hasSelfConversationState {
            try subBuilder.mergeFrom(selfConversationState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          selfConversationState = subBuilder.buildPartial()

        case 66:
          let subBuilder = UserReadState.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          readState += [subBuilder.buildPartial()]

        case 72:
          hasActiveHangout = try input.readBool()

        case 80:
          let valueIntotrStatus = try input.readEnum()
          if let enumsotrStatus = OffTheRecordStatus(rawValue:valueIntotrStatus){
               otrStatus = enumsotrStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(10, value:Int64(valueIntotrStatus))
          }

        case 88:
          let valueIntotrToggle = try input.readEnum()
          if let enumsotrToggle = OffTheRecordToggle(rawValue:valueIntotrToggle){
               otrToggle = enumsotrToggle
          } else {
               try unknownFieldsBuilder.mergeVarintField(11, value:Int64(valueIntotrToggle))
          }

        case 96:
          conversationHistorySupported = try input.readBool()

        case 106:
          let subBuilder = ParticipantId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          currentParticipant += [subBuilder.buildPartial()]

        case 114:
          let subBuilder = ConversationParticipantData.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          participantData += [subBuilder.buildPartial()]

        case 144:
          let valueIntnetworkType = try input.readEnum()
          if let enumsnetworkType = NetworkType(rawValue:valueIntnetworkType) {
               builderResult.networkType += [enumsnetworkType]
          } else {
               try unknownFieldsBuilder.mergeVarintField(18, value:Int64(valueIntnetworkType))
          }

        case 152:
          let valueIntforceHistoryState = try input.readEnum()
          if let enumsforceHistoryState = ForceHistory(rawValue:valueIntforceHistoryState){
               forceHistoryState = enumsforceHistoryState
          } else {
               try unknownFieldsBuilder.mergeVarintField(19, value:Int64(valueIntforceHistoryState))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EasterEgg : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var message_:String = ""

  public private(set) var hasMessage_:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMessage_ {
      try output.writeString(1, value:message_)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMessage_ {
      serialize_size += message_.computeStringSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EasterEgg> {
    var mergedArray = Array<EasterEgg>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EasterEgg? {
    return try EasterEgg.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEgg {
    return try EasterEgg.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EasterEgg.Builder {
    return EasterEgg.classBuilder() as! EasterEgg.Builder
  }
  public func getBuilder() -> EasterEgg.Builder {
    return classBuilder() as! EasterEgg.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EasterEgg.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EasterEgg.Builder()
  }
  public func toBuilder() throws -> EasterEgg.Builder {
    return try EasterEgg.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EasterEgg) throws -> EasterEgg.Builder {
    return try EasterEgg.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMessage_ {
      output += "\(indent) message_: \(message_) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMessage_ {
             hashCode = (hashCode &* 31) &+ message_.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EasterEgg"
  }
  override public func className() -> String {
      return "EasterEgg"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EasterEgg.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EasterEgg = EasterEgg()
    public func getMessage() -> EasterEgg {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMessage_:Bool {
         get {
              return builderResult.hasMessage_
         }
    }
    public var message_:String {
         get {
              return builderResult.message_
         }
         set (value) {
             builderResult.hasMessage_ = true
             builderResult.message_ = value
         }
    }
    public func setMessage_(_ value:String) -> EasterEgg.Builder {
      self.message_ = value
      return self
    }
    public func clearMessage_() -> EasterEgg.Builder{
         builderResult.hasMessage_ = false
         builderResult.message_ = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EasterEgg.Builder {
      builderResult = EasterEgg()
      return self
    }
    public override func clone() throws -> EasterEgg.Builder {
      return try EasterEgg.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EasterEgg {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EasterEgg {
      let returnMe:EasterEgg = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EasterEgg) throws -> EasterEgg.Builder {
      if other == EasterEgg() {
       return self
      }
      if other.hasMessage_ {
           message_ = other.message_
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEgg.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEgg.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          message_ = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class BlockStateChange : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var participantId:ParticipantId!
  public private(set) var hasParticipantId:Bool = false
  public private(set) var newBlockState:BlockState = BlockState.BlockStateUnknown
  public private(set) var hasNewBlockState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasParticipantId {
      try output.writeMessage(1, value:participantId)
    }
    if hasNewBlockState {
      try output.writeEnum(2, value:newBlockState.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasParticipantId {
        if let varSizeparticipantId = participantId?.computeMessageSize(1) {
            serialize_size += varSizeparticipantId
        }
    }
    if (hasNewBlockState) {
      serialize_size += newBlockState.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<BlockStateChange> {
    var mergedArray = Array<BlockStateChange>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> BlockStateChange? {
    return try BlockStateChange.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockStateChange {
    return try BlockStateChange.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> BlockStateChange.Builder {
    return BlockStateChange.classBuilder() as! BlockStateChange.Builder
  }
  public func getBuilder() -> BlockStateChange.Builder {
    return classBuilder() as! BlockStateChange.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return BlockStateChange.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return BlockStateChange.Builder()
  }
  public func toBuilder() throws -> BlockStateChange.Builder {
    return try BlockStateChange.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:BlockStateChange) throws -> BlockStateChange.Builder {
    return try BlockStateChange.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasParticipantId {
      output += "\(indent) participantId {\n"
      if let outDescParticipantId = participantId {
        output += try outDescParticipantId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasNewBlockState) {
      output += "\(indent) newBlockState: \(newBlockState.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasParticipantId {
              if let hashValueparticipantId = participantId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueparticipantId
              }
          }
          if hasNewBlockState {
             hashCode = (hashCode &* 31) &+ Int(newBlockState.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BlockStateChange"
  }
  override public func className() -> String {
      return "BlockStateChange"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BlockStateChange.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:BlockStateChange = BlockStateChange()
    public func getMessage() -> BlockStateChange {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasParticipantId:Bool {
         get {
             return builderResult.hasParticipantId
         }
    }
    public var participantId:ParticipantId! {
         get {
             if participantIdBuilder_ != nil {
                builderResult.participantId = participantIdBuilder_.getMessage()
             }
             return builderResult.participantId
         }
         set (value) {
             builderResult.hasParticipantId = true
             builderResult.participantId = value
         }
    }
    private var participantIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasParticipantId = true
         }
    }
    public func getParticipantIdBuilder() -> ParticipantId.Builder {
      if participantIdBuilder_ == nil {
         participantIdBuilder_ = ParticipantId.Builder()
         builderResult.participantId = participantIdBuilder_.getMessage()
         if participantId != nil {
            try! participantIdBuilder_.mergeFrom(participantId)
         }
      }
      return participantIdBuilder_
    }
    public func setParticipantId(_ value:ParticipantId!) -> BlockStateChange.Builder {
      self.participantId = value
      return self
    }
    public func mergeParticipantId(_ value:ParticipantId) throws -> BlockStateChange.Builder {
      if builderResult.hasParticipantId {
        builderResult.participantId = try ParticipantId.builderWithPrototype(builderResult.participantId).mergeFrom(value).buildPartial()
      } else {
        builderResult.participantId = value
      }
      builderResult.hasParticipantId = true
      return self
    }
    public func clearParticipantId() -> BlockStateChange.Builder {
      participantIdBuilder_ = nil
      builderResult.hasParticipantId = false
      builderResult.participantId = nil
      return self
    }
      public var hasNewBlockState:Bool{
          get {
              return builderResult.hasNewBlockState
          }
      }
      public var newBlockState:BlockState {
          get {
              return builderResult.newBlockState
          }
          set (value) {
              builderResult.hasNewBlockState = true
              builderResult.newBlockState = value
          }
      }
      public func setNewBlockState(_ value:BlockState) -> BlockStateChange.Builder {
        self.newBlockState = value
        return self
      }
      public func clearNewBlockState() -> BlockStateChange.Builder {
         builderResult.hasNewBlockState = false
         builderResult.newBlockState = .BlockStateUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> BlockStateChange.Builder {
      builderResult = BlockStateChange()
      return self
    }
    public override func clone() throws -> BlockStateChange.Builder {
      return try BlockStateChange.builderWithPrototype(builderResult)
    }
    public override func build() throws -> BlockStateChange {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> BlockStateChange {
      let returnMe:BlockStateChange = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:BlockStateChange) throws -> BlockStateChange.Builder {
      if other == BlockStateChange() {
       return self
      }
      if (other.hasParticipantId) {
          try mergeParticipantId(other.participantId)
      }
      if other.hasNewBlockState {
           newBlockState = other.newBlockState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> BlockStateChange.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockStateChange.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasParticipantId {
            try subBuilder.mergeFrom(participantId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          participantId = subBuilder.buildPartial()

        case 16:
          let valueIntnewBlockState = try input.readEnum()
          if let enumsnewBlockState = BlockState(rawValue:valueIntnewBlockState){
               newBlockState = enumsnewBlockState
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntnewBlockState))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Photo : GeneratedMessage, GeneratedMessageProtocol {
  // Picasa photo ID.
  public private(set) var photoId:String = ""

  public private(set) var hasPhotoId:Bool = false
  public private(set) var deleteAlbumlessSourcePhoto:Bool = false

  public private(set) var hasDeleteAlbumlessSourcePhoto:Bool = false
  // Optional Picasa user ID needed for photos from other accounts (eg. stickers).
  public private(set) var userId:String = ""

  public private(set) var hasUserId:Bool = false
  // Must be true if user_id is specified.
  public private(set) var isCustomUserId:Bool = false

  public private(set) var hasIsCustomUserId:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasPhotoId {
      try output.writeString(1, value:photoId)
    }
    if hasDeleteAlbumlessSourcePhoto {
      try output.writeBool(2, value:deleteAlbumlessSourcePhoto)
    }
    if hasUserId {
      try output.writeString(3, value:userId)
    }
    if hasIsCustomUserId {
      try output.writeBool(4, value:isCustomUserId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasPhotoId {
      serialize_size += photoId.computeStringSize(1)
    }
    if hasDeleteAlbumlessSourcePhoto {
      serialize_size += deleteAlbumlessSourcePhoto.computeBoolSize(2)
    }
    if hasUserId {
      serialize_size += userId.computeStringSize(3)
    }
    if hasIsCustomUserId {
      serialize_size += isCustomUserId.computeBoolSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Photo> {
    var mergedArray = Array<Photo>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Photo? {
    return try Photo.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Photo {
    return try Photo.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Photo {
    return try Photo.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Photo {
    return try Photo.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Photo {
    return try Photo.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Photo {
    return try Photo.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Photo {
    return try Photo.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Photo.Builder {
    return Photo.classBuilder() as! Photo.Builder
  }
  public func getBuilder() -> Photo.Builder {
    return classBuilder() as! Photo.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Photo.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Photo.Builder()
  }
  public func toBuilder() throws -> Photo.Builder {
    return try Photo.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Photo) throws -> Photo.Builder {
    return try Photo.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasPhotoId {
      output += "\(indent) photoId: \(photoId) \n"
    }
    if hasDeleteAlbumlessSourcePhoto {
      output += "\(indent) deleteAlbumlessSourcePhoto: \(deleteAlbumlessSourcePhoto) \n"
    }
    if hasUserId {
      output += "\(indent) userId: \(userId) \n"
    }
    if hasIsCustomUserId {
      output += "\(indent) isCustomUserId: \(isCustomUserId) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasPhotoId {
             hashCode = (hashCode &* 31) &+ photoId.hashValue
          }
          if hasDeleteAlbumlessSourcePhoto {
             hashCode = (hashCode &* 31) &+ deleteAlbumlessSourcePhoto.hashValue
          }
          if hasUserId {
             hashCode = (hashCode &* 31) &+ userId.hashValue
          }
          if hasIsCustomUserId {
             hashCode = (hashCode &* 31) &+ isCustomUserId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Photo"
  }
  override public func className() -> String {
      return "Photo"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Photo.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Photo = Photo()
    public func getMessage() -> Photo {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasPhotoId:Bool {
         get {
              return builderResult.hasPhotoId
         }
    }
    public var photoId:String {
         get {
              return builderResult.photoId
         }
         set (value) {
             builderResult.hasPhotoId = true
             builderResult.photoId = value
         }
    }
    public func setPhotoId(_ value:String) -> Photo.Builder {
      self.photoId = value
      return self
    }
    public func clearPhotoId() -> Photo.Builder{
         builderResult.hasPhotoId = false
         builderResult.photoId = ""
         return self
    }
    public var hasDeleteAlbumlessSourcePhoto:Bool {
         get {
              return builderResult.hasDeleteAlbumlessSourcePhoto
         }
    }
    public var deleteAlbumlessSourcePhoto:Bool {
         get {
              return builderResult.deleteAlbumlessSourcePhoto
         }
         set (value) {
             builderResult.hasDeleteAlbumlessSourcePhoto = true
             builderResult.deleteAlbumlessSourcePhoto = value
         }
    }
    public func setDeleteAlbumlessSourcePhoto(_ value:Bool) -> Photo.Builder {
      self.deleteAlbumlessSourcePhoto = value
      return self
    }
    public func clearDeleteAlbumlessSourcePhoto() -> Photo.Builder{
         builderResult.hasDeleteAlbumlessSourcePhoto = false
         builderResult.deleteAlbumlessSourcePhoto = false
         return self
    }
    public var hasUserId:Bool {
         get {
              return builderResult.hasUserId
         }
    }
    public var userId:String {
         get {
              return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    public func setUserId(_ value:String) -> Photo.Builder {
      self.userId = value
      return self
    }
    public func clearUserId() -> Photo.Builder{
         builderResult.hasUserId = false
         builderResult.userId = ""
         return self
    }
    public var hasIsCustomUserId:Bool {
         get {
              return builderResult.hasIsCustomUserId
         }
    }
    public var isCustomUserId:Bool {
         get {
              return builderResult.isCustomUserId
         }
         set (value) {
             builderResult.hasIsCustomUserId = true
             builderResult.isCustomUserId = value
         }
    }
    public func setIsCustomUserId(_ value:Bool) -> Photo.Builder {
      self.isCustomUserId = value
      return self
    }
    public func clearIsCustomUserId() -> Photo.Builder{
         builderResult.hasIsCustomUserId = false
         builderResult.isCustomUserId = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Photo.Builder {
      builderResult = Photo()
      return self
    }
    public override func clone() throws -> Photo.Builder {
      return try Photo.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Photo {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Photo {
      let returnMe:Photo = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Photo) throws -> Photo.Builder {
      if other == Photo() {
       return self
      }
      if other.hasPhotoId {
           photoId = other.photoId
      }
      if other.hasDeleteAlbumlessSourcePhoto {
           deleteAlbumlessSourcePhoto = other.deleteAlbumlessSourcePhoto
      }
      if other.hasUserId {
           userId = other.userId
      }
      if other.hasIsCustomUserId {
           isCustomUserId = other.isCustomUserId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Photo.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Photo.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          photoId = try input.readString()

        case 16:
          deleteAlbumlessSourcePhoto = try input.readBool()

        case 26:
          userId = try input.readString()

        case 32:
          isCustomUserId = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ExistingMedia : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var photo:Photo!
  public private(set) var hasPhoto:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasPhoto {
      try output.writeMessage(1, value:photo)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasPhoto {
        if let varSizephoto = photo?.computeMessageSize(1) {
            serialize_size += varSizephoto
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ExistingMedia> {
    var mergedArray = Array<ExistingMedia>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ExistingMedia? {
    return try ExistingMedia.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ExistingMedia {
    return try ExistingMedia.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ExistingMedia.Builder {
    return ExistingMedia.classBuilder() as! ExistingMedia.Builder
  }
  public func getBuilder() -> ExistingMedia.Builder {
    return classBuilder() as! ExistingMedia.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ExistingMedia.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ExistingMedia.Builder()
  }
  public func toBuilder() throws -> ExistingMedia.Builder {
    return try ExistingMedia.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ExistingMedia) throws -> ExistingMedia.Builder {
    return try ExistingMedia.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasPhoto {
      output += "\(indent) photo {\n"
      if let outDescPhoto = photo {
        output += try outDescPhoto.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasPhoto {
              if let hashValuephoto = photo?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuephoto
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ExistingMedia"
  }
  override public func className() -> String {
      return "ExistingMedia"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ExistingMedia.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ExistingMedia = ExistingMedia()
    public func getMessage() -> ExistingMedia {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasPhoto:Bool {
         get {
             return builderResult.hasPhoto
         }
    }
    public var photo:Photo! {
         get {
             if photoBuilder_ != nil {
                builderResult.photo = photoBuilder_.getMessage()
             }
             return builderResult.photo
         }
         set (value) {
             builderResult.hasPhoto = true
             builderResult.photo = value
         }
    }
    private var photoBuilder_:Photo.Builder! {
         didSet {
            builderResult.hasPhoto = true
         }
    }
    public func getPhotoBuilder() -> Photo.Builder {
      if photoBuilder_ == nil {
         photoBuilder_ = Photo.Builder()
         builderResult.photo = photoBuilder_.getMessage()
         if photo != nil {
            try! photoBuilder_.mergeFrom(photo)
         }
      }
      return photoBuilder_
    }
    public func setPhoto(_ value:Photo!) -> ExistingMedia.Builder {
      self.photo = value
      return self
    }
    public func mergePhoto(_ value:Photo) throws -> ExistingMedia.Builder {
      if builderResult.hasPhoto {
        builderResult.photo = try Photo.builderWithPrototype(builderResult.photo).mergeFrom(value).buildPartial()
      } else {
        builderResult.photo = value
      }
      builderResult.hasPhoto = true
      return self
    }
    public func clearPhoto() -> ExistingMedia.Builder {
      photoBuilder_ = nil
      builderResult.hasPhoto = false
      builderResult.photo = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ExistingMedia.Builder {
      builderResult = ExistingMedia()
      return self
    }
    public override func clone() throws -> ExistingMedia.Builder {
      return try ExistingMedia.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ExistingMedia {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ExistingMedia {
      let returnMe:ExistingMedia = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ExistingMedia) throws -> ExistingMedia.Builder {
      if other == ExistingMedia() {
       return self
      }
      if (other.hasPhoto) {
          try mergePhoto(other.photo)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ExistingMedia.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ExistingMedia.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:Photo.Builder = Photo.Builder()
          if hasPhoto {
            try subBuilder.mergeFrom(photo)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          photo = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EventRequestHeader : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var clientGeneratedId:UInt64 = UInt64(0)

  public private(set) var hasClientGeneratedId:Bool = false
  public private(set) var expectedOtr:OffTheRecordStatus = OffTheRecordStatus.OffTheRecordStatusUnknown
  public private(set) var hasExpectedOtr:Bool = false
  public private(set) var deliveryMedium:DeliveryMedium!
  public private(set) var hasDeliveryMedium:Bool = false
  public private(set) var eventType:EventType = EventType.EventTypeUnknown
  public private(set) var hasEventType:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasClientGeneratedId {
      try output.writeUInt64(2, value:clientGeneratedId)
    }
    if hasExpectedOtr {
      try output.writeEnum(3, value:expectedOtr.rawValue)
    }
    if hasDeliveryMedium {
      try output.writeMessage(4, value:deliveryMedium)
    }
    if hasEventType {
      try output.writeEnum(5, value:eventType.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasClientGeneratedId {
      serialize_size += clientGeneratedId.computeUInt64Size(2)
    }
    if (hasExpectedOtr) {
      serialize_size += expectedOtr.rawValue.computeEnumSize(3)
    }
    if hasDeliveryMedium {
        if let varSizedeliveryMedium = deliveryMedium?.computeMessageSize(4) {
            serialize_size += varSizedeliveryMedium
        }
    }
    if (hasEventType) {
      serialize_size += eventType.rawValue.computeEnumSize(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EventRequestHeader> {
    var mergedArray = Array<EventRequestHeader>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EventRequestHeader? {
    return try EventRequestHeader.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventRequestHeader {
    return try EventRequestHeader.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EventRequestHeader.Builder {
    return EventRequestHeader.classBuilder() as! EventRequestHeader.Builder
  }
  public func getBuilder() -> EventRequestHeader.Builder {
    return classBuilder() as! EventRequestHeader.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EventRequestHeader.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EventRequestHeader.Builder()
  }
  public func toBuilder() throws -> EventRequestHeader.Builder {
    return try EventRequestHeader.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EventRequestHeader) throws -> EventRequestHeader.Builder {
    return try EventRequestHeader.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasClientGeneratedId {
      output += "\(indent) clientGeneratedId: \(clientGeneratedId) \n"
    }
    if (hasExpectedOtr) {
      output += "\(indent) expectedOtr: \(expectedOtr.description)\n"
    }
    if hasDeliveryMedium {
      output += "\(indent) deliveryMedium {\n"
      if let outDescDeliveryMedium = deliveryMedium {
        output += try outDescDeliveryMedium.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasEventType) {
      output += "\(indent) eventType: \(eventType.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasClientGeneratedId {
             hashCode = (hashCode &* 31) &+ clientGeneratedId.hashValue
          }
          if hasExpectedOtr {
             hashCode = (hashCode &* 31) &+ Int(expectedOtr.rawValue)
          }
          if hasDeliveryMedium {
              if let hashValuedeliveryMedium = deliveryMedium?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeliveryMedium
              }
          }
          if hasEventType {
             hashCode = (hashCode &* 31) &+ Int(eventType.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EventRequestHeader"
  }
  override public func className() -> String {
      return "EventRequestHeader"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EventRequestHeader.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EventRequestHeader = EventRequestHeader()
    public func getMessage() -> EventRequestHeader {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> EventRequestHeader.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> EventRequestHeader.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> EventRequestHeader.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasClientGeneratedId:Bool {
         get {
              return builderResult.hasClientGeneratedId
         }
    }
    public var clientGeneratedId:UInt64 {
         get {
              return builderResult.clientGeneratedId
         }
         set (value) {
             builderResult.hasClientGeneratedId = true
             builderResult.clientGeneratedId = value
         }
    }
    public func setClientGeneratedId(_ value:UInt64) -> EventRequestHeader.Builder {
      self.clientGeneratedId = value
      return self
    }
    public func clearClientGeneratedId() -> EventRequestHeader.Builder{
         builderResult.hasClientGeneratedId = false
         builderResult.clientGeneratedId = UInt64(0)
         return self
    }
      public var hasExpectedOtr:Bool{
          get {
              return builderResult.hasExpectedOtr
          }
      }
      public var expectedOtr:OffTheRecordStatus {
          get {
              return builderResult.expectedOtr
          }
          set (value) {
              builderResult.hasExpectedOtr = true
              builderResult.expectedOtr = value
          }
      }
      public func setExpectedOtr(_ value:OffTheRecordStatus) -> EventRequestHeader.Builder {
        self.expectedOtr = value
        return self
      }
      public func clearExpectedOtr() -> EventRequestHeader.Builder {
         builderResult.hasExpectedOtr = false
         builderResult.expectedOtr = .OffTheRecordStatusUnknown
         return self
      }
    public var hasDeliveryMedium:Bool {
         get {
             return builderResult.hasDeliveryMedium
         }
    }
    public var deliveryMedium:DeliveryMedium! {
         get {
             if deliveryMediumBuilder_ != nil {
                builderResult.deliveryMedium = deliveryMediumBuilder_.getMessage()
             }
             return builderResult.deliveryMedium
         }
         set (value) {
             builderResult.hasDeliveryMedium = true
             builderResult.deliveryMedium = value
         }
    }
    private var deliveryMediumBuilder_:DeliveryMedium.Builder! {
         didSet {
            builderResult.hasDeliveryMedium = true
         }
    }
    public func getDeliveryMediumBuilder() -> DeliveryMedium.Builder {
      if deliveryMediumBuilder_ == nil {
         deliveryMediumBuilder_ = DeliveryMedium.Builder()
         builderResult.deliveryMedium = deliveryMediumBuilder_.getMessage()
         if deliveryMedium != nil {
            try! deliveryMediumBuilder_.mergeFrom(deliveryMedium)
         }
      }
      return deliveryMediumBuilder_
    }
    public func setDeliveryMedium(_ value:DeliveryMedium!) -> EventRequestHeader.Builder {
      self.deliveryMedium = value
      return self
    }
    public func mergeDeliveryMedium(_ value:DeliveryMedium) throws -> EventRequestHeader.Builder {
      if builderResult.hasDeliveryMedium {
        builderResult.deliveryMedium = try DeliveryMedium.builderWithPrototype(builderResult.deliveryMedium).mergeFrom(value).buildPartial()
      } else {
        builderResult.deliveryMedium = value
      }
      builderResult.hasDeliveryMedium = true
      return self
    }
    public func clearDeliveryMedium() -> EventRequestHeader.Builder {
      deliveryMediumBuilder_ = nil
      builderResult.hasDeliveryMedium = false
      builderResult.deliveryMedium = nil
      return self
    }
      public var hasEventType:Bool{
          get {
              return builderResult.hasEventType
          }
      }
      public var eventType:EventType {
          get {
              return builderResult.eventType
          }
          set (value) {
              builderResult.hasEventType = true
              builderResult.eventType = value
          }
      }
      public func setEventType(_ value:EventType) -> EventRequestHeader.Builder {
        self.eventType = value
        return self
      }
      public func clearEventType() -> EventRequestHeader.Builder {
         builderResult.hasEventType = false
         builderResult.eventType = .EventTypeUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EventRequestHeader.Builder {
      builderResult = EventRequestHeader()
      return self
    }
    public override func clone() throws -> EventRequestHeader.Builder {
      return try EventRequestHeader.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EventRequestHeader {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EventRequestHeader {
      let returnMe:EventRequestHeader = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EventRequestHeader) throws -> EventRequestHeader.Builder {
      if other == EventRequestHeader() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasClientGeneratedId {
           clientGeneratedId = other.clientGeneratedId
      }
      if other.hasExpectedOtr {
           expectedOtr = other.expectedOtr
      }
      if (other.hasDeliveryMedium) {
          try mergeDeliveryMedium(other.deliveryMedium)
      }
      if other.hasEventType {
           eventType = other.eventType
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EventRequestHeader.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventRequestHeader.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 16:
          clientGeneratedId = try input.readUInt64()

        case 24:
          let valueIntexpectedOtr = try input.readEnum()
          if let enumsexpectedOtr = OffTheRecordStatus(rawValue:valueIntexpectedOtr){
               expectedOtr = enumsexpectedOtr
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntexpectedOtr))
          }

        case 34:
          let subBuilder:DeliveryMedium.Builder = DeliveryMedium.Builder()
          if hasDeliveryMedium {
            try subBuilder.mergeFrom(deliveryMedium)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deliveryMedium = subBuilder.buildPartial()

        case 40:
          let valueInteventType = try input.readEnum()
          if let enumseventType = EventType(rawValue:valueInteventType){
               eventType = enumseventType
          } else {
               try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueInteventType))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// The client and device version.
final public class ClientVersion : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var clientId:ClientId = ClientId.ClientIdUnknown
  public private(set) var hasClientId:Bool = false
  public private(set) var buildType:ClientBuildType = ClientBuildType.BuildTypeUnknown
  public private(set) var hasBuildType:Bool = false
  // Client version.
  public private(set) var majorVersion:String = ""

  public private(set) var hasMajorVersion:Bool = false
  // Client version timestamp.
  public private(set) var versionTimestamp:UInt64 = UInt64(0)

  public private(set) var hasVersionTimestamp:Bool = false
  // OS version string (for native apps).
  public private(set) var deviceOsVersion:String = ""

  public private(set) var hasDeviceOsVersion:Bool = false
  // Device hardware name (for native apps).
  public private(set) var deviceHardware:String = ""

  public private(set) var hasDeviceHardware:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasClientId {
      try output.writeEnum(1, value:clientId.rawValue)
    }
    if hasBuildType {
      try output.writeEnum(2, value:buildType.rawValue)
    }
    if hasMajorVersion {
      try output.writeString(3, value:majorVersion)
    }
    if hasVersionTimestamp {
      try output.writeUInt64(4, value:versionTimestamp)
    }
    if hasDeviceOsVersion {
      try output.writeString(5, value:deviceOsVersion)
    }
    if hasDeviceHardware {
      try output.writeString(6, value:deviceHardware)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasClientId) {
      serialize_size += clientId.rawValue.computeEnumSize(1)
    }
    if (hasBuildType) {
      serialize_size += buildType.rawValue.computeEnumSize(2)
    }
    if hasMajorVersion {
      serialize_size += majorVersion.computeStringSize(3)
    }
    if hasVersionTimestamp {
      serialize_size += versionTimestamp.computeUInt64Size(4)
    }
    if hasDeviceOsVersion {
      serialize_size += deviceOsVersion.computeStringSize(5)
    }
    if hasDeviceHardware {
      serialize_size += deviceHardware.computeStringSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ClientVersion> {
    var mergedArray = Array<ClientVersion>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ClientVersion? {
    return try ClientVersion.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientVersion {
    return try ClientVersion.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ClientVersion.Builder {
    return ClientVersion.classBuilder() as! ClientVersion.Builder
  }
  public func getBuilder() -> ClientVersion.Builder {
    return classBuilder() as! ClientVersion.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ClientVersion.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ClientVersion.Builder()
  }
  public func toBuilder() throws -> ClientVersion.Builder {
    return try ClientVersion.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ClientVersion) throws -> ClientVersion.Builder {
    return try ClientVersion.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasClientId) {
      output += "\(indent) clientId: \(clientId.description)\n"
    }
    if (hasBuildType) {
      output += "\(indent) buildType: \(buildType.description)\n"
    }
    if hasMajorVersion {
      output += "\(indent) majorVersion: \(majorVersion) \n"
    }
    if hasVersionTimestamp {
      output += "\(indent) versionTimestamp: \(versionTimestamp) \n"
    }
    if hasDeviceOsVersion {
      output += "\(indent) deviceOsVersion: \(deviceOsVersion) \n"
    }
    if hasDeviceHardware {
      output += "\(indent) deviceHardware: \(deviceHardware) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasClientId {
             hashCode = (hashCode &* 31) &+ Int(clientId.rawValue)
          }
          if hasBuildType {
             hashCode = (hashCode &* 31) &+ Int(buildType.rawValue)
          }
          if hasMajorVersion {
             hashCode = (hashCode &* 31) &+ majorVersion.hashValue
          }
          if hasVersionTimestamp {
             hashCode = (hashCode &* 31) &+ versionTimestamp.hashValue
          }
          if hasDeviceOsVersion {
             hashCode = (hashCode &* 31) &+ deviceOsVersion.hashValue
          }
          if hasDeviceHardware {
             hashCode = (hashCode &* 31) &+ deviceHardware.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ClientVersion"
  }
  override public func className() -> String {
      return "ClientVersion"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ClientVersion.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ClientVersion = ClientVersion()
    public func getMessage() -> ClientVersion {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasClientId:Bool{
          get {
              return builderResult.hasClientId
          }
      }
      public var clientId:ClientId {
          get {
              return builderResult.clientId
          }
          set (value) {
              builderResult.hasClientId = true
              builderResult.clientId = value
          }
      }
      public func setClientId(_ value:ClientId) -> ClientVersion.Builder {
        self.clientId = value
        return self
      }
      public func clearClientId() -> ClientVersion.Builder {
         builderResult.hasClientId = false
         builderResult.clientId = .ClientIdUnknown
         return self
      }
      public var hasBuildType:Bool{
          get {
              return builderResult.hasBuildType
          }
      }
      public var buildType:ClientBuildType {
          get {
              return builderResult.buildType
          }
          set (value) {
              builderResult.hasBuildType = true
              builderResult.buildType = value
          }
      }
      public func setBuildType(_ value:ClientBuildType) -> ClientVersion.Builder {
        self.buildType = value
        return self
      }
      public func clearBuildType() -> ClientVersion.Builder {
         builderResult.hasBuildType = false
         builderResult.buildType = .BuildTypeUnknown
         return self
      }
    public var hasMajorVersion:Bool {
         get {
              return builderResult.hasMajorVersion
         }
    }
    public var majorVersion:String {
         get {
              return builderResult.majorVersion
         }
         set (value) {
             builderResult.hasMajorVersion = true
             builderResult.majorVersion = value
         }
    }
    public func setMajorVersion(_ value:String) -> ClientVersion.Builder {
      self.majorVersion = value
      return self
    }
    public func clearMajorVersion() -> ClientVersion.Builder{
         builderResult.hasMajorVersion = false
         builderResult.majorVersion = ""
         return self
    }
    public var hasVersionTimestamp:Bool {
         get {
              return builderResult.hasVersionTimestamp
         }
    }
    public var versionTimestamp:UInt64 {
         get {
              return builderResult.versionTimestamp
         }
         set (value) {
             builderResult.hasVersionTimestamp = true
             builderResult.versionTimestamp = value
         }
    }
    public func setVersionTimestamp(_ value:UInt64) -> ClientVersion.Builder {
      self.versionTimestamp = value
      return self
    }
    public func clearVersionTimestamp() -> ClientVersion.Builder{
         builderResult.hasVersionTimestamp = false
         builderResult.versionTimestamp = UInt64(0)
         return self
    }
    public var hasDeviceOsVersion:Bool {
         get {
              return builderResult.hasDeviceOsVersion
         }
    }
    public var deviceOsVersion:String {
         get {
              return builderResult.deviceOsVersion
         }
         set (value) {
             builderResult.hasDeviceOsVersion = true
             builderResult.deviceOsVersion = value
         }
    }
    public func setDeviceOsVersion(_ value:String) -> ClientVersion.Builder {
      self.deviceOsVersion = value
      return self
    }
    public func clearDeviceOsVersion() -> ClientVersion.Builder{
         builderResult.hasDeviceOsVersion = false
         builderResult.deviceOsVersion = ""
         return self
    }
    public var hasDeviceHardware:Bool {
         get {
              return builderResult.hasDeviceHardware
         }
    }
    public var deviceHardware:String {
         get {
              return builderResult.deviceHardware
         }
         set (value) {
             builderResult.hasDeviceHardware = true
             builderResult.deviceHardware = value
         }
    }
    public func setDeviceHardware(_ value:String) -> ClientVersion.Builder {
      self.deviceHardware = value
      return self
    }
    public func clearDeviceHardware() -> ClientVersion.Builder{
         builderResult.hasDeviceHardware = false
         builderResult.deviceHardware = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ClientVersion.Builder {
      builderResult = ClientVersion()
      return self
    }
    public override func clone() throws -> ClientVersion.Builder {
      return try ClientVersion.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ClientVersion {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ClientVersion {
      let returnMe:ClientVersion = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ClientVersion) throws -> ClientVersion.Builder {
      if other == ClientVersion() {
       return self
      }
      if other.hasClientId {
           clientId = other.clientId
      }
      if other.hasBuildType {
           buildType = other.buildType
      }
      if other.hasMajorVersion {
           majorVersion = other.majorVersion
      }
      if other.hasVersionTimestamp {
           versionTimestamp = other.versionTimestamp
      }
      if other.hasDeviceOsVersion {
           deviceOsVersion = other.deviceOsVersion
      }
      if other.hasDeviceHardware {
           deviceHardware = other.deviceHardware
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ClientVersion.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ClientVersion.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntclientId = try input.readEnum()
          if let enumsclientId = ClientId(rawValue:valueIntclientId){
               clientId = enumsclientId
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntclientId))
          }

        case 16:
          let valueIntbuildType = try input.readEnum()
          if let enumsbuildType = ClientBuildType(rawValue:valueIntbuildType){
               buildType = enumsbuildType
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntbuildType))
          }

        case 26:
          majorVersion = try input.readString()

        case 32:
          versionTimestamp = try input.readUInt64()

        case 42:
          deviceOsVersion = try input.readString()

        case 50:
          deviceHardware = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Header for requests from the client to the server.
final public class RequestHeader : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var clientVersion:ClientVersion!
  public private(set) var hasClientVersion:Bool = false
  public private(set) var clientIdentifier:ClientIdentifier!
  public private(set) var hasClientIdentifier:Bool = false
  public private(set) var languageCode:String = ""

  public private(set) var hasLanguageCode:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasClientVersion {
      try output.writeMessage(1, value:clientVersion)
    }
    if hasClientIdentifier {
      try output.writeMessage(2, value:clientIdentifier)
    }
    if hasLanguageCode {
      try output.writeString(4, value:languageCode)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasClientVersion {
        if let varSizeclientVersion = clientVersion?.computeMessageSize(1) {
            serialize_size += varSizeclientVersion
        }
    }
    if hasClientIdentifier {
        if let varSizeclientIdentifier = clientIdentifier?.computeMessageSize(2) {
            serialize_size += varSizeclientIdentifier
        }
    }
    if hasLanguageCode {
      serialize_size += languageCode.computeStringSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RequestHeader> {
    var mergedArray = Array<RequestHeader>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RequestHeader? {
    return try RequestHeader.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestHeader {
    return try RequestHeader.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RequestHeader.Builder {
    return RequestHeader.classBuilder() as! RequestHeader.Builder
  }
  public func getBuilder() -> RequestHeader.Builder {
    return classBuilder() as! RequestHeader.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RequestHeader.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RequestHeader.Builder()
  }
  public func toBuilder() throws -> RequestHeader.Builder {
    return try RequestHeader.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RequestHeader) throws -> RequestHeader.Builder {
    return try RequestHeader.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasClientVersion {
      output += "\(indent) clientVersion {\n"
      if let outDescClientVersion = clientVersion {
        output += try outDescClientVersion.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasClientIdentifier {
      output += "\(indent) clientIdentifier {\n"
      if let outDescClientIdentifier = clientIdentifier {
        output += try outDescClientIdentifier.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLanguageCode {
      output += "\(indent) languageCode: \(languageCode) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasClientVersion {
              if let hashValueclientVersion = clientVersion?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueclientVersion
              }
          }
          if hasClientIdentifier {
              if let hashValueclientIdentifier = clientIdentifier?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueclientIdentifier
              }
          }
          if hasLanguageCode {
             hashCode = (hashCode &* 31) &+ languageCode.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RequestHeader"
  }
  override public func className() -> String {
      return "RequestHeader"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RequestHeader.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RequestHeader = RequestHeader()
    public func getMessage() -> RequestHeader {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasClientVersion:Bool {
         get {
             return builderResult.hasClientVersion
         }
    }
    public var clientVersion:ClientVersion! {
         get {
             if clientVersionBuilder_ != nil {
                builderResult.clientVersion = clientVersionBuilder_.getMessage()
             }
             return builderResult.clientVersion
         }
         set (value) {
             builderResult.hasClientVersion = true
             builderResult.clientVersion = value
         }
    }
    private var clientVersionBuilder_:ClientVersion.Builder! {
         didSet {
            builderResult.hasClientVersion = true
         }
    }
    public func getClientVersionBuilder() -> ClientVersion.Builder {
      if clientVersionBuilder_ == nil {
         clientVersionBuilder_ = ClientVersion.Builder()
         builderResult.clientVersion = clientVersionBuilder_.getMessage()
         if clientVersion != nil {
            try! clientVersionBuilder_.mergeFrom(clientVersion)
         }
      }
      return clientVersionBuilder_
    }
    public func setClientVersion(_ value:ClientVersion!) -> RequestHeader.Builder {
      self.clientVersion = value
      return self
    }
    public func mergeClientVersion(_ value:ClientVersion) throws -> RequestHeader.Builder {
      if builderResult.hasClientVersion {
        builderResult.clientVersion = try ClientVersion.builderWithPrototype(builderResult.clientVersion).mergeFrom(value).buildPartial()
      } else {
        builderResult.clientVersion = value
      }
      builderResult.hasClientVersion = true
      return self
    }
    public func clearClientVersion() -> RequestHeader.Builder {
      clientVersionBuilder_ = nil
      builderResult.hasClientVersion = false
      builderResult.clientVersion = nil
      return self
    }
    public var hasClientIdentifier:Bool {
         get {
             return builderResult.hasClientIdentifier
         }
    }
    public var clientIdentifier:ClientIdentifier! {
         get {
             if clientIdentifierBuilder_ != nil {
                builderResult.clientIdentifier = clientIdentifierBuilder_.getMessage()
             }
             return builderResult.clientIdentifier
         }
         set (value) {
             builderResult.hasClientIdentifier = true
             builderResult.clientIdentifier = value
         }
    }
    private var clientIdentifierBuilder_:ClientIdentifier.Builder! {
         didSet {
            builderResult.hasClientIdentifier = true
         }
    }
    public func getClientIdentifierBuilder() -> ClientIdentifier.Builder {
      if clientIdentifierBuilder_ == nil {
         clientIdentifierBuilder_ = ClientIdentifier.Builder()
         builderResult.clientIdentifier = clientIdentifierBuilder_.getMessage()
         if clientIdentifier != nil {
            try! clientIdentifierBuilder_.mergeFrom(clientIdentifier)
         }
      }
      return clientIdentifierBuilder_
    }
    public func setClientIdentifier(_ value:ClientIdentifier!) -> RequestHeader.Builder {
      self.clientIdentifier = value
      return self
    }
    public func mergeClientIdentifier(_ value:ClientIdentifier) throws -> RequestHeader.Builder {
      if builderResult.hasClientIdentifier {
        builderResult.clientIdentifier = try ClientIdentifier.builderWithPrototype(builderResult.clientIdentifier).mergeFrom(value).buildPartial()
      } else {
        builderResult.clientIdentifier = value
      }
      builderResult.hasClientIdentifier = true
      return self
    }
    public func clearClientIdentifier() -> RequestHeader.Builder {
      clientIdentifierBuilder_ = nil
      builderResult.hasClientIdentifier = false
      builderResult.clientIdentifier = nil
      return self
    }
    public var hasLanguageCode:Bool {
         get {
              return builderResult.hasLanguageCode
         }
    }
    public var languageCode:String {
         get {
              return builderResult.languageCode
         }
         set (value) {
             builderResult.hasLanguageCode = true
             builderResult.languageCode = value
         }
    }
    public func setLanguageCode(_ value:String) -> RequestHeader.Builder {
      self.languageCode = value
      return self
    }
    public func clearLanguageCode() -> RequestHeader.Builder{
         builderResult.hasLanguageCode = false
         builderResult.languageCode = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RequestHeader.Builder {
      builderResult = RequestHeader()
      return self
    }
    public override func clone() throws -> RequestHeader.Builder {
      return try RequestHeader.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RequestHeader {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RequestHeader {
      let returnMe:RequestHeader = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RequestHeader) throws -> RequestHeader.Builder {
      if other == RequestHeader() {
       return self
      }
      if (other.hasClientVersion) {
          try mergeClientVersion(other.clientVersion)
      }
      if (other.hasClientIdentifier) {
          try mergeClientIdentifier(other.clientIdentifier)
      }
      if other.hasLanguageCode {
           languageCode = other.languageCode
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RequestHeader.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestHeader.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ClientVersion.Builder = ClientVersion.Builder()
          if hasClientVersion {
            try subBuilder.mergeFrom(clientVersion)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          clientVersion = subBuilder.buildPartial()

        case 18:
          let subBuilder:ClientIdentifier.Builder = ClientIdentifier.Builder()
          if hasClientIdentifier {
            try subBuilder.mergeFrom(clientIdentifier)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          clientIdentifier = subBuilder.buildPartial()

        case 34:
          languageCode = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Header for responses from the server to the client.
final public class ResponseHeader : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:ResponseStatus = ResponseStatus.ResponseStatusUnknown
  public private(set) var hasStatus:Bool = false
  public private(set) var errorDescription:String = ""

  public private(set) var hasErrorDescription:Bool = false
  public private(set) var debugUrl:String = ""

  public private(set) var hasDebugUrl:Bool = false
  public private(set) var requestTraceId:String = ""

  public private(set) var hasRequestTraceId:Bool = false
  public private(set) var currentServerTime:UInt64 = UInt64(0)

  public private(set) var hasCurrentServerTime:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeEnum(1, value:status.rawValue)
    }
    if hasErrorDescription {
      try output.writeString(2, value:errorDescription)
    }
    if hasDebugUrl {
      try output.writeString(3, value:debugUrl)
    }
    if hasRequestTraceId {
      try output.writeString(4, value:requestTraceId)
    }
    if hasCurrentServerTime {
      try output.writeUInt64(5, value:currentServerTime)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasStatus) {
      serialize_size += status.rawValue.computeEnumSize(1)
    }
    if hasErrorDescription {
      serialize_size += errorDescription.computeStringSize(2)
    }
    if hasDebugUrl {
      serialize_size += debugUrl.computeStringSize(3)
    }
    if hasRequestTraceId {
      serialize_size += requestTraceId.computeStringSize(4)
    }
    if hasCurrentServerTime {
      serialize_size += currentServerTime.computeUInt64Size(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ResponseHeader> {
    var mergedArray = Array<ResponseHeader>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ResponseHeader? {
    return try ResponseHeader.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseHeader {
    return try ResponseHeader.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ResponseHeader.Builder {
    return ResponseHeader.classBuilder() as! ResponseHeader.Builder
  }
  public func getBuilder() -> ResponseHeader.Builder {
    return classBuilder() as! ResponseHeader.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ResponseHeader.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ResponseHeader.Builder()
  }
  public func toBuilder() throws -> ResponseHeader.Builder {
    return try ResponseHeader.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ResponseHeader) throws -> ResponseHeader.Builder {
    return try ResponseHeader.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasStatus) {
      output += "\(indent) status: \(status.description)\n"
    }
    if hasErrorDescription {
      output += "\(indent) errorDescription: \(errorDescription) \n"
    }
    if hasDebugUrl {
      output += "\(indent) debugUrl: \(debugUrl) \n"
    }
    if hasRequestTraceId {
      output += "\(indent) requestTraceId: \(requestTraceId) \n"
    }
    if hasCurrentServerTime {
      output += "\(indent) currentServerTime: \(currentServerTime) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
             hashCode = (hashCode &* 31) &+ Int(status.rawValue)
          }
          if hasErrorDescription {
             hashCode = (hashCode &* 31) &+ errorDescription.hashValue
          }
          if hasDebugUrl {
             hashCode = (hashCode &* 31) &+ debugUrl.hashValue
          }
          if hasRequestTraceId {
             hashCode = (hashCode &* 31) &+ requestTraceId.hashValue
          }
          if hasCurrentServerTime {
             hashCode = (hashCode &* 31) &+ currentServerTime.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ResponseHeader"
  }
  override public func className() -> String {
      return "ResponseHeader"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ResponseHeader.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ResponseHeader = ResponseHeader()
    public func getMessage() -> ResponseHeader {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasStatus:Bool{
          get {
              return builderResult.hasStatus
          }
      }
      public var status:ResponseStatus {
          get {
              return builderResult.status
          }
          set (value) {
              builderResult.hasStatus = true
              builderResult.status = value
          }
      }
      public func setStatus(_ value:ResponseStatus) -> ResponseHeader.Builder {
        self.status = value
        return self
      }
      public func clearStatus() -> ResponseHeader.Builder {
         builderResult.hasStatus = false
         builderResult.status = .ResponseStatusUnknown
         return self
      }
    public var hasErrorDescription:Bool {
         get {
              return builderResult.hasErrorDescription
         }
    }
    public var errorDescription:String {
         get {
              return builderResult.errorDescription
         }
         set (value) {
             builderResult.hasErrorDescription = true
             builderResult.errorDescription = value
         }
    }
    public func setErrorDescription(_ value:String) -> ResponseHeader.Builder {
      self.errorDescription = value
      return self
    }
    public func clearErrorDescription() -> ResponseHeader.Builder{
         builderResult.hasErrorDescription = false
         builderResult.errorDescription = ""
         return self
    }
    public var hasDebugUrl:Bool {
         get {
              return builderResult.hasDebugUrl
         }
    }
    public var debugUrl:String {
         get {
              return builderResult.debugUrl
         }
         set (value) {
             builderResult.hasDebugUrl = true
             builderResult.debugUrl = value
         }
    }
    public func setDebugUrl(_ value:String) -> ResponseHeader.Builder {
      self.debugUrl = value
      return self
    }
    public func clearDebugUrl() -> ResponseHeader.Builder{
         builderResult.hasDebugUrl = false
         builderResult.debugUrl = ""
         return self
    }
    public var hasRequestTraceId:Bool {
         get {
              return builderResult.hasRequestTraceId
         }
    }
    public var requestTraceId:String {
         get {
              return builderResult.requestTraceId
         }
         set (value) {
             builderResult.hasRequestTraceId = true
             builderResult.requestTraceId = value
         }
    }
    public func setRequestTraceId(_ value:String) -> ResponseHeader.Builder {
      self.requestTraceId = value
      return self
    }
    public func clearRequestTraceId() -> ResponseHeader.Builder{
         builderResult.hasRequestTraceId = false
         builderResult.requestTraceId = ""
         return self
    }
    public var hasCurrentServerTime:Bool {
         get {
              return builderResult.hasCurrentServerTime
         }
    }
    public var currentServerTime:UInt64 {
         get {
              return builderResult.currentServerTime
         }
         set (value) {
             builderResult.hasCurrentServerTime = true
             builderResult.currentServerTime = value
         }
    }
    public func setCurrentServerTime(_ value:UInt64) -> ResponseHeader.Builder {
      self.currentServerTime = value
      return self
    }
    public func clearCurrentServerTime() -> ResponseHeader.Builder{
         builderResult.hasCurrentServerTime = false
         builderResult.currentServerTime = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ResponseHeader.Builder {
      builderResult = ResponseHeader()
      return self
    }
    public override func clone() throws -> ResponseHeader.Builder {
      return try ResponseHeader.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ResponseHeader {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ResponseHeader {
      let returnMe:ResponseHeader = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ResponseHeader) throws -> ResponseHeader.Builder {
      if other == ResponseHeader() {
       return self
      }
      if other.hasStatus {
           status = other.status
      }
      if other.hasErrorDescription {
           errorDescription = other.errorDescription
      }
      if other.hasDebugUrl {
           debugUrl = other.debugUrl
      }
      if other.hasRequestTraceId {
           requestTraceId = other.requestTraceId
      }
      if other.hasCurrentServerTime {
           currentServerTime = other.currentServerTime
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ResponseHeader.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseHeader.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntstatus = try input.readEnum()
          if let enumsstatus = ResponseStatus(rawValue:valueIntstatus){
               status = enumsstatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
          }

        case 18:
          errorDescription = try input.readString()

        case 26:
          debugUrl = try input.readString()

        case 34:
          requestTraceId = try input.readString()

        case 40:
          currentServerTime = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// A user that can participate in conversations.
final public class Entity : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum PastHangoutState:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case PastHangoutStateUnknown = 0
      case PastHangoutStateHadPastHangout = 1
      case PastHangoutStateNoPastHangout = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .PastHangoutStateUnknown: return ".PastHangoutStateUnknown"
              case .PastHangoutStateHadPastHangout: return ".PastHangoutStateHadPastHangout"
              case .PastHangoutStateNoPastHangout: return ".PastHangoutStateNoPastHangout"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var id:ParticipantId!
  public private(set) var hasId:Bool = false
  public private(set) var presence:Presence!
  public private(set) var hasPresence:Bool = false
  public private(set) var properties:EntityProperties!
  public private(set) var hasProperties:Bool = false
  public private(set) var entityType:ParticipantType = ParticipantType.ParticipantTypeUnknown
  public private(set) var hasEntityType:Bool = false
  public private(set) var hadPastHangoutState = Entity.PastHangoutState.PastHangoutStateUnknown
  public private(set) var hasHadPastHangoutState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasPresence {
     if !presence.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasPresence {
      try output.writeMessage(8, value:presence)
    }
    if hasId {
      try output.writeMessage(9, value:id)
    }
    if hasProperties {
      try output.writeMessage(10, value:properties)
    }
    if hasEntityType {
      try output.writeEnum(13, value:entityType.rawValue)
    }
    if hasHadPastHangoutState {
      try output.writeEnum(16, value:hadPastHangoutState.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasPresence {
        if let varSizepresence = presence?.computeMessageSize(8) {
            serialize_size += varSizepresence
        }
    }
    if hasId {
        if let varSizeid = id?.computeMessageSize(9) {
            serialize_size += varSizeid
        }
    }
    if hasProperties {
        if let varSizeproperties = properties?.computeMessageSize(10) {
            serialize_size += varSizeproperties
        }
    }
    if (hasEntityType) {
      serialize_size += entityType.rawValue.computeEnumSize(13)
    }
    if (hasHadPastHangoutState) {
      serialize_size += hadPastHangoutState.rawValue.computeEnumSize(16)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Entity> {
    var mergedArray = Array<Entity>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Entity? {
    return try Entity.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Entity {
    return try Entity.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Entity {
    return try Entity.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Entity {
    return try Entity.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Entity {
    return try Entity.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Entity {
    return try Entity.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Entity {
    return try Entity.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Entity.Builder {
    return Entity.classBuilder() as! Entity.Builder
  }
  public func getBuilder() -> Entity.Builder {
    return classBuilder() as! Entity.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Entity.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Entity.Builder()
  }
  public func toBuilder() throws -> Entity.Builder {
    return try Entity.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Entity) throws -> Entity.Builder {
    return try Entity.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasPresence {
      output += "\(indent) presence {\n"
      if let outDescPresence = presence {
        output += try outDescPresence.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasId {
      output += "\(indent) id {\n"
      if let outDescId = id {
        output += try outDescId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasProperties {
      output += "\(indent) properties {\n"
      if let outDescProperties = properties {
        output += try outDescProperties.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasEntityType) {
      output += "\(indent) entityType: \(entityType.description)\n"
    }
    if (hasHadPastHangoutState) {
      output += "\(indent) hadPastHangoutState: \(hadPastHangoutState.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasPresence {
              if let hashValuepresence = presence?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepresence
              }
          }
          if hasId {
              if let hashValueid = id?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueid
              }
          }
          if hasProperties {
              if let hashValueproperties = properties?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueproperties
              }
          }
          if hasEntityType {
             hashCode = (hashCode &* 31) &+ Int(entityType.rawValue)
          }
          if hasHadPastHangoutState {
             hashCode = (hashCode &* 31) &+ Int(hadPastHangoutState.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Entity"
  }
  override public func className() -> String {
      return "Entity"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Entity.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Entity = Entity()
    public func getMessage() -> Entity {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
             return builderResult.hasId
         }
    }
    public var id:ParticipantId! {
         get {
             if idBuilder_ != nil {
                builderResult.id = idBuilder_.getMessage()
             }
             return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    private var idBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasId = true
         }
    }
    public func getIdBuilder() -> ParticipantId.Builder {
      if idBuilder_ == nil {
         idBuilder_ = ParticipantId.Builder()
         builderResult.id = idBuilder_.getMessage()
         if id != nil {
            try! idBuilder_.mergeFrom(id)
         }
      }
      return idBuilder_
    }
    public func setId(_ value:ParticipantId!) -> Entity.Builder {
      self.id = value
      return self
    }
    public func mergeId(_ value:ParticipantId) throws -> Entity.Builder {
      if builderResult.hasId {
        builderResult.id = try ParticipantId.builderWithPrototype(builderResult.id).mergeFrom(value).buildPartial()
      } else {
        builderResult.id = value
      }
      builderResult.hasId = true
      return self
    }
    public func clearId() -> Entity.Builder {
      idBuilder_ = nil
      builderResult.hasId = false
      builderResult.id = nil
      return self
    }
    public var hasPresence:Bool {
         get {
             return builderResult.hasPresence
         }
    }
    public var presence:Presence! {
         get {
             if presenceBuilder_ != nil {
                builderResult.presence = presenceBuilder_.getMessage()
             }
             return builderResult.presence
         }
         set (value) {
             builderResult.hasPresence = true
             builderResult.presence = value
         }
    }
    private var presenceBuilder_:Presence.Builder! {
         didSet {
            builderResult.hasPresence = true
         }
    }
    public func getPresenceBuilder() -> Presence.Builder {
      if presenceBuilder_ == nil {
         presenceBuilder_ = Presence.Builder()
         builderResult.presence = presenceBuilder_.getMessage()
         if presence != nil {
            try! presenceBuilder_.mergeFrom(presence)
         }
      }
      return presenceBuilder_
    }
    public func setPresence(_ value:Presence!) -> Entity.Builder {
      self.presence = value
      return self
    }
    public func mergePresence(_ value:Presence) throws -> Entity.Builder {
      if builderResult.hasPresence {
        builderResult.presence = try Presence.builderWithPrototype(builderResult.presence).mergeFrom(value).buildPartial()
      } else {
        builderResult.presence = value
      }
      builderResult.hasPresence = true
      return self
    }
    public func clearPresence() -> Entity.Builder {
      presenceBuilder_ = nil
      builderResult.hasPresence = false
      builderResult.presence = nil
      return self
    }
    public var hasProperties:Bool {
         get {
             return builderResult.hasProperties
         }
    }
    public var properties:EntityProperties! {
         get {
             if propertiesBuilder_ != nil {
                builderResult.properties = propertiesBuilder_.getMessage()
             }
             return builderResult.properties
         }
         set (value) {
             builderResult.hasProperties = true
             builderResult.properties = value
         }
    }
    private var propertiesBuilder_:EntityProperties.Builder! {
         didSet {
            builderResult.hasProperties = true
         }
    }
    public func getPropertiesBuilder() -> EntityProperties.Builder {
      if propertiesBuilder_ == nil {
         propertiesBuilder_ = EntityProperties.Builder()
         builderResult.properties = propertiesBuilder_.getMessage()
         if properties != nil {
            try! propertiesBuilder_.mergeFrom(properties)
         }
      }
      return propertiesBuilder_
    }
    public func setProperties(_ value:EntityProperties!) -> Entity.Builder {
      self.properties = value
      return self
    }
    public func mergeProperties(_ value:EntityProperties) throws -> Entity.Builder {
      if builderResult.hasProperties {
        builderResult.properties = try EntityProperties.builderWithPrototype(builderResult.properties).mergeFrom(value).buildPartial()
      } else {
        builderResult.properties = value
      }
      builderResult.hasProperties = true
      return self
    }
    public func clearProperties() -> Entity.Builder {
      propertiesBuilder_ = nil
      builderResult.hasProperties = false
      builderResult.properties = nil
      return self
    }
      public var hasEntityType:Bool{
          get {
              return builderResult.hasEntityType
          }
      }
      public var entityType:ParticipantType {
          get {
              return builderResult.entityType
          }
          set (value) {
              builderResult.hasEntityType = true
              builderResult.entityType = value
          }
      }
      public func setEntityType(_ value:ParticipantType) -> Entity.Builder {
        self.entityType = value
        return self
      }
      public func clearEntityType() -> Entity.Builder {
         builderResult.hasEntityType = false
         builderResult.entityType = .ParticipantTypeUnknown
         return self
      }
      public var hasHadPastHangoutState:Bool{
          get {
              return builderResult.hasHadPastHangoutState
          }
      }
      public var hadPastHangoutState:Entity.PastHangoutState {
          get {
              return builderResult.hadPastHangoutState
          }
          set (value) {
              builderResult.hasHadPastHangoutState = true
              builderResult.hadPastHangoutState = value
          }
      }
      public func setHadPastHangoutState(_ value:Entity.PastHangoutState) -> Entity.Builder {
        self.hadPastHangoutState = value
        return self
      }
      public func clearHadPastHangoutState() -> Entity.Builder {
         builderResult.hasHadPastHangoutState = false
         builderResult.hadPastHangoutState = .PastHangoutStateUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Entity.Builder {
      builderResult = Entity()
      return self
    }
    public override func clone() throws -> Entity.Builder {
      return try Entity.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Entity {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Entity {
      let returnMe:Entity = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Entity) throws -> Entity.Builder {
      if other == Entity() {
       return self
      }
      if (other.hasId) {
          try mergeId(other.id)
      }
      if (other.hasPresence) {
          try mergePresence(other.presence)
      }
      if (other.hasProperties) {
          try mergeProperties(other.properties)
      }
      if other.hasEntityType {
           entityType = other.entityType
      }
      if other.hasHadPastHangoutState {
           hadPastHangoutState = other.hadPastHangoutState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Entity.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Entity.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 66:
          let subBuilder:Presence.Builder = Presence.Builder()
          if hasPresence {
            try subBuilder.mergeFrom(presence)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          presence = subBuilder.buildPartial()

        case 74:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasId {
            try subBuilder.mergeFrom(id)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          id = subBuilder.buildPartial()

        case 82:
          let subBuilder:EntityProperties.Builder = EntityProperties.Builder()
          if hasProperties {
            try subBuilder.mergeFrom(properties)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          properties = subBuilder.buildPartial()

        case 104:
          let valueIntentityType = try input.readEnum()
          if let enumsentityType = ParticipantType(rawValue:valueIntentityType){
               entityType = enumsentityType
          } else {
               try unknownFieldsBuilder.mergeVarintField(13, value:Int64(valueIntentityType))
          }

        case 128:
          let valueInthadPastHangoutState = try input.readEnum()
          if let enumshadPastHangoutState = Entity.PastHangoutState(rawValue:valueInthadPastHangoutState){
               hadPastHangoutState = enumshadPastHangoutState
          } else {
               try unknownFieldsBuilder.mergeVarintField(16, value:Int64(valueInthadPastHangoutState))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EntityProperties : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var types:ProfileType = ProfileType.ProfileTypeNone
  public private(set) var hasTypes:Bool = false
  public private(set) var displayName:String = ""

  public private(set) var hasDisplayName:Bool = false
  public private(set) var firstName:String = ""

  public private(set) var hasFirstName:Bool = false
  // Photo URL with protocol scheme omitted (eg.
  // "//lh.googleusercontent.com/...").
  public private(set) var photoUrl:String = ""

  public private(set) var hasPhotoUrl:Bool = false
  public private(set) var email:Array<String> = Array<String>()
  public private(set) var phone:Array<String> = Array<String>()
  public private(set) var inUsersDomain:Bool = false

  public private(set) var hasInUsersDomain:Bool = false
  public private(set) var gender:Gender = Gender.GenderUnknown
  public private(set) var hasGender:Bool = false
  public private(set) var photoUrlStatus:PhotoUrlStatus = PhotoUrlStatus.PhotoUrlStatusUnknown
  public private(set) var hasPhotoUrlStatus:Bool = false
  public private(set) var canonicalEmail:String = ""

  public private(set) var hasCanonicalEmail:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    if hasDisplayName {
      try output.writeString(2, value:displayName)
    }
    if hasFirstName {
      try output.writeString(3, value:firstName)
    }
    if hasPhotoUrl {
      try output.writeString(4, value:photoUrl)
    }
    if !email.isEmpty {
      for oneValueemail in email {
        try output.writeString(5, value:oneValueemail)
      }
    }
    if !phone.isEmpty {
      for oneValuephone in phone {
        try output.writeString(6, value:oneValuephone)
      }
    }
    if hasInUsersDomain {
      try output.writeBool(10, value:inUsersDomain)
    }
    if hasGender {
      try output.writeEnum(11, value:gender.rawValue)
    }
    if hasPhotoUrlStatus {
      try output.writeEnum(12, value:photoUrlStatus.rawValue)
    }
    if hasCanonicalEmail {
      try output.writeString(15, value:canonicalEmail)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    if hasDisplayName {
      serialize_size += displayName.computeStringSize(2)
    }
    if hasFirstName {
      serialize_size += firstName.computeStringSize(3)
    }
    if hasPhotoUrl {
      serialize_size += photoUrl.computeStringSize(4)
    }
    var dataSizeEmail:Int32 = 0
    for oneValueemail in email {
        dataSizeEmail += oneValueemail.computeStringSizeNoTag()
    }
    serialize_size += dataSizeEmail
    serialize_size += 1 * Int32(email.count)
    var dataSizePhone:Int32 = 0
    for oneValuephone in phone {
        dataSizePhone += oneValuephone.computeStringSizeNoTag()
    }
    serialize_size += dataSizePhone
    serialize_size += 1 * Int32(phone.count)
    if hasInUsersDomain {
      serialize_size += inUsersDomain.computeBoolSize(10)
    }
    if (hasGender) {
      serialize_size += gender.rawValue.computeEnumSize(11)
    }
    if (hasPhotoUrlStatus) {
      serialize_size += photoUrlStatus.rawValue.computeEnumSize(12)
    }
    if hasCanonicalEmail {
      serialize_size += canonicalEmail.computeStringSize(15)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EntityProperties> {
    var mergedArray = Array<EntityProperties>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EntityProperties? {
    return try EntityProperties.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityProperties {
    return try EntityProperties.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EntityProperties.Builder {
    return EntityProperties.classBuilder() as! EntityProperties.Builder
  }
  public func getBuilder() -> EntityProperties.Builder {
    return classBuilder() as! EntityProperties.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EntityProperties.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EntityProperties.Builder()
  }
  public func toBuilder() throws -> EntityProperties.Builder {
    return try EntityProperties.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EntityProperties) throws -> EntityProperties.Builder {
    return try EntityProperties.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasDisplayName {
      output += "\(indent) displayName: \(displayName) \n"
    }
    if hasFirstName {
      output += "\(indent) firstName: \(firstName) \n"
    }
    if hasPhotoUrl {
      output += "\(indent) photoUrl: \(photoUrl) \n"
    }
    var emailElementIndex:Int = 0
    for oneValueemail in email  {
        output += "\(indent) email[\(emailElementIndex)]: \(oneValueemail)\n"
        emailElementIndex += 1
    }
    var phoneElementIndex:Int = 0
    for oneValuephone in phone  {
        output += "\(indent) phone[\(phoneElementIndex)]: \(oneValuephone)\n"
        phoneElementIndex += 1
    }
    if hasInUsersDomain {
      output += "\(indent) inUsersDomain: \(inUsersDomain) \n"
    }
    if (hasGender) {
      output += "\(indent) gender: \(gender.description)\n"
    }
    if (hasPhotoUrlStatus) {
      output += "\(indent) photoUrlStatus: \(photoUrlStatus.description)\n"
    }
    if hasCanonicalEmail {
      output += "\(indent) canonicalEmail: \(canonicalEmail) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasDisplayName {
             hashCode = (hashCode &* 31) &+ displayName.hashValue
          }
          if hasFirstName {
             hashCode = (hashCode &* 31) &+ firstName.hashValue
          }
          if hasPhotoUrl {
             hashCode = (hashCode &* 31) &+ photoUrl.hashValue
          }
          for oneValueemail in email {
              hashCode = (hashCode &* 31) &+ oneValueemail.hashValue
          }
          for oneValuephone in phone {
              hashCode = (hashCode &* 31) &+ oneValuephone.hashValue
          }
          if hasInUsersDomain {
             hashCode = (hashCode &* 31) &+ inUsersDomain.hashValue
          }
          if hasGender {
             hashCode = (hashCode &* 31) &+ Int(gender.rawValue)
          }
          if hasPhotoUrlStatus {
             hashCode = (hashCode &* 31) &+ Int(photoUrlStatus.rawValue)
          }
          if hasCanonicalEmail {
             hashCode = (hashCode &* 31) &+ canonicalEmail.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EntityProperties"
  }
  override public func className() -> String {
      return "EntityProperties"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EntityProperties.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EntityProperties = EntityProperties()
    public func getMessage() -> EntityProperties {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ProfileType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ProfileType) -> EntityProperties.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> EntityProperties.Builder {
         builderResult.hasTypes = false
         builderResult.types = .ProfileTypeNone
         return self
      }
    public var hasDisplayName:Bool {
         get {
              return builderResult.hasDisplayName
         }
    }
    public var displayName:String {
         get {
              return builderResult.displayName
         }
         set (value) {
             builderResult.hasDisplayName = true
             builderResult.displayName = value
         }
    }
    public func setDisplayName(_ value:String) -> EntityProperties.Builder {
      self.displayName = value
      return self
    }
    public func clearDisplayName() -> EntityProperties.Builder{
         builderResult.hasDisplayName = false
         builderResult.displayName = ""
         return self
    }
    public var hasFirstName:Bool {
         get {
              return builderResult.hasFirstName
         }
    }
    public var firstName:String {
         get {
              return builderResult.firstName
         }
         set (value) {
             builderResult.hasFirstName = true
             builderResult.firstName = value
         }
    }
    public func setFirstName(_ value:String) -> EntityProperties.Builder {
      self.firstName = value
      return self
    }
    public func clearFirstName() -> EntityProperties.Builder{
         builderResult.hasFirstName = false
         builderResult.firstName = ""
         return self
    }
    public var hasPhotoUrl:Bool {
         get {
              return builderResult.hasPhotoUrl
         }
    }
    public var photoUrl:String {
         get {
              return builderResult.photoUrl
         }
         set (value) {
             builderResult.hasPhotoUrl = true
             builderResult.photoUrl = value
         }
    }
    public func setPhotoUrl(_ value:String) -> EntityProperties.Builder {
      self.photoUrl = value
      return self
    }
    public func clearPhotoUrl() -> EntityProperties.Builder{
         builderResult.hasPhotoUrl = false
         builderResult.photoUrl = ""
         return self
    }
    public var email:Array<String> {
         get {
             return builderResult.email
         }
         set (array) {
             builderResult.email = array
         }
    }
    public func setEmail(_ value:Array<String>) -> EntityProperties.Builder {
      self.email = value
      return self
    }
    public func clearEmail() -> EntityProperties.Builder {
       builderResult.email.removeAll(keepingCapacity: false)
       return self
    }
    public var phone:Array<String> {
         get {
             return builderResult.phone
         }
         set (array) {
             builderResult.phone = array
         }
    }
    public func setPhone(_ value:Array<String>) -> EntityProperties.Builder {
      self.phone = value
      return self
    }
    public func clearPhone() -> EntityProperties.Builder {
       builderResult.phone.removeAll(keepingCapacity: false)
       return self
    }
    public var hasInUsersDomain:Bool {
         get {
              return builderResult.hasInUsersDomain
         }
    }
    public var inUsersDomain:Bool {
         get {
              return builderResult.inUsersDomain
         }
         set (value) {
             builderResult.hasInUsersDomain = true
             builderResult.inUsersDomain = value
         }
    }
    public func setInUsersDomain(_ value:Bool) -> EntityProperties.Builder {
      self.inUsersDomain = value
      return self
    }
    public func clearInUsersDomain() -> EntityProperties.Builder{
         builderResult.hasInUsersDomain = false
         builderResult.inUsersDomain = false
         return self
    }
      public var hasGender:Bool{
          get {
              return builderResult.hasGender
          }
      }
      public var gender:Gender {
          get {
              return builderResult.gender
          }
          set (value) {
              builderResult.hasGender = true
              builderResult.gender = value
          }
      }
      public func setGender(_ value:Gender) -> EntityProperties.Builder {
        self.gender = value
        return self
      }
      public func clearGender() -> EntityProperties.Builder {
         builderResult.hasGender = false
         builderResult.gender = .GenderUnknown
         return self
      }
      public var hasPhotoUrlStatus:Bool{
          get {
              return builderResult.hasPhotoUrlStatus
          }
      }
      public var photoUrlStatus:PhotoUrlStatus {
          get {
              return builderResult.photoUrlStatus
          }
          set (value) {
              builderResult.hasPhotoUrlStatus = true
              builderResult.photoUrlStatus = value
          }
      }
      public func setPhotoUrlStatus(_ value:PhotoUrlStatus) -> EntityProperties.Builder {
        self.photoUrlStatus = value
        return self
      }
      public func clearPhotoUrlStatus() -> EntityProperties.Builder {
         builderResult.hasPhotoUrlStatus = false
         builderResult.photoUrlStatus = .PhotoUrlStatusUnknown
         return self
      }
    public var hasCanonicalEmail:Bool {
         get {
              return builderResult.hasCanonicalEmail
         }
    }
    public var canonicalEmail:String {
         get {
              return builderResult.canonicalEmail
         }
         set (value) {
             builderResult.hasCanonicalEmail = true
             builderResult.canonicalEmail = value
         }
    }
    public func setCanonicalEmail(_ value:String) -> EntityProperties.Builder {
      self.canonicalEmail = value
      return self
    }
    public func clearCanonicalEmail() -> EntityProperties.Builder{
         builderResult.hasCanonicalEmail = false
         builderResult.canonicalEmail = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EntityProperties.Builder {
      builderResult = EntityProperties()
      return self
    }
    public override func clone() throws -> EntityProperties.Builder {
      return try EntityProperties.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EntityProperties {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EntityProperties {
      let returnMe:EntityProperties = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EntityProperties) throws -> EntityProperties.Builder {
      if other == EntityProperties() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasDisplayName {
           displayName = other.displayName
      }
      if other.hasFirstName {
           firstName = other.firstName
      }
      if other.hasPhotoUrl {
           photoUrl = other.photoUrl
      }
      if !other.email.isEmpty {
          builderResult.email += other.email
      }
      if !other.phone.isEmpty {
          builderResult.phone += other.phone
      }
      if other.hasInUsersDomain {
           inUsersDomain = other.inUsersDomain
      }
      if other.hasGender {
           gender = other.gender
      }
      if other.hasPhotoUrlStatus {
           photoUrlStatus = other.photoUrlStatus
      }
      if other.hasCanonicalEmail {
           canonicalEmail = other.canonicalEmail
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EntityProperties.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityProperties.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ProfileType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 18:
          displayName = try input.readString()

        case 26:
          firstName = try input.readString()

        case 34:
          photoUrl = try input.readString()

        case 42:
          email += [try input.readString()]

        case 50:
          phone += [try input.readString()]

        case 80:
          inUsersDomain = try input.readBool()

        case 88:
          let valueIntgender = try input.readEnum()
          if let enumsgender = Gender(rawValue:valueIntgender){
               gender = enumsgender
          } else {
               try unknownFieldsBuilder.mergeVarintField(11, value:Int64(valueIntgender))
          }

        case 96:
          let valueIntphotoUrlStatus = try input.readEnum()
          if let enumsphotoUrlStatus = PhotoUrlStatus(rawValue:valueIntphotoUrlStatus){
               photoUrlStatus = enumsphotoUrlStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(12, value:Int64(valueIntphotoUrlStatus))
          }

        case 122:
          canonicalEmail = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// State of a conversation and recent events.
final public class ConversationState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var conversation:Conversation!
  public private(set) var hasConversation:Bool = false
  public private(set) var event:Array<Event>  = Array<Event>()
  public private(set) var eventContinuationToken:EventContinuationToken!
  public private(set) var hasEventContinuationToken:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitevent:Bool = true
    for oneElementevent in event {
        if (!oneElementevent.isInitialized()) {
            isInitevent = false
            break 
        }
    }
    if !isInitevent {
     return isInitevent
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasConversation {
      try output.writeMessage(2, value:conversation)
    }
    for oneElementevent in event {
        try output.writeMessage(3, value:oneElementevent)
    }
    if hasEventContinuationToken {
      try output.writeMessage(5, value:eventContinuationToken)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasConversation {
        if let varSizeconversation = conversation?.computeMessageSize(2) {
            serialize_size += varSizeconversation
        }
    }
    for oneElementevent in event {
        serialize_size += oneElementevent.computeMessageSize(3)
    }
    if hasEventContinuationToken {
        if let varSizeeventContinuationToken = eventContinuationToken?.computeMessageSize(5) {
            serialize_size += varSizeeventContinuationToken
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationState> {
    var mergedArray = Array<ConversationState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationState? {
    return try ConversationState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationState {
    return try ConversationState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationState.Builder {
    return ConversationState.classBuilder() as! ConversationState.Builder
  }
  public func getBuilder() -> ConversationState.Builder {
    return classBuilder() as! ConversationState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationState.Builder()
  }
  public func toBuilder() throws -> ConversationState.Builder {
    return try ConversationState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationState) throws -> ConversationState.Builder {
    return try ConversationState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversation {
      output += "\(indent) conversation {\n"
      if let outDescConversation = conversation {
        output += try outDescConversation.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var eventElementIndex:Int = 0
    for oneElementevent in event {
        output += "\(indent) event[\(eventElementIndex)] {\n"
        output += try oneElementevent.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        eventElementIndex += 1
    }
    if hasEventContinuationToken {
      output += "\(indent) eventContinuationToken {\n"
      if let outDescEventContinuationToken = eventContinuationToken {
        output += try outDescEventContinuationToken.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasConversation {
              if let hashValueconversation = conversation?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversation
              }
          }
          for oneElementevent in event {
              hashCode = (hashCode &* 31) &+ oneElementevent.hashValue
          }
          if hasEventContinuationToken {
              if let hashValueeventContinuationToken = eventContinuationToken?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventContinuationToken
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationState"
  }
  override public func className() -> String {
      return "ConversationState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationState = ConversationState()
    public func getMessage() -> ConversationState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> ConversationState.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> ConversationState.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> ConversationState.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasConversation:Bool {
         get {
             return builderResult.hasConversation
         }
    }
    public var conversation:Conversation! {
         get {
             if conversationBuilder_ != nil {
                builderResult.conversation = conversationBuilder_.getMessage()
             }
             return builderResult.conversation
         }
         set (value) {
             builderResult.hasConversation = true
             builderResult.conversation = value
         }
    }
    private var conversationBuilder_:Conversation.Builder! {
         didSet {
            builderResult.hasConversation = true
         }
    }
    public func getConversationBuilder() -> Conversation.Builder {
      if conversationBuilder_ == nil {
         conversationBuilder_ = Conversation.Builder()
         builderResult.conversation = conversationBuilder_.getMessage()
         if conversation != nil {
            try! conversationBuilder_.mergeFrom(conversation)
         }
      }
      return conversationBuilder_
    }
    public func setConversation(_ value:Conversation!) -> ConversationState.Builder {
      self.conversation = value
      return self
    }
    public func mergeConversation(_ value:Conversation) throws -> ConversationState.Builder {
      if builderResult.hasConversation {
        builderResult.conversation = try Conversation.builderWithPrototype(builderResult.conversation).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversation = value
      }
      builderResult.hasConversation = true
      return self
    }
    public func clearConversation() -> ConversationState.Builder {
      conversationBuilder_ = nil
      builderResult.hasConversation = false
      builderResult.conversation = nil
      return self
    }
    public var event:Array<Event> {
         get {
             return builderResult.event
         }
         set (value) {
             builderResult.event = value
         }
    }
    public func setEvent(_ value:Array<Event>) -> ConversationState.Builder {
      self.event = value
      return self
    }
    public func clearEvent() -> ConversationState.Builder {
      builderResult.event.removeAll(keepingCapacity: false)
      return self
    }
    public var hasEventContinuationToken:Bool {
         get {
             return builderResult.hasEventContinuationToken
         }
    }
    public var eventContinuationToken:EventContinuationToken! {
         get {
             if eventContinuationTokenBuilder_ != nil {
                builderResult.eventContinuationToken = eventContinuationTokenBuilder_.getMessage()
             }
             return builderResult.eventContinuationToken
         }
         set (value) {
             builderResult.hasEventContinuationToken = true
             builderResult.eventContinuationToken = value
         }
    }
    private var eventContinuationTokenBuilder_:EventContinuationToken.Builder! {
         didSet {
            builderResult.hasEventContinuationToken = true
         }
    }
    public func getEventContinuationTokenBuilder() -> EventContinuationToken.Builder {
      if eventContinuationTokenBuilder_ == nil {
         eventContinuationTokenBuilder_ = EventContinuationToken.Builder()
         builderResult.eventContinuationToken = eventContinuationTokenBuilder_.getMessage()
         if eventContinuationToken != nil {
            try! eventContinuationTokenBuilder_.mergeFrom(eventContinuationToken)
         }
      }
      return eventContinuationTokenBuilder_
    }
    public func setEventContinuationToken(_ value:EventContinuationToken!) -> ConversationState.Builder {
      self.eventContinuationToken = value
      return self
    }
    public func mergeEventContinuationToken(_ value:EventContinuationToken) throws -> ConversationState.Builder {
      if builderResult.hasEventContinuationToken {
        builderResult.eventContinuationToken = try EventContinuationToken.builderWithPrototype(builderResult.eventContinuationToken).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventContinuationToken = value
      }
      builderResult.hasEventContinuationToken = true
      return self
    }
    public func clearEventContinuationToken() -> ConversationState.Builder {
      eventContinuationTokenBuilder_ = nil
      builderResult.hasEventContinuationToken = false
      builderResult.eventContinuationToken = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationState.Builder {
      builderResult = ConversationState()
      return self
    }
    public override func clone() throws -> ConversationState.Builder {
      return try ConversationState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationState {
      let returnMe:ConversationState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationState) throws -> ConversationState.Builder {
      if other == ConversationState() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasConversation) {
          try mergeConversation(other.conversation)
      }
      if !other.event.isEmpty  {
         builderResult.event += other.event
      }
      if (other.hasEventContinuationToken) {
          try mergeEventContinuationToken(other.eventContinuationToken)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 18:
          let subBuilder:Conversation.Builder = Conversation.Builder()
          if hasConversation {
            try subBuilder.mergeFrom(conversation)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversation = subBuilder.buildPartial()

        case 26:
          let subBuilder = Event.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          event += [subBuilder.buildPartial()]

        case 42:
          let subBuilder:EventContinuationToken.Builder = EventContinuationToken.Builder()
          if hasEventContinuationToken {
            try subBuilder.mergeFrom(eventContinuationToken)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventContinuationToken = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Token that allows retrieving more events from a position in a conversation.
// Specifying event_timestamp is sufficient.
final public class EventContinuationToken : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var eventId:String = ""

  public private(set) var hasEventId:Bool = false
  public private(set) var storageContinuationToken:NSData = NSData()

  public private(set) var hasStorageContinuationToken:Bool = false
  public private(set) var eventTimestamp:UInt64 = UInt64(0)

  public private(set) var hasEventTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEventId {
      try output.writeString(1, value:eventId)
    }
    if hasStorageContinuationToken {
      try output.writeData(2, value:storageContinuationToken)
    }
    if hasEventTimestamp {
      try output.writeUInt64(3, value:eventTimestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEventId {
      serialize_size += eventId.computeStringSize(1)
    }
    if hasStorageContinuationToken {
      serialize_size += storageContinuationToken.computeDataSize(2)
    }
    if hasEventTimestamp {
      serialize_size += eventTimestamp.computeUInt64Size(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EventContinuationToken> {
    var mergedArray = Array<EventContinuationToken>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EventContinuationToken? {
    return try EventContinuationToken.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventContinuationToken {
    return try EventContinuationToken.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EventContinuationToken.Builder {
    return EventContinuationToken.classBuilder() as! EventContinuationToken.Builder
  }
  public func getBuilder() -> EventContinuationToken.Builder {
    return classBuilder() as! EventContinuationToken.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EventContinuationToken.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EventContinuationToken.Builder()
  }
  public func toBuilder() throws -> EventContinuationToken.Builder {
    return try EventContinuationToken.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EventContinuationToken) throws -> EventContinuationToken.Builder {
    return try EventContinuationToken.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasEventId {
      output += "\(indent) eventId: \(eventId) \n"
    }
    if hasStorageContinuationToken {
      output += "\(indent) storageContinuationToken: \(storageContinuationToken) \n"
    }
    if hasEventTimestamp {
      output += "\(indent) eventTimestamp: \(eventTimestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEventId {
             hashCode = (hashCode &* 31) &+ eventId.hashValue
          }
          if hasStorageContinuationToken {
             hashCode = (hashCode &* 31) &+ storageContinuationToken.hashValue
          }
          if hasEventTimestamp {
             hashCode = (hashCode &* 31) &+ eventTimestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EventContinuationToken"
  }
  override public func className() -> String {
      return "EventContinuationToken"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EventContinuationToken.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EventContinuationToken = EventContinuationToken()
    public func getMessage() -> EventContinuationToken {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEventId:Bool {
         get {
              return builderResult.hasEventId
         }
    }
    public var eventId:String {
         get {
              return builderResult.eventId
         }
         set (value) {
             builderResult.hasEventId = true
             builderResult.eventId = value
         }
    }
    public func setEventId(_ value:String) -> EventContinuationToken.Builder {
      self.eventId = value
      return self
    }
    public func clearEventId() -> EventContinuationToken.Builder{
         builderResult.hasEventId = false
         builderResult.eventId = ""
         return self
    }
    public var hasStorageContinuationToken:Bool {
         get {
              return builderResult.hasStorageContinuationToken
         }
    }
    public var storageContinuationToken:NSData {
         get {
              return builderResult.storageContinuationToken
         }
         set (value) {
             builderResult.hasStorageContinuationToken = true
             builderResult.storageContinuationToken = value
         }
    }
    public func setStorageContinuationToken(_ value:NSData) -> EventContinuationToken.Builder {
      self.storageContinuationToken = value
      return self
    }
    public func clearStorageContinuationToken() -> EventContinuationToken.Builder{
         builderResult.hasStorageContinuationToken = false
         builderResult.storageContinuationToken = NSData()
         return self
    }
    public var hasEventTimestamp:Bool {
         get {
              return builderResult.hasEventTimestamp
         }
    }
    public var eventTimestamp:UInt64 {
         get {
              return builderResult.eventTimestamp
         }
         set (value) {
             builderResult.hasEventTimestamp = true
             builderResult.eventTimestamp = value
         }
    }
    public func setEventTimestamp(_ value:UInt64) -> EventContinuationToken.Builder {
      self.eventTimestamp = value
      return self
    }
    public func clearEventTimestamp() -> EventContinuationToken.Builder{
         builderResult.hasEventTimestamp = false
         builderResult.eventTimestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EventContinuationToken.Builder {
      builderResult = EventContinuationToken()
      return self
    }
    public override func clone() throws -> EventContinuationToken.Builder {
      return try EventContinuationToken.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EventContinuationToken {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EventContinuationToken {
      let returnMe:EventContinuationToken = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EventContinuationToken) throws -> EventContinuationToken.Builder {
      if other == EventContinuationToken() {
       return self
      }
      if other.hasEventId {
           eventId = other.eventId
      }
      if other.hasStorageContinuationToken {
           storageContinuationToken = other.storageContinuationToken
      }
      if other.hasEventTimestamp {
           eventTimestamp = other.eventTimestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EventContinuationToken.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventContinuationToken.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          eventId = try input.readString()

        case 18:
          storageContinuationToken = try input.readData()

        case 24:
          eventTimestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Specifies an entity to lookup by one of its properties.
final public class EntityLookupSpec : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var gaiaId:String = ""

  public private(set) var hasGaiaId:Bool = false
  public private(set) var email:String = ""

  public private(set) var hasEmail:Bool = false
  // Phone number as string (eg. "+15551234567").
  public private(set) var phone:String = ""

  public private(set) var hasPhone:Bool = false
  // Whether create a gaia_id for off-network contacts (eg. Google Voice contacts).
  public private(set) var createOffnetworkGaia:Bool = false

  public private(set) var hasCreateOffnetworkGaia:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasGaiaId {
      try output.writeString(1, value:gaiaId)
    }
    if hasEmail {
      try output.writeString(3, value:email)
    }
    if hasPhone {
      try output.writeString(4, value:phone)
    }
    if hasCreateOffnetworkGaia {
      try output.writeBool(6, value:createOffnetworkGaia)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasGaiaId {
      serialize_size += gaiaId.computeStringSize(1)
    }
    if hasEmail {
      serialize_size += email.computeStringSize(3)
    }
    if hasPhone {
      serialize_size += phone.computeStringSize(4)
    }
    if hasCreateOffnetworkGaia {
      serialize_size += createOffnetworkGaia.computeBoolSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EntityLookupSpec> {
    var mergedArray = Array<EntityLookupSpec>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EntityLookupSpec? {
    return try EntityLookupSpec.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityLookupSpec {
    return try EntityLookupSpec.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EntityLookupSpec.Builder {
    return EntityLookupSpec.classBuilder() as! EntityLookupSpec.Builder
  }
  public func getBuilder() -> EntityLookupSpec.Builder {
    return classBuilder() as! EntityLookupSpec.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EntityLookupSpec.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EntityLookupSpec.Builder()
  }
  public func toBuilder() throws -> EntityLookupSpec.Builder {
    return try EntityLookupSpec.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EntityLookupSpec) throws -> EntityLookupSpec.Builder {
    return try EntityLookupSpec.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasGaiaId {
      output += "\(indent) gaiaId: \(gaiaId) \n"
    }
    if hasEmail {
      output += "\(indent) email: \(email) \n"
    }
    if hasPhone {
      output += "\(indent) phone: \(phone) \n"
    }
    if hasCreateOffnetworkGaia {
      output += "\(indent) createOffnetworkGaia: \(createOffnetworkGaia) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasGaiaId {
             hashCode = (hashCode &* 31) &+ gaiaId.hashValue
          }
          if hasEmail {
             hashCode = (hashCode &* 31) &+ email.hashValue
          }
          if hasPhone {
             hashCode = (hashCode &* 31) &+ phone.hashValue
          }
          if hasCreateOffnetworkGaia {
             hashCode = (hashCode &* 31) &+ createOffnetworkGaia.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EntityLookupSpec"
  }
  override public func className() -> String {
      return "EntityLookupSpec"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EntityLookupSpec.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EntityLookupSpec = EntityLookupSpec()
    public func getMessage() -> EntityLookupSpec {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasGaiaId:Bool {
         get {
              return builderResult.hasGaiaId
         }
    }
    public var gaiaId:String {
         get {
              return builderResult.gaiaId
         }
         set (value) {
             builderResult.hasGaiaId = true
             builderResult.gaiaId = value
         }
    }
    public func setGaiaId(_ value:String) -> EntityLookupSpec.Builder {
      self.gaiaId = value
      return self
    }
    public func clearGaiaId() -> EntityLookupSpec.Builder{
         builderResult.hasGaiaId = false
         builderResult.gaiaId = ""
         return self
    }
    public var hasEmail:Bool {
         get {
              return builderResult.hasEmail
         }
    }
    public var email:String {
         get {
              return builderResult.email
         }
         set (value) {
             builderResult.hasEmail = true
             builderResult.email = value
         }
    }
    public func setEmail(_ value:String) -> EntityLookupSpec.Builder {
      self.email = value
      return self
    }
    public func clearEmail() -> EntityLookupSpec.Builder{
         builderResult.hasEmail = false
         builderResult.email = ""
         return self
    }
    public var hasPhone:Bool {
         get {
              return builderResult.hasPhone
         }
    }
    public var phone:String {
         get {
              return builderResult.phone
         }
         set (value) {
             builderResult.hasPhone = true
             builderResult.phone = value
         }
    }
    public func setPhone(_ value:String) -> EntityLookupSpec.Builder {
      self.phone = value
      return self
    }
    public func clearPhone() -> EntityLookupSpec.Builder{
         builderResult.hasPhone = false
         builderResult.phone = ""
         return self
    }
    public var hasCreateOffnetworkGaia:Bool {
         get {
              return builderResult.hasCreateOffnetworkGaia
         }
    }
    public var createOffnetworkGaia:Bool {
         get {
              return builderResult.createOffnetworkGaia
         }
         set (value) {
             builderResult.hasCreateOffnetworkGaia = true
             builderResult.createOffnetworkGaia = value
         }
    }
    public func setCreateOffnetworkGaia(_ value:Bool) -> EntityLookupSpec.Builder {
      self.createOffnetworkGaia = value
      return self
    }
    public func clearCreateOffnetworkGaia() -> EntityLookupSpec.Builder{
         builderResult.hasCreateOffnetworkGaia = false
         builderResult.createOffnetworkGaia = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EntityLookupSpec.Builder {
      builderResult = EntityLookupSpec()
      return self
    }
    public override func clone() throws -> EntityLookupSpec.Builder {
      return try EntityLookupSpec.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EntityLookupSpec {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EntityLookupSpec {
      let returnMe:EntityLookupSpec = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EntityLookupSpec) throws -> EntityLookupSpec.Builder {
      if other == EntityLookupSpec() {
       return self
      }
      if other.hasGaiaId {
           gaiaId = other.gaiaId
      }
      if other.hasEmail {
           email = other.email
      }
      if other.hasPhone {
           phone = other.phone
      }
      if other.hasCreateOffnetworkGaia {
           createOffnetworkGaia = other.createOffnetworkGaia
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EntityLookupSpec.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityLookupSpec.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          gaiaId = try input.readString()

        case 26:
          email = try input.readString()

        case 34:
          phone = try input.readString()

        case 48:
          createOffnetworkGaia = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConfigurationBit : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var configurationBitType:ConfigurationBitType = ConfigurationBitType.ConfigurationBitTypeUnknown
  public private(set) var hasConfigurationBitType:Bool = false
  public private(set) var value:Bool = false

  public private(set) var hasValue:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConfigurationBitType {
      try output.writeEnum(1, value:configurationBitType.rawValue)
    }
    if hasValue {
      try output.writeBool(2, value:value)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasConfigurationBitType) {
      serialize_size += configurationBitType.rawValue.computeEnumSize(1)
    }
    if hasValue {
      serialize_size += value.computeBoolSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConfigurationBit> {
    var mergedArray = Array<ConfigurationBit>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConfigurationBit? {
    return try ConfigurationBit.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConfigurationBit {
    return try ConfigurationBit.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConfigurationBit.Builder {
    return ConfigurationBit.classBuilder() as! ConfigurationBit.Builder
  }
  public func getBuilder() -> ConfigurationBit.Builder {
    return classBuilder() as! ConfigurationBit.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConfigurationBit.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConfigurationBit.Builder()
  }
  public func toBuilder() throws -> ConfigurationBit.Builder {
    return try ConfigurationBit.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConfigurationBit) throws -> ConfigurationBit.Builder {
    return try ConfigurationBit.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasConfigurationBitType) {
      output += "\(indent) configurationBitType: \(configurationBitType.description)\n"
    }
    if hasValue {
      output += "\(indent) value: \(value) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConfigurationBitType {
             hashCode = (hashCode &* 31) &+ Int(configurationBitType.rawValue)
          }
          if hasValue {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConfigurationBit"
  }
  override public func className() -> String {
      return "ConfigurationBit"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConfigurationBit.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConfigurationBit = ConfigurationBit()
    public func getMessage() -> ConfigurationBit {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasConfigurationBitType:Bool{
          get {
              return builderResult.hasConfigurationBitType
          }
      }
      public var configurationBitType:ConfigurationBitType {
          get {
              return builderResult.configurationBitType
          }
          set (value) {
              builderResult.hasConfigurationBitType = true
              builderResult.configurationBitType = value
          }
      }
      public func setConfigurationBitType(_ value:ConfigurationBitType) -> ConfigurationBit.Builder {
        self.configurationBitType = value
        return self
      }
      public func clearConfigurationBitType() -> ConfigurationBit.Builder {
         builderResult.hasConfigurationBitType = false
         builderResult.configurationBitType = .ConfigurationBitTypeUnknown
         return self
      }
    public var hasValue:Bool {
         get {
              return builderResult.hasValue
         }
    }
    public var value:Bool {
         get {
              return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    public func setValue(_ value:Bool) -> ConfigurationBit.Builder {
      self.value = value
      return self
    }
    public func clearValue() -> ConfigurationBit.Builder{
         builderResult.hasValue = false
         builderResult.value = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConfigurationBit.Builder {
      builderResult = ConfigurationBit()
      return self
    }
    public override func clone() throws -> ConfigurationBit.Builder {
      return try ConfigurationBit.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConfigurationBit {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConfigurationBit {
      let returnMe:ConfigurationBit = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConfigurationBit) throws -> ConfigurationBit.Builder {
      if other == ConfigurationBit() {
       return self
      }
      if other.hasConfigurationBitType {
           configurationBitType = other.configurationBitType
      }
      if other.hasValue {
           value = other.value
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConfigurationBit.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConfigurationBit.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntconfigurationBitType = try input.readEnum()
          if let enumsconfigurationBitType = ConfigurationBitType(rawValue:valueIntconfigurationBitType){
               configurationBitType = enumsconfigurationBitType
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntconfigurationBitType))
          }

        case 16:
          value = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RichPresenceState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var getRichPresenceEnabledState:Array<RichPresenceEnabledState>  = Array<RichPresenceEnabledState>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementgetRichPresenceEnabledState in getRichPresenceEnabledState {
        try output.writeMessage(3, value:oneElementgetRichPresenceEnabledState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementgetRichPresenceEnabledState in getRichPresenceEnabledState {
        serialize_size += oneElementgetRichPresenceEnabledState.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RichPresenceState> {
    var mergedArray = Array<RichPresenceState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RichPresenceState? {
    return try RichPresenceState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceState {
    return try RichPresenceState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RichPresenceState.Builder {
    return RichPresenceState.classBuilder() as! RichPresenceState.Builder
  }
  public func getBuilder() -> RichPresenceState.Builder {
    return classBuilder() as! RichPresenceState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RichPresenceState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RichPresenceState.Builder()
  }
  public func toBuilder() throws -> RichPresenceState.Builder {
    return try RichPresenceState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RichPresenceState) throws -> RichPresenceState.Builder {
    return try RichPresenceState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var getRichPresenceEnabledStateElementIndex:Int = 0
    for oneElementgetRichPresenceEnabledState in getRichPresenceEnabledState {
        output += "\(indent) getRichPresenceEnabledState[\(getRichPresenceEnabledStateElementIndex)] {\n"
        output += try oneElementgetRichPresenceEnabledState.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        getRichPresenceEnabledStateElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementgetRichPresenceEnabledState in getRichPresenceEnabledState {
              hashCode = (hashCode &* 31) &+ oneElementgetRichPresenceEnabledState.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RichPresenceState"
  }
  override public func className() -> String {
      return "RichPresenceState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RichPresenceState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RichPresenceState = RichPresenceState()
    public func getMessage() -> RichPresenceState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var getRichPresenceEnabledState:Array<RichPresenceEnabledState> {
         get {
             return builderResult.getRichPresenceEnabledState
         }
         set (value) {
             builderResult.getRichPresenceEnabledState = value
         }
    }
    public func setGetRichPresenceEnabledState(_ value:Array<RichPresenceEnabledState>) -> RichPresenceState.Builder {
      self.getRichPresenceEnabledState = value
      return self
    }
    public func clearGetRichPresenceEnabledState() -> RichPresenceState.Builder {
      builderResult.getRichPresenceEnabledState.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RichPresenceState.Builder {
      builderResult = RichPresenceState()
      return self
    }
    public override func clone() throws -> RichPresenceState.Builder {
      return try RichPresenceState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RichPresenceState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RichPresenceState {
      let returnMe:RichPresenceState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RichPresenceState) throws -> RichPresenceState.Builder {
      if other == RichPresenceState() {
       return self
      }
      if !other.getRichPresenceEnabledState.isEmpty  {
         builderResult.getRichPresenceEnabledState += other.getRichPresenceEnabledState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 26:
          let subBuilder = RichPresenceEnabledState.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          getRichPresenceEnabledState += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RichPresenceEnabledState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var types:RichPresenceType = RichPresenceType.RichPresenceTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var enabled:Bool = false

  public private(set) var hasEnabled:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    if hasEnabled {
      try output.writeBool(2, value:enabled)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    if hasEnabled {
      serialize_size += enabled.computeBoolSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RichPresenceEnabledState> {
    var mergedArray = Array<RichPresenceEnabledState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RichPresenceEnabledState? {
    return try RichPresenceEnabledState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledState {
    return try RichPresenceEnabledState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RichPresenceEnabledState.Builder {
    return RichPresenceEnabledState.classBuilder() as! RichPresenceEnabledState.Builder
  }
  public func getBuilder() -> RichPresenceEnabledState.Builder {
    return classBuilder() as! RichPresenceEnabledState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RichPresenceEnabledState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RichPresenceEnabledState.Builder()
  }
  public func toBuilder() throws -> RichPresenceEnabledState.Builder {
    return try RichPresenceEnabledState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RichPresenceEnabledState) throws -> RichPresenceEnabledState.Builder {
    return try RichPresenceEnabledState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasEnabled {
      output += "\(indent) enabled: \(enabled) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasEnabled {
             hashCode = (hashCode &* 31) &+ enabled.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RichPresenceEnabledState"
  }
  override public func className() -> String {
      return "RichPresenceEnabledState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RichPresenceEnabledState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RichPresenceEnabledState = RichPresenceEnabledState()
    public func getMessage() -> RichPresenceEnabledState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:RichPresenceType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:RichPresenceType) -> RichPresenceEnabledState.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> RichPresenceEnabledState.Builder {
         builderResult.hasTypes = false
         builderResult.types = .RichPresenceTypeUnknown
         return self
      }
    public var hasEnabled:Bool {
         get {
              return builderResult.hasEnabled
         }
    }
    public var enabled:Bool {
         get {
              return builderResult.enabled
         }
         set (value) {
             builderResult.hasEnabled = true
             builderResult.enabled = value
         }
    }
    public func setEnabled(_ value:Bool) -> RichPresenceEnabledState.Builder {
      self.enabled = value
      return self
    }
    public func clearEnabled() -> RichPresenceEnabledState.Builder{
         builderResult.hasEnabled = false
         builderResult.enabled = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RichPresenceEnabledState.Builder {
      builderResult = RichPresenceEnabledState()
      return self
    }
    public override func clone() throws -> RichPresenceEnabledState.Builder {
      return try RichPresenceEnabledState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RichPresenceEnabledState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RichPresenceEnabledState {
      let returnMe:RichPresenceEnabledState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RichPresenceEnabledState) throws -> RichPresenceEnabledState.Builder {
      if other == RichPresenceEnabledState() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasEnabled {
           enabled = other.enabled
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceEnabledState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = RichPresenceType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 16:
          enabled = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DesktopOffSetting : GeneratedMessage, GeneratedMessageProtocol {
  // State of "desktop off" setting.
  public private(set) var desktopOff:Bool = false

  public private(set) var hasDesktopOff:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDesktopOff {
      try output.writeBool(1, value:desktopOff)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDesktopOff {
      serialize_size += desktopOff.computeBoolSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DesktopOffSetting> {
    var mergedArray = Array<DesktopOffSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DesktopOffSetting? {
    return try DesktopOffSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffSetting {
    return try DesktopOffSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DesktopOffSetting.Builder {
    return DesktopOffSetting.classBuilder() as! DesktopOffSetting.Builder
  }
  public func getBuilder() -> DesktopOffSetting.Builder {
    return classBuilder() as! DesktopOffSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DesktopOffSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DesktopOffSetting.Builder()
  }
  public func toBuilder() throws -> DesktopOffSetting.Builder {
    return try DesktopOffSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DesktopOffSetting) throws -> DesktopOffSetting.Builder {
    return try DesktopOffSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDesktopOff {
      output += "\(indent) desktopOff: \(desktopOff) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDesktopOff {
             hashCode = (hashCode &* 31) &+ desktopOff.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DesktopOffSetting"
  }
  override public func className() -> String {
      return "DesktopOffSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DesktopOffSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DesktopOffSetting = DesktopOffSetting()
    public func getMessage() -> DesktopOffSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDesktopOff:Bool {
         get {
              return builderResult.hasDesktopOff
         }
    }
    public var desktopOff:Bool {
         get {
              return builderResult.desktopOff
         }
         set (value) {
             builderResult.hasDesktopOff = true
             builderResult.desktopOff = value
         }
    }
    public func setDesktopOff(_ value:Bool) -> DesktopOffSetting.Builder {
      self.desktopOff = value
      return self
    }
    public func clearDesktopOff() -> DesktopOffSetting.Builder{
         builderResult.hasDesktopOff = false
         builderResult.desktopOff = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DesktopOffSetting.Builder {
      builderResult = DesktopOffSetting()
      return self
    }
    public override func clone() throws -> DesktopOffSetting.Builder {
      return try DesktopOffSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DesktopOffSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DesktopOffSetting {
      let returnMe:DesktopOffSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DesktopOffSetting) throws -> DesktopOffSetting.Builder {
      if other == DesktopOffSetting() {
       return self
      }
      if other.hasDesktopOff {
           desktopOff = other.desktopOff
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopOffSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          desktopOff = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DesktopOffState : GeneratedMessage, GeneratedMessageProtocol {
  // Whether Hangouts desktop is signed off or on.
  public private(set) var desktopOff:Bool = false

  public private(set) var hasDesktopOff:Bool = false
  public private(set) var version:UInt64 = UInt64(0)

  public private(set) var hasVersion:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDesktopOff {
      try output.writeBool(1, value:desktopOff)
    }
    if hasVersion {
      try output.writeUInt64(2, value:version)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDesktopOff {
      serialize_size += desktopOff.computeBoolSize(1)
    }
    if hasVersion {
      serialize_size += version.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DesktopOffState> {
    var mergedArray = Array<DesktopOffState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DesktopOffState? {
    return try DesktopOffState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffState {
    return try DesktopOffState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DesktopOffState.Builder {
    return DesktopOffState.classBuilder() as! DesktopOffState.Builder
  }
  public func getBuilder() -> DesktopOffState.Builder {
    return classBuilder() as! DesktopOffState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DesktopOffState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DesktopOffState.Builder()
  }
  public func toBuilder() throws -> DesktopOffState.Builder {
    return try DesktopOffState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DesktopOffState) throws -> DesktopOffState.Builder {
    return try DesktopOffState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDesktopOff {
      output += "\(indent) desktopOff: \(desktopOff) \n"
    }
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDesktopOff {
             hashCode = (hashCode &* 31) &+ desktopOff.hashValue
          }
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DesktopOffState"
  }
  override public func className() -> String {
      return "DesktopOffState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DesktopOffState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DesktopOffState = DesktopOffState()
    public func getMessage() -> DesktopOffState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDesktopOff:Bool {
         get {
              return builderResult.hasDesktopOff
         }
    }
    public var desktopOff:Bool {
         get {
              return builderResult.desktopOff
         }
         set (value) {
             builderResult.hasDesktopOff = true
             builderResult.desktopOff = value
         }
    }
    public func setDesktopOff(_ value:Bool) -> DesktopOffState.Builder {
      self.desktopOff = value
      return self
    }
    public func clearDesktopOff() -> DesktopOffState.Builder{
         builderResult.hasDesktopOff = false
         builderResult.desktopOff = false
         return self
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt64 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(_ value:UInt64) -> DesktopOffState.Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> DesktopOffState.Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DesktopOffState.Builder {
      builderResult = DesktopOffState()
      return self
    }
    public override func clone() throws -> DesktopOffState.Builder {
      return try DesktopOffState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DesktopOffState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DesktopOffState {
      let returnMe:DesktopOffState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DesktopOffState) throws -> DesktopOffState.Builder {
      if other == DesktopOffState() {
       return self
      }
      if other.hasDesktopOff {
           desktopOff = other.desktopOff
      }
      if other.hasVersion {
           version = other.version
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopOffState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopOffState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          desktopOff = try input.readBool()

        case 16:
          version = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Enable or disable do-not-disturb mode. Not to be confused with
// DoNotDisturbSetting, which is used to indicate the state of do-not-disturb
// mode.
final public class DndSetting : GeneratedMessage, GeneratedMessageProtocol {
  // Whether to enable or disable do-not-disturb mode.
  public private(set) var doNotDisturb:Bool = false

  public private(set) var hasDoNotDisturb:Bool = false
  // Do not disturb expiration in seconds.
  public private(set) var timeoutSecs:UInt64 = UInt64(0)

  public private(set) var hasTimeoutSecs:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDoNotDisturb {
      try output.writeBool(1, value:doNotDisturb)
    }
    if hasTimeoutSecs {
      try output.writeUInt64(2, value:timeoutSecs)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDoNotDisturb {
      serialize_size += doNotDisturb.computeBoolSize(1)
    }
    if hasTimeoutSecs {
      serialize_size += timeoutSecs.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DndSetting> {
    var mergedArray = Array<DndSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DndSetting? {
    return try DndSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DndSetting {
    return try DndSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DndSetting.Builder {
    return DndSetting.classBuilder() as! DndSetting.Builder
  }
  public func getBuilder() -> DndSetting.Builder {
    return classBuilder() as! DndSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DndSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DndSetting.Builder()
  }
  public func toBuilder() throws -> DndSetting.Builder {
    return try DndSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DndSetting) throws -> DndSetting.Builder {
    return try DndSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDoNotDisturb {
      output += "\(indent) doNotDisturb: \(doNotDisturb) \n"
    }
    if hasTimeoutSecs {
      output += "\(indent) timeoutSecs: \(timeoutSecs) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDoNotDisturb {
             hashCode = (hashCode &* 31) &+ doNotDisturb.hashValue
          }
          if hasTimeoutSecs {
             hashCode = (hashCode &* 31) &+ timeoutSecs.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DndSetting"
  }
  override public func className() -> String {
      return "DndSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DndSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DndSetting = DndSetting()
    public func getMessage() -> DndSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDoNotDisturb:Bool {
         get {
              return builderResult.hasDoNotDisturb
         }
    }
    public var doNotDisturb:Bool {
         get {
              return builderResult.doNotDisturb
         }
         set (value) {
             builderResult.hasDoNotDisturb = true
             builderResult.doNotDisturb = value
         }
    }
    public func setDoNotDisturb(_ value:Bool) -> DndSetting.Builder {
      self.doNotDisturb = value
      return self
    }
    public func clearDoNotDisturb() -> DndSetting.Builder{
         builderResult.hasDoNotDisturb = false
         builderResult.doNotDisturb = false
         return self
    }
    public var hasTimeoutSecs:Bool {
         get {
              return builderResult.hasTimeoutSecs
         }
    }
    public var timeoutSecs:UInt64 {
         get {
              return builderResult.timeoutSecs
         }
         set (value) {
             builderResult.hasTimeoutSecs = true
             builderResult.timeoutSecs = value
         }
    }
    public func setTimeoutSecs(_ value:UInt64) -> DndSetting.Builder {
      self.timeoutSecs = value
      return self
    }
    public func clearTimeoutSecs() -> DndSetting.Builder{
         builderResult.hasTimeoutSecs = false
         builderResult.timeoutSecs = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DndSetting.Builder {
      builderResult = DndSetting()
      return self
    }
    public override func clone() throws -> DndSetting.Builder {
      return try DndSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DndSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DndSetting {
      let returnMe:DndSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DndSetting) throws -> DndSetting.Builder {
      if other == DndSetting() {
       return self
      }
      if other.hasDoNotDisturb {
           doNotDisturb = other.doNotDisturb
      }
      if other.hasTimeoutSecs {
           timeoutSecs = other.timeoutSecs
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DndSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DndSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          doNotDisturb = try input.readBool()

        case 16:
          timeoutSecs = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PresenceStateSetting : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var timeoutSecs:UInt64 = UInt64(0)

  public private(set) var hasTimeoutSecs:Bool = false
  public private(set) var types:ClientPresenceStateType = ClientPresenceStateType.ClientPresenceStateUnknown
  public private(set) var hasTypes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTimeoutSecs {
      try output.writeUInt64(1, value:timeoutSecs)
    }
    if hasTypes {
      try output.writeEnum(2, value:types.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTimeoutSecs {
      serialize_size += timeoutSecs.computeUInt64Size(1)
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PresenceStateSetting> {
    var mergedArray = Array<PresenceStateSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PresenceStateSetting? {
    return try PresenceStateSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceStateSetting {
    return try PresenceStateSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PresenceStateSetting.Builder {
    return PresenceStateSetting.classBuilder() as! PresenceStateSetting.Builder
  }
  public func getBuilder() -> PresenceStateSetting.Builder {
    return classBuilder() as! PresenceStateSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PresenceStateSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PresenceStateSetting.Builder()
  }
  public func toBuilder() throws -> PresenceStateSetting.Builder {
    return try PresenceStateSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PresenceStateSetting) throws -> PresenceStateSetting.Builder {
    return try PresenceStateSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasTimeoutSecs {
      output += "\(indent) timeoutSecs: \(timeoutSecs) \n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTimeoutSecs {
             hashCode = (hashCode &* 31) &+ timeoutSecs.hashValue
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PresenceStateSetting"
  }
  override public func className() -> String {
      return "PresenceStateSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PresenceStateSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PresenceStateSetting = PresenceStateSetting()
    public func getMessage() -> PresenceStateSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasTimeoutSecs:Bool {
         get {
              return builderResult.hasTimeoutSecs
         }
    }
    public var timeoutSecs:UInt64 {
         get {
              return builderResult.timeoutSecs
         }
         set (value) {
             builderResult.hasTimeoutSecs = true
             builderResult.timeoutSecs = value
         }
    }
    public func setTimeoutSecs(_ value:UInt64) -> PresenceStateSetting.Builder {
      self.timeoutSecs = value
      return self
    }
    public func clearTimeoutSecs() -> PresenceStateSetting.Builder{
         builderResult.hasTimeoutSecs = false
         builderResult.timeoutSecs = UInt64(0)
         return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ClientPresenceStateType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ClientPresenceStateType) -> PresenceStateSetting.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> PresenceStateSetting.Builder {
         builderResult.hasTypes = false
         builderResult.types = .ClientPresenceStateUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PresenceStateSetting.Builder {
      builderResult = PresenceStateSetting()
      return self
    }
    public override func clone() throws -> PresenceStateSetting.Builder {
      return try PresenceStateSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PresenceStateSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PresenceStateSetting {
      let returnMe:PresenceStateSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PresenceStateSetting) throws -> PresenceStateSetting.Builder {
      if other == PresenceStateSetting() {
       return self
      }
      if other.hasTimeoutSecs {
           timeoutSecs = other.timeoutSecs
      }
      if other.hasTypes {
           types = other.types
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceStateSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceStateSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          timeoutSecs = try input.readUInt64()

        case 16:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ClientPresenceStateType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueInttypes))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class MoodMessage : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var moodContent:MoodContent!
  public private(set) var hasMoodContent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodContent {
     if !moodContent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMoodContent {
      try output.writeMessage(1, value:moodContent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMoodContent {
        if let varSizemoodContent = moodContent?.computeMessageSize(1) {
            serialize_size += varSizemoodContent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MoodMessage> {
    var mergedArray = Array<MoodMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MoodMessage? {
    return try MoodMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodMessage {
    return try MoodMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MoodMessage.Builder {
    return MoodMessage.classBuilder() as! MoodMessage.Builder
  }
  public func getBuilder() -> MoodMessage.Builder {
    return classBuilder() as! MoodMessage.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MoodMessage.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MoodMessage.Builder()
  }
  public func toBuilder() throws -> MoodMessage.Builder {
    return try MoodMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MoodMessage) throws -> MoodMessage.Builder {
    return try MoodMessage.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMoodContent {
      output += "\(indent) moodContent {\n"
      if let outDescMoodContent = moodContent {
        output += try outDescMoodContent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMoodContent {
              if let hashValuemoodContent = moodContent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodContent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoodMessage"
  }
  override public func className() -> String {
      return "MoodMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoodMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MoodMessage = MoodMessage()
    public func getMessage() -> MoodMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMoodContent:Bool {
         get {
             return builderResult.hasMoodContent
         }
    }
    public var moodContent:MoodContent! {
         get {
             if moodContentBuilder_ != nil {
                builderResult.moodContent = moodContentBuilder_.getMessage()
             }
             return builderResult.moodContent
         }
         set (value) {
             builderResult.hasMoodContent = true
             builderResult.moodContent = value
         }
    }
    private var moodContentBuilder_:MoodContent.Builder! {
         didSet {
            builderResult.hasMoodContent = true
         }
    }
    public func getMoodContentBuilder() -> MoodContent.Builder {
      if moodContentBuilder_ == nil {
         moodContentBuilder_ = MoodContent.Builder()
         builderResult.moodContent = moodContentBuilder_.getMessage()
         if moodContent != nil {
            try! moodContentBuilder_.mergeFrom(moodContent)
         }
      }
      return moodContentBuilder_
    }
    public func setMoodContent(_ value:MoodContent!) -> MoodMessage.Builder {
      self.moodContent = value
      return self
    }
    public func mergeMoodContent(_ value:MoodContent) throws -> MoodMessage.Builder {
      if builderResult.hasMoodContent {
        builderResult.moodContent = try MoodContent.builderWithPrototype(builderResult.moodContent).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodContent = value
      }
      builderResult.hasMoodContent = true
      return self
    }
    public func clearMoodContent() -> MoodMessage.Builder {
      moodContentBuilder_ = nil
      builderResult.hasMoodContent = false
      builderResult.moodContent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MoodMessage.Builder {
      builderResult = MoodMessage()
      return self
    }
    public override func clone() throws -> MoodMessage.Builder {
      return try MoodMessage.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MoodMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MoodMessage {
      let returnMe:MoodMessage = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MoodMessage) throws -> MoodMessage.Builder {
      if other == MoodMessage() {
       return self
      }
      if (other.hasMoodContent) {
          try mergeMoodContent(other.moodContent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MoodMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:MoodContent.Builder = MoodContent.Builder()
          if hasMoodContent {
            try subBuilder.mergeFrom(moodContent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodContent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class MoodContent : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var segment:Array<Segment>  = Array<Segment>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitsegment:Bool = true
    for oneElementsegment in segment {
        if (!oneElementsegment.isInitialized()) {
            isInitsegment = false
            break 
        }
    }
    if !isInitsegment {
     return isInitsegment
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementsegment in segment {
        try output.writeMessage(1, value:oneElementsegment)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementsegment in segment {
        serialize_size += oneElementsegment.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MoodContent> {
    var mergedArray = Array<MoodContent>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MoodContent? {
    return try MoodContent.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodContent {
    return try MoodContent.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MoodContent.Builder {
    return MoodContent.classBuilder() as! MoodContent.Builder
  }
  public func getBuilder() -> MoodContent.Builder {
    return classBuilder() as! MoodContent.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MoodContent.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MoodContent.Builder()
  }
  public func toBuilder() throws -> MoodContent.Builder {
    return try MoodContent.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MoodContent) throws -> MoodContent.Builder {
    return try MoodContent.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var segmentElementIndex:Int = 0
    for oneElementsegment in segment {
        output += "\(indent) segment[\(segmentElementIndex)] {\n"
        output += try oneElementsegment.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        segmentElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementsegment in segment {
              hashCode = (hashCode &* 31) &+ oneElementsegment.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoodContent"
  }
  override public func className() -> String {
      return "MoodContent"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoodContent.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MoodContent = MoodContent()
    public func getMessage() -> MoodContent {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var segment:Array<Segment> {
         get {
             return builderResult.segment
         }
         set (value) {
             builderResult.segment = value
         }
    }
    public func setSegment(_ value:Array<Segment>) -> MoodContent.Builder {
      self.segment = value
      return self
    }
    public func clearSegment() -> MoodContent.Builder {
      builderResult.segment.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MoodContent.Builder {
      builderResult = MoodContent()
      return self
    }
    public override func clone() throws -> MoodContent.Builder {
      return try MoodContent.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MoodContent {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MoodContent {
      let returnMe:MoodContent = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MoodContent) throws -> MoodContent.Builder {
      if other == MoodContent() {
       return self
      }
      if !other.segment.isEmpty  {
         builderResult.segment += other.segment
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MoodContent.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodContent.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = Segment.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          segment += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// The user's mood message.
final public class MoodSetting : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var moodMessage:MoodMessage!
  public private(set) var hasMoodMessage:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodMessage {
     if !moodMessage.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMoodMessage {
      try output.writeMessage(1, value:moodMessage)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMoodMessage {
        if let varSizemoodMessage = moodMessage?.computeMessageSize(1) {
            serialize_size += varSizemoodMessage
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MoodSetting> {
    var mergedArray = Array<MoodSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MoodSetting? {
    return try MoodSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodSetting {
    return try MoodSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MoodSetting.Builder {
    return MoodSetting.classBuilder() as! MoodSetting.Builder
  }
  public func getBuilder() -> MoodSetting.Builder {
    return classBuilder() as! MoodSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MoodSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MoodSetting.Builder()
  }
  public func toBuilder() throws -> MoodSetting.Builder {
    return try MoodSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MoodSetting) throws -> MoodSetting.Builder {
    return try MoodSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMoodMessage {
      output += "\(indent) moodMessage {\n"
      if let outDescMoodMessage = moodMessage {
        output += try outDescMoodMessage.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMoodMessage {
              if let hashValuemoodMessage = moodMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodMessage
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoodSetting"
  }
  override public func className() -> String {
      return "MoodSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoodSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MoodSetting = MoodSetting()
    public func getMessage() -> MoodSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMoodMessage:Bool {
         get {
             return builderResult.hasMoodMessage
         }
    }
    public var moodMessage:MoodMessage! {
         get {
             if moodMessageBuilder_ != nil {
                builderResult.moodMessage = moodMessageBuilder_.getMessage()
             }
             return builderResult.moodMessage
         }
         set (value) {
             builderResult.hasMoodMessage = true
             builderResult.moodMessage = value
         }
    }
    private var moodMessageBuilder_:MoodMessage.Builder! {
         didSet {
            builderResult.hasMoodMessage = true
         }
    }
    public func getMoodMessageBuilder() -> MoodMessage.Builder {
      if moodMessageBuilder_ == nil {
         moodMessageBuilder_ = MoodMessage.Builder()
         builderResult.moodMessage = moodMessageBuilder_.getMessage()
         if moodMessage != nil {
            try! moodMessageBuilder_.mergeFrom(moodMessage)
         }
      }
      return moodMessageBuilder_
    }
    public func setMoodMessage(_ value:MoodMessage!) -> MoodSetting.Builder {
      self.moodMessage = value
      return self
    }
    public func mergeMoodMessage(_ value:MoodMessage) throws -> MoodSetting.Builder {
      if builderResult.hasMoodMessage {
        builderResult.moodMessage = try MoodMessage.builderWithPrototype(builderResult.moodMessage).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodMessage = value
      }
      builderResult.hasMoodMessage = true
      return self
    }
    public func clearMoodMessage() -> MoodSetting.Builder {
      moodMessageBuilder_ = nil
      builderResult.hasMoodMessage = false
      builderResult.moodMessage = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MoodSetting.Builder {
      builderResult = MoodSetting()
      return self
    }
    public override func clone() throws -> MoodSetting.Builder {
      return try MoodSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MoodSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MoodSetting {
      let returnMe:MoodSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MoodSetting) throws -> MoodSetting.Builder {
      if other == MoodSetting() {
       return self
      }
      if (other.hasMoodMessage) {
          try mergeMoodMessage(other.moodMessage)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MoodSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:MoodMessage.Builder = MoodMessage.Builder()
          if hasMoodMessage {
            try subBuilder.mergeFrom(moodMessage)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodMessage = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class MoodState : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var moodSetting:MoodSetting!
  public private(set) var hasMoodSetting:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodSetting {
     if !moodSetting.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMoodSetting {
      try output.writeMessage(4, value:moodSetting)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMoodSetting {
        if let varSizemoodSetting = moodSetting?.computeMessageSize(4) {
            serialize_size += varSizemoodSetting
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<MoodState> {
    var mergedArray = Array<MoodState>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> MoodState? {
    return try MoodState.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> MoodState {
    return try MoodState.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> MoodState {
    return try MoodState.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> MoodState {
    return try MoodState.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodState {
    return try MoodState.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> MoodState {
    return try MoodState.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodState {
    return try MoodState.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MoodState.Builder {
    return MoodState.classBuilder() as! MoodState.Builder
  }
  public func getBuilder() -> MoodState.Builder {
    return classBuilder() as! MoodState.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MoodState.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MoodState.Builder()
  }
  public func toBuilder() throws -> MoodState.Builder {
    return try MoodState.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:MoodState) throws -> MoodState.Builder {
    return try MoodState.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMoodSetting {
      output += "\(indent) moodSetting {\n"
      if let outDescMoodSetting = moodSetting {
        output += try outDescMoodSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMoodSetting {
              if let hashValuemoodSetting = moodSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodSetting
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoodState"
  }
  override public func className() -> String {
      return "MoodState"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoodState.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MoodState = MoodState()
    public func getMessage() -> MoodState {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMoodSetting:Bool {
         get {
             return builderResult.hasMoodSetting
         }
    }
    public var moodSetting:MoodSetting! {
         get {
             if moodSettingBuilder_ != nil {
                builderResult.moodSetting = moodSettingBuilder_.getMessage()
             }
             return builderResult.moodSetting
         }
         set (value) {
             builderResult.hasMoodSetting = true
             builderResult.moodSetting = value
         }
    }
    private var moodSettingBuilder_:MoodSetting.Builder! {
         didSet {
            builderResult.hasMoodSetting = true
         }
    }
    public func getMoodSettingBuilder() -> MoodSetting.Builder {
      if moodSettingBuilder_ == nil {
         moodSettingBuilder_ = MoodSetting.Builder()
         builderResult.moodSetting = moodSettingBuilder_.getMessage()
         if moodSetting != nil {
            try! moodSettingBuilder_.mergeFrom(moodSetting)
         }
      }
      return moodSettingBuilder_
    }
    public func setMoodSetting(_ value:MoodSetting!) -> MoodState.Builder {
      self.moodSetting = value
      return self
    }
    public func mergeMoodSetting(_ value:MoodSetting) throws -> MoodState.Builder {
      if builderResult.hasMoodSetting {
        builderResult.moodSetting = try MoodSetting.builderWithPrototype(builderResult.moodSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodSetting = value
      }
      builderResult.hasMoodSetting = true
      return self
    }
    public func clearMoodSetting() -> MoodState.Builder {
      moodSettingBuilder_ = nil
      builderResult.hasMoodSetting = false
      builderResult.moodSetting = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MoodState.Builder {
      builderResult = MoodState()
      return self
    }
    public override func clone() throws -> MoodState.Builder {
      return try MoodState.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MoodState {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MoodState {
      let returnMe:MoodState = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:MoodState) throws -> MoodState.Builder {
      if other == MoodState() {
       return self
      }
      if (other.hasMoodSetting) {
          try mergeMoodSetting(other.moodSetting)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> MoodState.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MoodState.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 34:
          let subBuilder:MoodSetting.Builder = MoodSetting.Builder()
          if hasMoodSetting {
            try subBuilder.mergeFrom(moodSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodSetting = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeleteAction : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var deleteActionTimestamp:UInt64 = UInt64(0)

  public private(set) var hasDeleteActionTimestamp:Bool = false
  public private(set) var deleteUpperBoundTimestamp:UInt64 = UInt64(0)

  public private(set) var hasDeleteUpperBoundTimestamp:Bool = false
  public private(set) var deleteType:DeleteType = DeleteType.DeleteTypeUnknown
  public private(set) var hasDeleteType:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDeleteActionTimestamp {
      try output.writeUInt64(1, value:deleteActionTimestamp)
    }
    if hasDeleteUpperBoundTimestamp {
      try output.writeUInt64(2, value:deleteUpperBoundTimestamp)
    }
    if hasDeleteType {
      try output.writeEnum(3, value:deleteType.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDeleteActionTimestamp {
      serialize_size += deleteActionTimestamp.computeUInt64Size(1)
    }
    if hasDeleteUpperBoundTimestamp {
      serialize_size += deleteUpperBoundTimestamp.computeUInt64Size(2)
    }
    if (hasDeleteType) {
      serialize_size += deleteType.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeleteAction> {
    var mergedArray = Array<DeleteAction>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeleteAction? {
    return try DeleteAction.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteAction {
    return try DeleteAction.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeleteAction.Builder {
    return DeleteAction.classBuilder() as! DeleteAction.Builder
  }
  public func getBuilder() -> DeleteAction.Builder {
    return classBuilder() as! DeleteAction.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeleteAction.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeleteAction.Builder()
  }
  public func toBuilder() throws -> DeleteAction.Builder {
    return try DeleteAction.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeleteAction) throws -> DeleteAction.Builder {
    return try DeleteAction.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDeleteActionTimestamp {
      output += "\(indent) deleteActionTimestamp: \(deleteActionTimestamp) \n"
    }
    if hasDeleteUpperBoundTimestamp {
      output += "\(indent) deleteUpperBoundTimestamp: \(deleteUpperBoundTimestamp) \n"
    }
    if (hasDeleteType) {
      output += "\(indent) deleteType: \(deleteType.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDeleteActionTimestamp {
             hashCode = (hashCode &* 31) &+ deleteActionTimestamp.hashValue
          }
          if hasDeleteUpperBoundTimestamp {
             hashCode = (hashCode &* 31) &+ deleteUpperBoundTimestamp.hashValue
          }
          if hasDeleteType {
             hashCode = (hashCode &* 31) &+ Int(deleteType.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeleteAction"
  }
  override public func className() -> String {
      return "DeleteAction"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeleteAction.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeleteAction = DeleteAction()
    public func getMessage() -> DeleteAction {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDeleteActionTimestamp:Bool {
         get {
              return builderResult.hasDeleteActionTimestamp
         }
    }
    public var deleteActionTimestamp:UInt64 {
         get {
              return builderResult.deleteActionTimestamp
         }
         set (value) {
             builderResult.hasDeleteActionTimestamp = true
             builderResult.deleteActionTimestamp = value
         }
    }
    public func setDeleteActionTimestamp(_ value:UInt64) -> DeleteAction.Builder {
      self.deleteActionTimestamp = value
      return self
    }
    public func clearDeleteActionTimestamp() -> DeleteAction.Builder{
         builderResult.hasDeleteActionTimestamp = false
         builderResult.deleteActionTimestamp = UInt64(0)
         return self
    }
    public var hasDeleteUpperBoundTimestamp:Bool {
         get {
              return builderResult.hasDeleteUpperBoundTimestamp
         }
    }
    public var deleteUpperBoundTimestamp:UInt64 {
         get {
              return builderResult.deleteUpperBoundTimestamp
         }
         set (value) {
             builderResult.hasDeleteUpperBoundTimestamp = true
             builderResult.deleteUpperBoundTimestamp = value
         }
    }
    public func setDeleteUpperBoundTimestamp(_ value:UInt64) -> DeleteAction.Builder {
      self.deleteUpperBoundTimestamp = value
      return self
    }
    public func clearDeleteUpperBoundTimestamp() -> DeleteAction.Builder{
         builderResult.hasDeleteUpperBoundTimestamp = false
         builderResult.deleteUpperBoundTimestamp = UInt64(0)
         return self
    }
      public var hasDeleteType:Bool{
          get {
              return builderResult.hasDeleteType
          }
      }
      public var deleteType:DeleteType {
          get {
              return builderResult.deleteType
          }
          set (value) {
              builderResult.hasDeleteType = true
              builderResult.deleteType = value
          }
      }
      public func setDeleteType(_ value:DeleteType) -> DeleteAction.Builder {
        self.deleteType = value
        return self
      }
      public func clearDeleteType() -> DeleteAction.Builder {
         builderResult.hasDeleteType = false
         builderResult.deleteType = .DeleteTypeUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeleteAction.Builder {
      builderResult = DeleteAction()
      return self
    }
    public override func clone() throws -> DeleteAction.Builder {
      return try DeleteAction.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeleteAction {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeleteAction {
      let returnMe:DeleteAction = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeleteAction) throws -> DeleteAction.Builder {
      if other == DeleteAction() {
       return self
      }
      if other.hasDeleteActionTimestamp {
           deleteActionTimestamp = other.deleteActionTimestamp
      }
      if other.hasDeleteUpperBoundTimestamp {
           deleteUpperBoundTimestamp = other.deleteUpperBoundTimestamp
      }
      if other.hasDeleteType {
           deleteType = other.deleteType
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteAction.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteAction.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          deleteActionTimestamp = try input.readUInt64()

        case 16:
          deleteUpperBoundTimestamp = try input.readUInt64()

        case 24:
          let valueIntdeleteType = try input.readEnum()
          if let enumsdeleteType = DeleteType(rawValue:valueIntdeleteType){
               deleteType = enumsdeleteType
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntdeleteType))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class InviteeId : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var gaiaId:String = ""

  public private(set) var hasGaiaId:Bool = false
  public private(set) var fallbackName:String = ""

  public private(set) var hasFallbackName:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasGaiaId {
      try output.writeString(1, value:gaiaId)
    }
    if hasFallbackName {
      try output.writeString(4, value:fallbackName)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasGaiaId {
      serialize_size += gaiaId.computeStringSize(1)
    }
    if hasFallbackName {
      serialize_size += fallbackName.computeStringSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<InviteeId> {
    var mergedArray = Array<InviteeId>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> InviteeId? {
    return try InviteeId.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> InviteeId {
    return try InviteeId.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> InviteeId.Builder {
    return InviteeId.classBuilder() as! InviteeId.Builder
  }
  public func getBuilder() -> InviteeId.Builder {
    return classBuilder() as! InviteeId.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return InviteeId.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return InviteeId.Builder()
  }
  public func toBuilder() throws -> InviteeId.Builder {
    return try InviteeId.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:InviteeId) throws -> InviteeId.Builder {
    return try InviteeId.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasGaiaId {
      output += "\(indent) gaiaId: \(gaiaId) \n"
    }
    if hasFallbackName {
      output += "\(indent) fallbackName: \(fallbackName) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasGaiaId {
             hashCode = (hashCode &* 31) &+ gaiaId.hashValue
          }
          if hasFallbackName {
             hashCode = (hashCode &* 31) &+ fallbackName.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "InviteeId"
  }
  override public func className() -> String {
      return "InviteeId"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return InviteeId.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:InviteeId = InviteeId()
    public func getMessage() -> InviteeId {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasGaiaId:Bool {
         get {
              return builderResult.hasGaiaId
         }
    }
    public var gaiaId:String {
         get {
              return builderResult.gaiaId
         }
         set (value) {
             builderResult.hasGaiaId = true
             builderResult.gaiaId = value
         }
    }
    public func setGaiaId(_ value:String) -> InviteeId.Builder {
      self.gaiaId = value
      return self
    }
    public func clearGaiaId() -> InviteeId.Builder{
         builderResult.hasGaiaId = false
         builderResult.gaiaId = ""
         return self
    }
    public var hasFallbackName:Bool {
         get {
              return builderResult.hasFallbackName
         }
    }
    public var fallbackName:String {
         get {
              return builderResult.fallbackName
         }
         set (value) {
             builderResult.hasFallbackName = true
             builderResult.fallbackName = value
         }
    }
    public func setFallbackName(_ value:String) -> InviteeId.Builder {
      self.fallbackName = value
      return self
    }
    public func clearFallbackName() -> InviteeId.Builder{
         builderResult.hasFallbackName = false
         builderResult.fallbackName = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> InviteeId.Builder {
      builderResult = InviteeId()
      return self
    }
    public override func clone() throws -> InviteeId.Builder {
      return try InviteeId.builderWithPrototype(builderResult)
    }
    public override func build() throws -> InviteeId {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> InviteeId {
      let returnMe:InviteeId = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:InviteeId) throws -> InviteeId.Builder {
      if other == InviteeId() {
       return self
      }
      if other.hasGaiaId {
           gaiaId = other.gaiaId
      }
      if other.hasFallbackName {
           fallbackName = other.fallbackName
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> InviteeId.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> InviteeId.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          gaiaId = try input.readString()

        case 34:
          fallbackName = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Describes a user's country.
final public class Country : GeneratedMessage, GeneratedMessageProtocol {
  // Abbreviated region code (eg. "CA").
  public private(set) var regionCode:String = ""

  public private(set) var hasRegionCode:Bool = false
  // Country's calling code (eg. "1").
  public private(set) var countryCode:UInt64 = UInt64(0)

  public private(set) var hasCountryCode:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRegionCode {
      try output.writeString(1, value:regionCode)
    }
    if hasCountryCode {
      try output.writeUInt64(2, value:countryCode)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRegionCode {
      serialize_size += regionCode.computeStringSize(1)
    }
    if hasCountryCode {
      serialize_size += countryCode.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Country> {
    var mergedArray = Array<Country>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Country? {
    return try Country.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Country {
    return try Country.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Country {
    return try Country.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Country {
    return try Country.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Country {
    return try Country.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Country {
    return try Country.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Country {
    return try Country.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Country.Builder {
    return Country.classBuilder() as! Country.Builder
  }
  public func getBuilder() -> Country.Builder {
    return classBuilder() as! Country.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Country.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Country.Builder()
  }
  public func toBuilder() throws -> Country.Builder {
    return try Country.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Country) throws -> Country.Builder {
    return try Country.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRegionCode {
      output += "\(indent) regionCode: \(regionCode) \n"
    }
    if hasCountryCode {
      output += "\(indent) countryCode: \(countryCode) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRegionCode {
             hashCode = (hashCode &* 31) &+ regionCode.hashValue
          }
          if hasCountryCode {
             hashCode = (hashCode &* 31) &+ countryCode.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Country"
  }
  override public func className() -> String {
      return "Country"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Country.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Country = Country()
    public func getMessage() -> Country {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRegionCode:Bool {
         get {
              return builderResult.hasRegionCode
         }
    }
    public var regionCode:String {
         get {
              return builderResult.regionCode
         }
         set (value) {
             builderResult.hasRegionCode = true
             builderResult.regionCode = value
         }
    }
    public func setRegionCode(_ value:String) -> Country.Builder {
      self.regionCode = value
      return self
    }
    public func clearRegionCode() -> Country.Builder{
         builderResult.hasRegionCode = false
         builderResult.regionCode = ""
         return self
    }
    public var hasCountryCode:Bool {
         get {
              return builderResult.hasCountryCode
         }
    }
    public var countryCode:UInt64 {
         get {
              return builderResult.countryCode
         }
         set (value) {
             builderResult.hasCountryCode = true
             builderResult.countryCode = value
         }
    }
    public func setCountryCode(_ value:UInt64) -> Country.Builder {
      self.countryCode = value
      return self
    }
    public func clearCountryCode() -> Country.Builder{
         builderResult.hasCountryCode = false
         builderResult.countryCode = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Country.Builder {
      builderResult = Country()
      return self
    }
    public override func clone() throws -> Country.Builder {
      return try Country.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Country {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Country {
      let returnMe:Country = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Country) throws -> Country.Builder {
      if other == Country() {
       return self
      }
      if other.hasRegionCode {
           regionCode = other.regionCode
      }
      if other.hasCountryCode {
           countryCode = other.countryCode
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Country.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Country.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          regionCode = try input.readString()

        case 16:
          countryCode = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Sound settings in the desktop Hangouts client.
final public class DesktopSoundSetting : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var desktopSoundState:SoundState = SoundState.SoundStateUnknown
  public private(set) var hasDesktopSoundState:Bool = false
  public private(set) var desktopRingSoundState:SoundState = SoundState.SoundStateUnknown
  public private(set) var hasDesktopRingSoundState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDesktopSoundState {
      try output.writeEnum(1, value:desktopSoundState.rawValue)
    }
    if hasDesktopRingSoundState {
      try output.writeEnum(2, value:desktopRingSoundState.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasDesktopSoundState) {
      serialize_size += desktopSoundState.rawValue.computeEnumSize(1)
    }
    if (hasDesktopRingSoundState) {
      serialize_size += desktopRingSoundState.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DesktopSoundSetting> {
    var mergedArray = Array<DesktopSoundSetting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DesktopSoundSetting? {
    return try DesktopSoundSetting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopSoundSetting {
    return try DesktopSoundSetting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DesktopSoundSetting.Builder {
    return DesktopSoundSetting.classBuilder() as! DesktopSoundSetting.Builder
  }
  public func getBuilder() -> DesktopSoundSetting.Builder {
    return classBuilder() as! DesktopSoundSetting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DesktopSoundSetting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DesktopSoundSetting.Builder()
  }
  public func toBuilder() throws -> DesktopSoundSetting.Builder {
    return try DesktopSoundSetting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DesktopSoundSetting) throws -> DesktopSoundSetting.Builder {
    return try DesktopSoundSetting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasDesktopSoundState) {
      output += "\(indent) desktopSoundState: \(desktopSoundState.description)\n"
    }
    if (hasDesktopRingSoundState) {
      output += "\(indent) desktopRingSoundState: \(desktopRingSoundState.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDesktopSoundState {
             hashCode = (hashCode &* 31) &+ Int(desktopSoundState.rawValue)
          }
          if hasDesktopRingSoundState {
             hashCode = (hashCode &* 31) &+ Int(desktopRingSoundState.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DesktopSoundSetting"
  }
  override public func className() -> String {
      return "DesktopSoundSetting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DesktopSoundSetting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DesktopSoundSetting = DesktopSoundSetting()
    public func getMessage() -> DesktopSoundSetting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasDesktopSoundState:Bool{
          get {
              return builderResult.hasDesktopSoundState
          }
      }
      public var desktopSoundState:SoundState {
          get {
              return builderResult.desktopSoundState
          }
          set (value) {
              builderResult.hasDesktopSoundState = true
              builderResult.desktopSoundState = value
          }
      }
      public func setDesktopSoundState(_ value:SoundState) -> DesktopSoundSetting.Builder {
        self.desktopSoundState = value
        return self
      }
      public func clearDesktopSoundState() -> DesktopSoundSetting.Builder {
         builderResult.hasDesktopSoundState = false
         builderResult.desktopSoundState = .SoundStateUnknown
         return self
      }
      public var hasDesktopRingSoundState:Bool{
          get {
              return builderResult.hasDesktopRingSoundState
          }
      }
      public var desktopRingSoundState:SoundState {
          get {
              return builderResult.desktopRingSoundState
          }
          set (value) {
              builderResult.hasDesktopRingSoundState = true
              builderResult.desktopRingSoundState = value
          }
      }
      public func setDesktopRingSoundState(_ value:SoundState) -> DesktopSoundSetting.Builder {
        self.desktopRingSoundState = value
        return self
      }
      public func clearDesktopRingSoundState() -> DesktopSoundSetting.Builder {
         builderResult.hasDesktopRingSoundState = false
         builderResult.desktopRingSoundState = .SoundStateUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DesktopSoundSetting.Builder {
      builderResult = DesktopSoundSetting()
      return self
    }
    public override func clone() throws -> DesktopSoundSetting.Builder {
      return try DesktopSoundSetting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DesktopSoundSetting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DesktopSoundSetting {
      let returnMe:DesktopSoundSetting = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DesktopSoundSetting) throws -> DesktopSoundSetting.Builder {
      if other == DesktopSoundSetting() {
       return self
      }
      if other.hasDesktopSoundState {
           desktopSoundState = other.desktopSoundState
      }
      if other.hasDesktopRingSoundState {
           desktopRingSoundState = other.desktopRingSoundState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DesktopSoundSetting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DesktopSoundSetting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntdesktopSoundState = try input.readEnum()
          if let enumsdesktopSoundState = SoundState(rawValue:valueIntdesktopSoundState){
               desktopSoundState = enumsdesktopSoundState
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntdesktopSoundState))
          }

        case 16:
          let valueIntdesktopRingSoundState = try input.readEnum()
          if let enumsdesktopRingSoundState = SoundState(rawValue:valueIntdesktopRingSoundState){
               desktopRingSoundState = enumsdesktopRingSoundState
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntdesktopRingSoundState))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PhoneData : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var phone:Array<Phone>  = Array<Phone>()
  public private(set) var callerIdSettingsMask:CallerIdSettingsMask = CallerIdSettingsMask.CallerIdSettingsMaskUnknown
  public private(set) var hasCallerIdSettingsMask:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementphone in phone {
        try output.writeMessage(1, value:oneElementphone)
    }
    if hasCallerIdSettingsMask {
      try output.writeEnum(3, value:callerIdSettingsMask.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementphone in phone {
        serialize_size += oneElementphone.computeMessageSize(1)
    }
    if (hasCallerIdSettingsMask) {
      serialize_size += callerIdSettingsMask.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PhoneData> {
    var mergedArray = Array<PhoneData>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PhoneData? {
    return try PhoneData.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneData {
    return try PhoneData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PhoneData.Builder {
    return PhoneData.classBuilder() as! PhoneData.Builder
  }
  public func getBuilder() -> PhoneData.Builder {
    return classBuilder() as! PhoneData.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PhoneData.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PhoneData.Builder()
  }
  public func toBuilder() throws -> PhoneData.Builder {
    return try PhoneData.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PhoneData) throws -> PhoneData.Builder {
    return try PhoneData.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var phoneElementIndex:Int = 0
    for oneElementphone in phone {
        output += "\(indent) phone[\(phoneElementIndex)] {\n"
        output += try oneElementphone.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        phoneElementIndex += 1
    }
    if (hasCallerIdSettingsMask) {
      output += "\(indent) callerIdSettingsMask: \(callerIdSettingsMask.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementphone in phone {
              hashCode = (hashCode &* 31) &+ oneElementphone.hashValue
          }
          if hasCallerIdSettingsMask {
             hashCode = (hashCode &* 31) &+ Int(callerIdSettingsMask.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PhoneData"
  }
  override public func className() -> String {
      return "PhoneData"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PhoneData.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PhoneData = PhoneData()
    public func getMessage() -> PhoneData {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var phone:Array<Phone> {
         get {
             return builderResult.phone
         }
         set (value) {
             builderResult.phone = value
         }
    }
    public func setPhone(_ value:Array<Phone>) -> PhoneData.Builder {
      self.phone = value
      return self
    }
    public func clearPhone() -> PhoneData.Builder {
      builderResult.phone.removeAll(keepingCapacity: false)
      return self
    }
      public var hasCallerIdSettingsMask:Bool{
          get {
              return builderResult.hasCallerIdSettingsMask
          }
      }
      public var callerIdSettingsMask:CallerIdSettingsMask {
          get {
              return builderResult.callerIdSettingsMask
          }
          set (value) {
              builderResult.hasCallerIdSettingsMask = true
              builderResult.callerIdSettingsMask = value
          }
      }
      public func setCallerIdSettingsMask(_ value:CallerIdSettingsMask) -> PhoneData.Builder {
        self.callerIdSettingsMask = value
        return self
      }
      public func clearCallerIdSettingsMask() -> PhoneData.Builder {
         builderResult.hasCallerIdSettingsMask = false
         builderResult.callerIdSettingsMask = .CallerIdSettingsMaskUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PhoneData.Builder {
      builderResult = PhoneData()
      return self
    }
    public override func clone() throws -> PhoneData.Builder {
      return try PhoneData.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PhoneData {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PhoneData {
      let returnMe:PhoneData = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PhoneData) throws -> PhoneData.Builder {
      if other == PhoneData() {
       return self
      }
      if !other.phone.isEmpty  {
         builderResult.phone += other.phone
      }
      if other.hasCallerIdSettingsMask {
           callerIdSettingsMask = other.callerIdSettingsMask
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PhoneData.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneData.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = Phone.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          phone += [subBuilder.buildPartial()]

        case 24:
          let valueIntcallerIdSettingsMask = try input.readEnum()
          if let enumscallerIdSettingsMask = CallerIdSettingsMask(rawValue:valueIntcallerIdSettingsMask){
               callerIdSettingsMask = enumscallerIdSettingsMask
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntcallerIdSettingsMask))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Phone : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var phoneNumber:PhoneNumber!
  public private(set) var hasPhoneNumber:Bool = false
  public private(set) var googleVoice:Bool = false

  public private(set) var hasGoogleVoice:Bool = false
  public private(set) var verificationStatus:PhoneVerificationStatus = PhoneVerificationStatus.PhoneVerificationStatusUnknown
  public private(set) var hasVerificationStatus:Bool = false
  public private(set) var discoverable:Bool = false

  public private(set) var hasDiscoverable:Bool = false
  public private(set) var discoverabilityStatus:PhoneDiscoverabilityStatus = PhoneDiscoverabilityStatus.PhoneDiscoverabilityStatusUnknown
  public private(set) var hasDiscoverabilityStatus:Bool = false
  public private(set) var primary:Bool = false

  public private(set) var hasPrimary:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasPhoneNumber {
      try output.writeMessage(1, value:phoneNumber)
    }
    if hasGoogleVoice {
      try output.writeBool(2, value:googleVoice)
    }
    if hasVerificationStatus {
      try output.writeEnum(3, value:verificationStatus.rawValue)
    }
    if hasDiscoverable {
      try output.writeBool(4, value:discoverable)
    }
    if hasDiscoverabilityStatus {
      try output.writeEnum(5, value:discoverabilityStatus.rawValue)
    }
    if hasPrimary {
      try output.writeBool(6, value:primary)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasPhoneNumber {
        if let varSizephoneNumber = phoneNumber?.computeMessageSize(1) {
            serialize_size += varSizephoneNumber
        }
    }
    if hasGoogleVoice {
      serialize_size += googleVoice.computeBoolSize(2)
    }
    if (hasVerificationStatus) {
      serialize_size += verificationStatus.rawValue.computeEnumSize(3)
    }
    if hasDiscoverable {
      serialize_size += discoverable.computeBoolSize(4)
    }
    if (hasDiscoverabilityStatus) {
      serialize_size += discoverabilityStatus.rawValue.computeEnumSize(5)
    }
    if hasPrimary {
      serialize_size += primary.computeBoolSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<Phone> {
    var mergedArray = Array<Phone>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> Phone? {
    return try Phone.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> Phone {
    return try Phone.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> Phone {
    return try Phone.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> Phone {
    return try Phone.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Phone {
    return try Phone.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Phone {
    return try Phone.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Phone {
    return try Phone.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Phone.Builder {
    return Phone.classBuilder() as! Phone.Builder
  }
  public func getBuilder() -> Phone.Builder {
    return classBuilder() as! Phone.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Phone.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Phone.Builder()
  }
  public func toBuilder() throws -> Phone.Builder {
    return try Phone.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:Phone) throws -> Phone.Builder {
    return try Phone.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasPhoneNumber {
      output += "\(indent) phoneNumber {\n"
      if let outDescPhoneNumber = phoneNumber {
        output += try outDescPhoneNumber.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasGoogleVoice {
      output += "\(indent) googleVoice: \(googleVoice) \n"
    }
    if (hasVerificationStatus) {
      output += "\(indent) verificationStatus: \(verificationStatus.description)\n"
    }
    if hasDiscoverable {
      output += "\(indent) discoverable: \(discoverable) \n"
    }
    if (hasDiscoverabilityStatus) {
      output += "\(indent) discoverabilityStatus: \(discoverabilityStatus.description)\n"
    }
    if hasPrimary {
      output += "\(indent) primary: \(primary) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasPhoneNumber {
              if let hashValuephoneNumber = phoneNumber?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuephoneNumber
              }
          }
          if hasGoogleVoice {
             hashCode = (hashCode &* 31) &+ googleVoice.hashValue
          }
          if hasVerificationStatus {
             hashCode = (hashCode &* 31) &+ Int(verificationStatus.rawValue)
          }
          if hasDiscoverable {
             hashCode = (hashCode &* 31) &+ discoverable.hashValue
          }
          if hasDiscoverabilityStatus {
             hashCode = (hashCode &* 31) &+ Int(discoverabilityStatus.rawValue)
          }
          if hasPrimary {
             hashCode = (hashCode &* 31) &+ primary.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Phone"
  }
  override public func className() -> String {
      return "Phone"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Phone.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Phone = Phone()
    public func getMessage() -> Phone {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasPhoneNumber:Bool {
         get {
             return builderResult.hasPhoneNumber
         }
    }
    public var phoneNumber:PhoneNumber! {
         get {
             if phoneNumberBuilder_ != nil {
                builderResult.phoneNumber = phoneNumberBuilder_.getMessage()
             }
             return builderResult.phoneNumber
         }
         set (value) {
             builderResult.hasPhoneNumber = true
             builderResult.phoneNumber = value
         }
    }
    private var phoneNumberBuilder_:PhoneNumber.Builder! {
         didSet {
            builderResult.hasPhoneNumber = true
         }
    }
    public func getPhoneNumberBuilder() -> PhoneNumber.Builder {
      if phoneNumberBuilder_ == nil {
         phoneNumberBuilder_ = PhoneNumber.Builder()
         builderResult.phoneNumber = phoneNumberBuilder_.getMessage()
         if phoneNumber != nil {
            try! phoneNumberBuilder_.mergeFrom(phoneNumber)
         }
      }
      return phoneNumberBuilder_
    }
    public func setPhoneNumber(_ value:PhoneNumber!) -> Phone.Builder {
      self.phoneNumber = value
      return self
    }
    public func mergePhoneNumber(_ value:PhoneNumber) throws -> Phone.Builder {
      if builderResult.hasPhoneNumber {
        builderResult.phoneNumber = try PhoneNumber.builderWithPrototype(builderResult.phoneNumber).mergeFrom(value).buildPartial()
      } else {
        builderResult.phoneNumber = value
      }
      builderResult.hasPhoneNumber = true
      return self
    }
    public func clearPhoneNumber() -> Phone.Builder {
      phoneNumberBuilder_ = nil
      builderResult.hasPhoneNumber = false
      builderResult.phoneNumber = nil
      return self
    }
    public var hasGoogleVoice:Bool {
         get {
              return builderResult.hasGoogleVoice
         }
    }
    public var googleVoice:Bool {
         get {
              return builderResult.googleVoice
         }
         set (value) {
             builderResult.hasGoogleVoice = true
             builderResult.googleVoice = value
         }
    }
    public func setGoogleVoice(_ value:Bool) -> Phone.Builder {
      self.googleVoice = value
      return self
    }
    public func clearGoogleVoice() -> Phone.Builder{
         builderResult.hasGoogleVoice = false
         builderResult.googleVoice = false
         return self
    }
      public var hasVerificationStatus:Bool{
          get {
              return builderResult.hasVerificationStatus
          }
      }
      public var verificationStatus:PhoneVerificationStatus {
          get {
              return builderResult.verificationStatus
          }
          set (value) {
              builderResult.hasVerificationStatus = true
              builderResult.verificationStatus = value
          }
      }
      public func setVerificationStatus(_ value:PhoneVerificationStatus) -> Phone.Builder {
        self.verificationStatus = value
        return self
      }
      public func clearVerificationStatus() -> Phone.Builder {
         builderResult.hasVerificationStatus = false
         builderResult.verificationStatus = .PhoneVerificationStatusUnknown
         return self
      }
    public var hasDiscoverable:Bool {
         get {
              return builderResult.hasDiscoverable
         }
    }
    public var discoverable:Bool {
         get {
              return builderResult.discoverable
         }
         set (value) {
             builderResult.hasDiscoverable = true
             builderResult.discoverable = value
         }
    }
    public func setDiscoverable(_ value:Bool) -> Phone.Builder {
      self.discoverable = value
      return self
    }
    public func clearDiscoverable() -> Phone.Builder{
         builderResult.hasDiscoverable = false
         builderResult.discoverable = false
         return self
    }
      public var hasDiscoverabilityStatus:Bool{
          get {
              return builderResult.hasDiscoverabilityStatus
          }
      }
      public var discoverabilityStatus:PhoneDiscoverabilityStatus {
          get {
              return builderResult.discoverabilityStatus
          }
          set (value) {
              builderResult.hasDiscoverabilityStatus = true
              builderResult.discoverabilityStatus = value
          }
      }
      public func setDiscoverabilityStatus(_ value:PhoneDiscoverabilityStatus) -> Phone.Builder {
        self.discoverabilityStatus = value
        return self
      }
      public func clearDiscoverabilityStatus() -> Phone.Builder {
         builderResult.hasDiscoverabilityStatus = false
         builderResult.discoverabilityStatus = .PhoneDiscoverabilityStatusUnknown
         return self
      }
    public var hasPrimary:Bool {
         get {
              return builderResult.hasPrimary
         }
    }
    public var primary:Bool {
         get {
              return builderResult.primary
         }
         set (value) {
             builderResult.hasPrimary = true
             builderResult.primary = value
         }
    }
    public func setPrimary(_ value:Bool) -> Phone.Builder {
      self.primary = value
      return self
    }
    public func clearPrimary() -> Phone.Builder{
         builderResult.hasPrimary = false
         builderResult.primary = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Phone.Builder {
      builderResult = Phone()
      return self
    }
    public override func clone() throws -> Phone.Builder {
      return try Phone.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Phone {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Phone {
      let returnMe:Phone = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:Phone) throws -> Phone.Builder {
      if other == Phone() {
       return self
      }
      if (other.hasPhoneNumber) {
          try mergePhoneNumber(other.phoneNumber)
      }
      if other.hasGoogleVoice {
           googleVoice = other.googleVoice
      }
      if other.hasVerificationStatus {
           verificationStatus = other.verificationStatus
      }
      if other.hasDiscoverable {
           discoverable = other.discoverable
      }
      if other.hasDiscoverabilityStatus {
           discoverabilityStatus = other.discoverabilityStatus
      }
      if other.hasPrimary {
           primary = other.primary
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Phone.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Phone.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PhoneNumber.Builder = PhoneNumber.Builder()
          if hasPhoneNumber {
            try subBuilder.mergeFrom(phoneNumber)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          phoneNumber = subBuilder.buildPartial()

        case 16:
          googleVoice = try input.readBool()

        case 24:
          let valueIntverificationStatus = try input.readEnum()
          if let enumsverificationStatus = PhoneVerificationStatus(rawValue:valueIntverificationStatus){
               verificationStatus = enumsverificationStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntverificationStatus))
          }

        case 32:
          discoverable = try input.readBool()

        case 40:
          let valueIntdiscoverabilityStatus = try input.readEnum()
          if let enumsdiscoverabilityStatus = PhoneDiscoverabilityStatus(rawValue:valueIntdiscoverabilityStatus){
               discoverabilityStatus = enumsdiscoverabilityStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntdiscoverabilityStatus))
          }

        case 48:
          primary = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class I18NData : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var nationalNumber:String = ""

  public private(set) var hasNationalNumber:Bool = false
  public private(set) var internationalNumber:String = ""

  public private(set) var hasInternationalNumber:Bool = false
  public private(set) var countryCode:UInt64 = UInt64(0)

  public private(set) var hasCountryCode:Bool = false
  public private(set) var regionCode:String = ""

  public private(set) var hasRegionCode:Bool = false
  public private(set) var isValid:Bool = false

  public private(set) var hasIsValid:Bool = false
  public private(set) var validationResult:PhoneValidationResult = PhoneValidationResult.PhoneValidationResultIsPossible
  public private(set) var hasValidationResult:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasNationalNumber {
      try output.writeString(1, value:nationalNumber)
    }
    if hasInternationalNumber {
      try output.writeString(2, value:internationalNumber)
    }
    if hasCountryCode {
      try output.writeUInt64(3, value:countryCode)
    }
    if hasRegionCode {
      try output.writeString(4, value:regionCode)
    }
    if hasIsValid {
      try output.writeBool(5, value:isValid)
    }
    if hasValidationResult {
      try output.writeEnum(6, value:validationResult.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasNationalNumber {
      serialize_size += nationalNumber.computeStringSize(1)
    }
    if hasInternationalNumber {
      serialize_size += internationalNumber.computeStringSize(2)
    }
    if hasCountryCode {
      serialize_size += countryCode.computeUInt64Size(3)
    }
    if hasRegionCode {
      serialize_size += regionCode.computeStringSize(4)
    }
    if hasIsValid {
      serialize_size += isValid.computeBoolSize(5)
    }
    if (hasValidationResult) {
      serialize_size += validationResult.rawValue.computeEnumSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<I18NData> {
    var mergedArray = Array<I18NData>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> I18NData? {
    return try I18NData.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> I18NData {
    return try I18NData.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> I18NData {
    return try I18NData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> I18NData {
    return try I18NData.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> I18NData {
    return try I18NData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> I18NData {
    return try I18NData.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> I18NData {
    return try I18NData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> I18NData.Builder {
    return I18NData.classBuilder() as! I18NData.Builder
  }
  public func getBuilder() -> I18NData.Builder {
    return classBuilder() as! I18NData.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return I18NData.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return I18NData.Builder()
  }
  public func toBuilder() throws -> I18NData.Builder {
    return try I18NData.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:I18NData) throws -> I18NData.Builder {
    return try I18NData.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasNationalNumber {
      output += "\(indent) nationalNumber: \(nationalNumber) \n"
    }
    if hasInternationalNumber {
      output += "\(indent) internationalNumber: \(internationalNumber) \n"
    }
    if hasCountryCode {
      output += "\(indent) countryCode: \(countryCode) \n"
    }
    if hasRegionCode {
      output += "\(indent) regionCode: \(regionCode) \n"
    }
    if hasIsValid {
      output += "\(indent) isValid: \(isValid) \n"
    }
    if (hasValidationResult) {
      output += "\(indent) validationResult: \(validationResult.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasNationalNumber {
             hashCode = (hashCode &* 31) &+ nationalNumber.hashValue
          }
          if hasInternationalNumber {
             hashCode = (hashCode &* 31) &+ internationalNumber.hashValue
          }
          if hasCountryCode {
             hashCode = (hashCode &* 31) &+ countryCode.hashValue
          }
          if hasRegionCode {
             hashCode = (hashCode &* 31) &+ regionCode.hashValue
          }
          if hasIsValid {
             hashCode = (hashCode &* 31) &+ isValid.hashValue
          }
          if hasValidationResult {
             hashCode = (hashCode &* 31) &+ Int(validationResult.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "I18NData"
  }
  override public func className() -> String {
      return "I18NData"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return I18NData.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:I18NData = I18NData()
    public func getMessage() -> I18NData {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasNationalNumber:Bool {
         get {
              return builderResult.hasNationalNumber
         }
    }
    public var nationalNumber:String {
         get {
              return builderResult.nationalNumber
         }
         set (value) {
             builderResult.hasNationalNumber = true
             builderResult.nationalNumber = value
         }
    }
    public func setNationalNumber(_ value:String) -> I18NData.Builder {
      self.nationalNumber = value
      return self
    }
    public func clearNationalNumber() -> I18NData.Builder{
         builderResult.hasNationalNumber = false
         builderResult.nationalNumber = ""
         return self
    }
    public var hasInternationalNumber:Bool {
         get {
              return builderResult.hasInternationalNumber
         }
    }
    public var internationalNumber:String {
         get {
              return builderResult.internationalNumber
         }
         set (value) {
             builderResult.hasInternationalNumber = true
             builderResult.internationalNumber = value
         }
    }
    public func setInternationalNumber(_ value:String) -> I18NData.Builder {
      self.internationalNumber = value
      return self
    }
    public func clearInternationalNumber() -> I18NData.Builder{
         builderResult.hasInternationalNumber = false
         builderResult.internationalNumber = ""
         return self
    }
    public var hasCountryCode:Bool {
         get {
              return builderResult.hasCountryCode
         }
    }
    public var countryCode:UInt64 {
         get {
              return builderResult.countryCode
         }
         set (value) {
             builderResult.hasCountryCode = true
             builderResult.countryCode = value
         }
    }
    public func setCountryCode(_ value:UInt64) -> I18NData.Builder {
      self.countryCode = value
      return self
    }
    public func clearCountryCode() -> I18NData.Builder{
         builderResult.hasCountryCode = false
         builderResult.countryCode = UInt64(0)
         return self
    }
    public var hasRegionCode:Bool {
         get {
              return builderResult.hasRegionCode
         }
    }
    public var regionCode:String {
         get {
              return builderResult.regionCode
         }
         set (value) {
             builderResult.hasRegionCode = true
             builderResult.regionCode = value
         }
    }
    public func setRegionCode(_ value:String) -> I18NData.Builder {
      self.regionCode = value
      return self
    }
    public func clearRegionCode() -> I18NData.Builder{
         builderResult.hasRegionCode = false
         builderResult.regionCode = ""
         return self
    }
    public var hasIsValid:Bool {
         get {
              return builderResult.hasIsValid
         }
    }
    public var isValid:Bool {
         get {
              return builderResult.isValid
         }
         set (value) {
             builderResult.hasIsValid = true
             builderResult.isValid = value
         }
    }
    public func setIsValid(_ value:Bool) -> I18NData.Builder {
      self.isValid = value
      return self
    }
    public func clearIsValid() -> I18NData.Builder{
         builderResult.hasIsValid = false
         builderResult.isValid = false
         return self
    }
      public var hasValidationResult:Bool{
          get {
              return builderResult.hasValidationResult
          }
      }
      public var validationResult:PhoneValidationResult {
          get {
              return builderResult.validationResult
          }
          set (value) {
              builderResult.hasValidationResult = true
              builderResult.validationResult = value
          }
      }
      public func setValidationResult(_ value:PhoneValidationResult) -> I18NData.Builder {
        self.validationResult = value
        return self
      }
      public func clearValidationResult() -> I18NData.Builder {
         builderResult.hasValidationResult = false
         builderResult.validationResult = .PhoneValidationResultIsPossible
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> I18NData.Builder {
      builderResult = I18NData()
      return self
    }
    public override func clone() throws -> I18NData.Builder {
      return try I18NData.builderWithPrototype(builderResult)
    }
    public override func build() throws -> I18NData {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> I18NData {
      let returnMe:I18NData = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:I18NData) throws -> I18NData.Builder {
      if other == I18NData() {
       return self
      }
      if other.hasNationalNumber {
           nationalNumber = other.nationalNumber
      }
      if other.hasInternationalNumber {
           internationalNumber = other.internationalNumber
      }
      if other.hasCountryCode {
           countryCode = other.countryCode
      }
      if other.hasRegionCode {
           regionCode = other.regionCode
      }
      if other.hasIsValid {
           isValid = other.isValid
      }
      if other.hasValidationResult {
           validationResult = other.validationResult
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> I18NData.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> I18NData.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          nationalNumber = try input.readString()

        case 18:
          internationalNumber = try input.readString()

        case 24:
          countryCode = try input.readUInt64()

        case 34:
          regionCode = try input.readString()

        case 40:
          isValid = try input.readBool()

        case 48:
          let valueIntvalidationResult = try input.readEnum()
          if let enumsvalidationResult = PhoneValidationResult(rawValue:valueIntvalidationResult){
               validationResult = enumsvalidationResult
          } else {
               try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntvalidationResult))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PhoneNumber : GeneratedMessage, GeneratedMessageProtocol {
  // Phone number as string (eg. "+15551234567").
  public private(set) var e164:String = ""

  public private(set) var hasE164:Bool = false
  public private(set) var i18NData:I18NData!
  public private(set) var hasI18NData:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasE164 {
      try output.writeString(1, value:e164)
    }
    if hasI18NData {
      try output.writeMessage(2, value:i18NData)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasE164 {
      serialize_size += e164.computeStringSize(1)
    }
    if hasI18NData {
        if let varSizei18NData = i18NData?.computeMessageSize(2) {
            serialize_size += varSizei18NData
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PhoneNumber> {
    var mergedArray = Array<PhoneNumber>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PhoneNumber? {
    return try PhoneNumber.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneNumber {
    return try PhoneNumber.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PhoneNumber.Builder {
    return PhoneNumber.classBuilder() as! PhoneNumber.Builder
  }
  public func getBuilder() -> PhoneNumber.Builder {
    return classBuilder() as! PhoneNumber.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PhoneNumber.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PhoneNumber.Builder()
  }
  public func toBuilder() throws -> PhoneNumber.Builder {
    return try PhoneNumber.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PhoneNumber) throws -> PhoneNumber.Builder {
    return try PhoneNumber.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasE164 {
      output += "\(indent) e164: \(e164) \n"
    }
    if hasI18NData {
      output += "\(indent) i18NData {\n"
      if let outDescI18NData = i18NData {
        output += try outDescI18NData.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasE164 {
             hashCode = (hashCode &* 31) &+ e164.hashValue
          }
          if hasI18NData {
              if let hashValuei18NData = i18NData?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuei18NData
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PhoneNumber"
  }
  override public func className() -> String {
      return "PhoneNumber"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PhoneNumber.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PhoneNumber = PhoneNumber()
    public func getMessage() -> PhoneNumber {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasE164:Bool {
         get {
              return builderResult.hasE164
         }
    }
    public var e164:String {
         get {
              return builderResult.e164
         }
         set (value) {
             builderResult.hasE164 = true
             builderResult.e164 = value
         }
    }
    public func setE164(_ value:String) -> PhoneNumber.Builder {
      self.e164 = value
      return self
    }
    public func clearE164() -> PhoneNumber.Builder{
         builderResult.hasE164 = false
         builderResult.e164 = ""
         return self
    }
    public var hasI18NData:Bool {
         get {
             return builderResult.hasI18NData
         }
    }
    public var i18NData:I18NData! {
         get {
             if i18NDataBuilder_ != nil {
                builderResult.i18NData = i18NDataBuilder_.getMessage()
             }
             return builderResult.i18NData
         }
         set (value) {
             builderResult.hasI18NData = true
             builderResult.i18NData = value
         }
    }
    private var i18NDataBuilder_:I18NData.Builder! {
         didSet {
            builderResult.hasI18NData = true
         }
    }
    public func getI18NDataBuilder() -> I18NData.Builder {
      if i18NDataBuilder_ == nil {
         i18NDataBuilder_ = I18NData.Builder()
         builderResult.i18NData = i18NDataBuilder_.getMessage()
         if i18NData != nil {
            try! i18NDataBuilder_.mergeFrom(i18NData)
         }
      }
      return i18NDataBuilder_
    }
    public func setI18NData(_ value:I18NData!) -> PhoneNumber.Builder {
      self.i18NData = value
      return self
    }
    public func mergeI18NData(_ value:I18NData) throws -> PhoneNumber.Builder {
      if builderResult.hasI18NData {
        builderResult.i18NData = try I18NData.builderWithPrototype(builderResult.i18NData).mergeFrom(value).buildPartial()
      } else {
        builderResult.i18NData = value
      }
      builderResult.hasI18NData = true
      return self
    }
    public func clearI18NData() -> PhoneNumber.Builder {
      i18NDataBuilder_ = nil
      builderResult.hasI18NData = false
      builderResult.i18NData = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PhoneNumber.Builder {
      builderResult = PhoneNumber()
      return self
    }
    public override func clone() throws -> PhoneNumber.Builder {
      return try PhoneNumber.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PhoneNumber {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PhoneNumber {
      let returnMe:PhoneNumber = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PhoneNumber) throws -> PhoneNumber.Builder {
      if other == PhoneNumber() {
       return self
      }
      if other.hasE164 {
           e164 = other.e164
      }
      if (other.hasI18NData) {
          try mergeI18NData(other.i18NData)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PhoneNumber.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PhoneNumber.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          e164 = try input.readString()

        case 18:
          let subBuilder:I18NData.Builder = I18NData.Builder()
          if hasI18NData {
            try subBuilder.mergeFrom(i18NData)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          i18NData = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SuggestedContactGroupHash : GeneratedMessage, GeneratedMessageProtocol {
  // Number of results to return from this group.
  public private(set) var maxResults:UInt64 = UInt64(0)

  public private(set) var hasMaxResults:Bool = false
  // An optional 4-byte hash. If this matches the server's hash, no results
  // will be sent.
  public private(set) var hash:NSData = NSData()

  public private(set) var hasHash:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasMaxResults {
      try output.writeUInt64(1, value:maxResults)
    }
    if hasHash {
      try output.writeData(2, value:hash)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMaxResults {
      serialize_size += maxResults.computeUInt64Size(1)
    }
    if hasHash {
      serialize_size += hash.computeDataSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SuggestedContactGroupHash> {
    var mergedArray = Array<SuggestedContactGroupHash>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SuggestedContactGroupHash? {
    return try SuggestedContactGroupHash.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroupHash {
    return try SuggestedContactGroupHash.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SuggestedContactGroupHash.Builder {
    return SuggestedContactGroupHash.classBuilder() as! SuggestedContactGroupHash.Builder
  }
  public func getBuilder() -> SuggestedContactGroupHash.Builder {
    return classBuilder() as! SuggestedContactGroupHash.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SuggestedContactGroupHash.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SuggestedContactGroupHash.Builder()
  }
  public func toBuilder() throws -> SuggestedContactGroupHash.Builder {
    return try SuggestedContactGroupHash.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SuggestedContactGroupHash) throws -> SuggestedContactGroupHash.Builder {
    return try SuggestedContactGroupHash.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasMaxResults {
      output += "\(indent) maxResults: \(maxResults) \n"
    }
    if hasHash {
      output += "\(indent) hash: \(hash) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMaxResults {
             hashCode = (hashCode &* 31) &+ maxResults.hashValue
          }
          if hasHash {
             hashCode = (hashCode &* 31) &+ hash.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SuggestedContactGroupHash"
  }
  override public func className() -> String {
      return "SuggestedContactGroupHash"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SuggestedContactGroupHash.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SuggestedContactGroupHash = SuggestedContactGroupHash()
    public func getMessage() -> SuggestedContactGroupHash {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMaxResults:Bool {
         get {
              return builderResult.hasMaxResults
         }
    }
    public var maxResults:UInt64 {
         get {
              return builderResult.maxResults
         }
         set (value) {
             builderResult.hasMaxResults = true
             builderResult.maxResults = value
         }
    }
    public func setMaxResults(_ value:UInt64) -> SuggestedContactGroupHash.Builder {
      self.maxResults = value
      return self
    }
    public func clearMaxResults() -> SuggestedContactGroupHash.Builder{
         builderResult.hasMaxResults = false
         builderResult.maxResults = UInt64(0)
         return self
    }
    public var hasHash:Bool {
         get {
              return builderResult.hasHash
         }
    }
    public var hash:NSData {
         get {
              return builderResult.hash
         }
         set (value) {
             builderResult.hasHash = true
             builderResult.hash = value
         }
    }
    public func setHash(_ value:NSData) -> SuggestedContactGroupHash.Builder {
      self.hash = value
      return self
    }
    public func clearHash() -> SuggestedContactGroupHash.Builder{
         builderResult.hasHash = false
         builderResult.hash = NSData()
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SuggestedContactGroupHash.Builder {
      builderResult = SuggestedContactGroupHash()
      return self
    }
    public override func clone() throws -> SuggestedContactGroupHash.Builder {
      return try SuggestedContactGroupHash.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SuggestedContactGroupHash {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SuggestedContactGroupHash {
      let returnMe:SuggestedContactGroupHash = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SuggestedContactGroupHash) throws -> SuggestedContactGroupHash.Builder {
      if other == SuggestedContactGroupHash() {
       return self
      }
      if other.hasMaxResults {
           maxResults = other.maxResults
      }
      if other.hasHash {
           hash = other.hash
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContactGroupHash.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroupHash.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          maxResults = try input.readUInt64()

        case 18:
          hash = try input.readData()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SuggestedContact : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var entity:Entity!
  public private(set) var hasEntity:Bool = false
  public private(set) var invitationStatus:InvitationStatus = InvitationStatus.InvitationStatusUnknown
  public private(set) var hasInvitationStatus:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasEntity {
     if !entity.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEntity {
      try output.writeMessage(1, value:entity)
    }
    if hasInvitationStatus {
      try output.writeEnum(2, value:invitationStatus.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEntity {
        if let varSizeentity = entity?.computeMessageSize(1) {
            serialize_size += varSizeentity
        }
    }
    if (hasInvitationStatus) {
      serialize_size += invitationStatus.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SuggestedContact> {
    var mergedArray = Array<SuggestedContact>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SuggestedContact? {
    return try SuggestedContact.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContact {
    return try SuggestedContact.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SuggestedContact.Builder {
    return SuggestedContact.classBuilder() as! SuggestedContact.Builder
  }
  public func getBuilder() -> SuggestedContact.Builder {
    return classBuilder() as! SuggestedContact.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SuggestedContact.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SuggestedContact.Builder()
  }
  public func toBuilder() throws -> SuggestedContact.Builder {
    return try SuggestedContact.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SuggestedContact) throws -> SuggestedContact.Builder {
    return try SuggestedContact.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasEntity {
      output += "\(indent) entity {\n"
      if let outDescEntity = entity {
        output += try outDescEntity.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasInvitationStatus) {
      output += "\(indent) invitationStatus: \(invitationStatus.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEntity {
              if let hashValueentity = entity?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueentity
              }
          }
          if hasInvitationStatus {
             hashCode = (hashCode &* 31) &+ Int(invitationStatus.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SuggestedContact"
  }
  override public func className() -> String {
      return "SuggestedContact"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SuggestedContact.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SuggestedContact = SuggestedContact()
    public func getMessage() -> SuggestedContact {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEntity:Bool {
         get {
             return builderResult.hasEntity
         }
    }
    public var entity:Entity! {
         get {
             if entityBuilder_ != nil {
                builderResult.entity = entityBuilder_.getMessage()
             }
             return builderResult.entity
         }
         set (value) {
             builderResult.hasEntity = true
             builderResult.entity = value
         }
    }
    private var entityBuilder_:Entity.Builder! {
         didSet {
            builderResult.hasEntity = true
         }
    }
    public func getEntityBuilder() -> Entity.Builder {
      if entityBuilder_ == nil {
         entityBuilder_ = Entity.Builder()
         builderResult.entity = entityBuilder_.getMessage()
         if entity != nil {
            try! entityBuilder_.mergeFrom(entity)
         }
      }
      return entityBuilder_
    }
    public func setEntity(_ value:Entity!) -> SuggestedContact.Builder {
      self.entity = value
      return self
    }
    public func mergeEntity(_ value:Entity) throws -> SuggestedContact.Builder {
      if builderResult.hasEntity {
        builderResult.entity = try Entity.builderWithPrototype(builderResult.entity).mergeFrom(value).buildPartial()
      } else {
        builderResult.entity = value
      }
      builderResult.hasEntity = true
      return self
    }
    public func clearEntity() -> SuggestedContact.Builder {
      entityBuilder_ = nil
      builderResult.hasEntity = false
      builderResult.entity = nil
      return self
    }
      public var hasInvitationStatus:Bool{
          get {
              return builderResult.hasInvitationStatus
          }
      }
      public var invitationStatus:InvitationStatus {
          get {
              return builderResult.invitationStatus
          }
          set (value) {
              builderResult.hasInvitationStatus = true
              builderResult.invitationStatus = value
          }
      }
      public func setInvitationStatus(_ value:InvitationStatus) -> SuggestedContact.Builder {
        self.invitationStatus = value
        return self
      }
      public func clearInvitationStatus() -> SuggestedContact.Builder {
         builderResult.hasInvitationStatus = false
         builderResult.invitationStatus = .InvitationStatusUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SuggestedContact.Builder {
      builderResult = SuggestedContact()
      return self
    }
    public override func clone() throws -> SuggestedContact.Builder {
      return try SuggestedContact.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SuggestedContact {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SuggestedContact {
      let returnMe:SuggestedContact = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SuggestedContact) throws -> SuggestedContact.Builder {
      if other == SuggestedContact() {
       return self
      }
      if (other.hasEntity) {
          try mergeEntity(other.entity)
      }
      if other.hasInvitationStatus {
           invitationStatus = other.invitationStatus
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContact.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContact.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:Entity.Builder = Entity.Builder()
          if hasEntity {
            try subBuilder.mergeFrom(entity)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          entity = subBuilder.buildPartial()

        case 16:
          let valueIntinvitationStatus = try input.readEnum()
          if let enumsinvitationStatus = InvitationStatus(rawValue:valueIntinvitationStatus){
               invitationStatus = enumsinvitationStatus
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntinvitationStatus))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SuggestedContactGroup : GeneratedMessage, GeneratedMessageProtocol {
  // True if the request's hash matched and no contacts will be included.
  public private(set) var hashMatched:Bool = false

  public private(set) var hasHashMatched:Bool = false
  // A 4-byte hash which can be used in subsequent requests.
  public private(set) var hash:NSData = NSData()

  public private(set) var hasHash:Bool = false
  public private(set) var contact:Array<SuggestedContact>  = Array<SuggestedContact>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitcontact:Bool = true
    for oneElementcontact in contact {
        if (!oneElementcontact.isInitialized()) {
            isInitcontact = false
            break 
        }
    }
    if !isInitcontact {
     return isInitcontact
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasHashMatched {
      try output.writeBool(1, value:hashMatched)
    }
    if hasHash {
      try output.writeData(2, value:hash)
    }
    for oneElementcontact in contact {
        try output.writeMessage(3, value:oneElementcontact)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasHashMatched {
      serialize_size += hashMatched.computeBoolSize(1)
    }
    if hasHash {
      serialize_size += hash.computeDataSize(2)
    }
    for oneElementcontact in contact {
        serialize_size += oneElementcontact.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SuggestedContactGroup> {
    var mergedArray = Array<SuggestedContactGroup>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SuggestedContactGroup? {
    return try SuggestedContactGroup.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroup {
    return try SuggestedContactGroup.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SuggestedContactGroup.Builder {
    return SuggestedContactGroup.classBuilder() as! SuggestedContactGroup.Builder
  }
  public func getBuilder() -> SuggestedContactGroup.Builder {
    return classBuilder() as! SuggestedContactGroup.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SuggestedContactGroup.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SuggestedContactGroup.Builder()
  }
  public func toBuilder() throws -> SuggestedContactGroup.Builder {
    return try SuggestedContactGroup.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SuggestedContactGroup) throws -> SuggestedContactGroup.Builder {
    return try SuggestedContactGroup.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasHashMatched {
      output += "\(indent) hashMatched: \(hashMatched) \n"
    }
    if hasHash {
      output += "\(indent) hash: \(hash) \n"
    }
    var contactElementIndex:Int = 0
    for oneElementcontact in contact {
        output += "\(indent) contact[\(contactElementIndex)] {\n"
        output += try oneElementcontact.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        contactElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasHashMatched {
             hashCode = (hashCode &* 31) &+ hashMatched.hashValue
          }
          if hasHash {
             hashCode = (hashCode &* 31) &+ hash.hashValue
          }
          for oneElementcontact in contact {
              hashCode = (hashCode &* 31) &+ oneElementcontact.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SuggestedContactGroup"
  }
  override public func className() -> String {
      return "SuggestedContactGroup"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SuggestedContactGroup.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SuggestedContactGroup = SuggestedContactGroup()
    public func getMessage() -> SuggestedContactGroup {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasHashMatched:Bool {
         get {
              return builderResult.hasHashMatched
         }
    }
    public var hashMatched:Bool {
         get {
              return builderResult.hashMatched
         }
         set (value) {
             builderResult.hasHashMatched = true
             builderResult.hashMatched = value
         }
    }
    public func setHashMatched(_ value:Bool) -> SuggestedContactGroup.Builder {
      self.hashMatched = value
      return self
    }
    public func clearHashMatched() -> SuggestedContactGroup.Builder{
         builderResult.hasHashMatched = false
         builderResult.hashMatched = false
         return self
    }
    public var hasHash:Bool {
         get {
              return builderResult.hasHash
         }
    }
    public var hash:NSData {
         get {
              return builderResult.hash
         }
         set (value) {
             builderResult.hasHash = true
             builderResult.hash = value
         }
    }
    public func setHash(_ value:NSData) -> SuggestedContactGroup.Builder {
      self.hash = value
      return self
    }
    public func clearHash() -> SuggestedContactGroup.Builder{
         builderResult.hasHash = false
         builderResult.hash = NSData()
         return self
    }
    public var contact:Array<SuggestedContact> {
         get {
             return builderResult.contact
         }
         set (value) {
             builderResult.contact = value
         }
    }
    public func setContact(_ value:Array<SuggestedContact>) -> SuggestedContactGroup.Builder {
      self.contact = value
      return self
    }
    public func clearContact() -> SuggestedContactGroup.Builder {
      builderResult.contact.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SuggestedContactGroup.Builder {
      builderResult = SuggestedContactGroup()
      return self
    }
    public override func clone() throws -> SuggestedContactGroup.Builder {
      return try SuggestedContactGroup.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SuggestedContactGroup {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SuggestedContactGroup {
      let returnMe:SuggestedContactGroup = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SuggestedContactGroup) throws -> SuggestedContactGroup.Builder {
      if other == SuggestedContactGroup() {
       return self
      }
      if other.hasHashMatched {
           hashMatched = other.hashMatched
      }
      if other.hasHash {
           hash = other.hash
      }
      if !other.contact.isEmpty  {
         builderResult.contact += other.contact
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SuggestedContactGroup.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SuggestedContactGroup.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          hashMatched = try input.readBool()

        case 18:
          hash = try input.readData()

        case 26:
          let subBuilder = SuggestedContact.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          contact += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Pushed from the server to the client to notify it of state changes. Includes
// exactly one type of notification, and optionally updates the attributes of a
// conversation.
final public class StateUpdate : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var stateUpdateHeader:StateUpdateHeader!
  public private(set) var hasStateUpdateHeader:Bool = false
  public private(set) var conversation:Conversation!
  public private(set) var hasConversation:Bool = false
  public private(set) var conversationNotification:ConversationNotification!
  public private(set) var hasConversationNotification:Bool = false
  public private(set) var eventNotification:EventNotification!
  public private(set) var hasEventNotification:Bool = false
  public private(set) var focusNotification:SetFocusNotification!
  public private(set) var hasFocusNotification:Bool = false
  public private(set) var typingNotification:SetTypingNotification!
  public private(set) var hasTypingNotification:Bool = false
  public private(set) var notificationLevelNotification:SetConversationNotificationLevelNotification!
  public private(set) var hasNotificationLevelNotification:Bool = false
  public private(set) var replyToInviteNotification:ReplyToInviteNotification!
  public private(set) var hasReplyToInviteNotification:Bool = false
  public private(set) var watermarkNotification:WatermarkNotification!
  public private(set) var hasWatermarkNotification:Bool = false
  public private(set) var viewModification:ConversationViewModification!
  public private(set) var hasViewModification:Bool = false
  public private(set) var easterEggNotification:EasterEggNotification!
  public private(set) var hasEasterEggNotification:Bool = false
  public private(set) var selfPresenceNotification:SelfPresenceNotification!
  public private(set) var hasSelfPresenceNotification:Bool = false
  public private(set) var deleteNotification:DeleteActionNotification!
  public private(set) var hasDeleteNotification:Bool = false
  public private(set) var presenceNotification:PresenceNotification!
  public private(set) var hasPresenceNotification:Bool = false
  public private(set) var blockNotification:BlockNotification!
  public private(set) var hasBlockNotification:Bool = false
  public private(set) var notificationSettingNotification:SetNotificationSettingNotification!
  public private(set) var hasNotificationSettingNotification:Bool = false
  public private(set) var richPresenceEnabledStateNotification:RichPresenceEnabledStateNotification!
  public private(set) var hasRichPresenceEnabledStateNotification:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasEventNotification {
     if !eventNotification.isInitialized() {
       return false
     }
    }
    if hasSelfPresenceNotification {
     if !selfPresenceNotification.isInitialized() {
       return false
     }
    }
    if hasPresenceNotification {
     if !presenceNotification.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasStateUpdateHeader {
      try output.writeMessage(1, value:stateUpdateHeader)
    }
    if hasConversationNotification {
      try output.writeMessage(2, value:conversationNotification)
    }
    if hasEventNotification {
      try output.writeMessage(3, value:eventNotification)
    }
    if hasFocusNotification {
      try output.writeMessage(4, value:focusNotification)
    }
    if hasTypingNotification {
      try output.writeMessage(5, value:typingNotification)
    }
    if hasNotificationLevelNotification {
      try output.writeMessage(6, value:notificationLevelNotification)
    }
    if hasReplyToInviteNotification {
      try output.writeMessage(7, value:replyToInviteNotification)
    }
    if hasWatermarkNotification {
      try output.writeMessage(8, value:watermarkNotification)
    }
    if hasViewModification {
      try output.writeMessage(11, value:viewModification)
    }
    if hasEasterEggNotification {
      try output.writeMessage(12, value:easterEggNotification)
    }
    if hasConversation {
      try output.writeMessage(13, value:conversation)
    }
    if hasSelfPresenceNotification {
      try output.writeMessage(14, value:selfPresenceNotification)
    }
    if hasDeleteNotification {
      try output.writeMessage(15, value:deleteNotification)
    }
    if hasPresenceNotification {
      try output.writeMessage(16, value:presenceNotification)
    }
    if hasBlockNotification {
      try output.writeMessage(17, value:blockNotification)
    }
    if hasNotificationSettingNotification {
      try output.writeMessage(19, value:notificationSettingNotification)
    }
    if hasRichPresenceEnabledStateNotification {
      try output.writeMessage(20, value:richPresenceEnabledStateNotification)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStateUpdateHeader {
        if let varSizestateUpdateHeader = stateUpdateHeader?.computeMessageSize(1) {
            serialize_size += varSizestateUpdateHeader
        }
    }
    if hasConversationNotification {
        if let varSizeconversationNotification = conversationNotification?.computeMessageSize(2) {
            serialize_size += varSizeconversationNotification
        }
    }
    if hasEventNotification {
        if let varSizeeventNotification = eventNotification?.computeMessageSize(3) {
            serialize_size += varSizeeventNotification
        }
    }
    if hasFocusNotification {
        if let varSizefocusNotification = focusNotification?.computeMessageSize(4) {
            serialize_size += varSizefocusNotification
        }
    }
    if hasTypingNotification {
        if let varSizetypingNotification = typingNotification?.computeMessageSize(5) {
            serialize_size += varSizetypingNotification
        }
    }
    if hasNotificationLevelNotification {
        if let varSizenotificationLevelNotification = notificationLevelNotification?.computeMessageSize(6) {
            serialize_size += varSizenotificationLevelNotification
        }
    }
    if hasReplyToInviteNotification {
        if let varSizereplyToInviteNotification = replyToInviteNotification?.computeMessageSize(7) {
            serialize_size += varSizereplyToInviteNotification
        }
    }
    if hasWatermarkNotification {
        if let varSizewatermarkNotification = watermarkNotification?.computeMessageSize(8) {
            serialize_size += varSizewatermarkNotification
        }
    }
    if hasViewModification {
        if let varSizeviewModification = viewModification?.computeMessageSize(11) {
            serialize_size += varSizeviewModification
        }
    }
    if hasEasterEggNotification {
        if let varSizeeasterEggNotification = easterEggNotification?.computeMessageSize(12) {
            serialize_size += varSizeeasterEggNotification
        }
    }
    if hasConversation {
        if let varSizeconversation = conversation?.computeMessageSize(13) {
            serialize_size += varSizeconversation
        }
    }
    if hasSelfPresenceNotification {
        if let varSizeselfPresenceNotification = selfPresenceNotification?.computeMessageSize(14) {
            serialize_size += varSizeselfPresenceNotification
        }
    }
    if hasDeleteNotification {
        if let varSizedeleteNotification = deleteNotification?.computeMessageSize(15) {
            serialize_size += varSizedeleteNotification
        }
    }
    if hasPresenceNotification {
        if let varSizepresenceNotification = presenceNotification?.computeMessageSize(16) {
            serialize_size += varSizepresenceNotification
        }
    }
    if hasBlockNotification {
        if let varSizeblockNotification = blockNotification?.computeMessageSize(17) {
            serialize_size += varSizeblockNotification
        }
    }
    if hasNotificationSettingNotification {
        if let varSizenotificationSettingNotification = notificationSettingNotification?.computeMessageSize(19) {
            serialize_size += varSizenotificationSettingNotification
        }
    }
    if hasRichPresenceEnabledStateNotification {
        if let varSizerichPresenceEnabledStateNotification = richPresenceEnabledStateNotification?.computeMessageSize(20) {
            serialize_size += varSizerichPresenceEnabledStateNotification
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<StateUpdate> {
    var mergedArray = Array<StateUpdate>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> StateUpdate? {
    return try StateUpdate.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdate {
    return try StateUpdate.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> StateUpdate.Builder {
    return StateUpdate.classBuilder() as! StateUpdate.Builder
  }
  public func getBuilder() -> StateUpdate.Builder {
    return classBuilder() as! StateUpdate.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return StateUpdate.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return StateUpdate.Builder()
  }
  public func toBuilder() throws -> StateUpdate.Builder {
    return try StateUpdate.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:StateUpdate) throws -> StateUpdate.Builder {
    return try StateUpdate.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasStateUpdateHeader {
      output += "\(indent) stateUpdateHeader {\n"
      if let outDescStateUpdateHeader = stateUpdateHeader {
        output += try outDescStateUpdateHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationNotification {
      output += "\(indent) conversationNotification {\n"
      if let outDescConversationNotification = conversationNotification {
        output += try outDescConversationNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEventNotification {
      output += "\(indent) eventNotification {\n"
      if let outDescEventNotification = eventNotification {
        output += try outDescEventNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasFocusNotification {
      output += "\(indent) focusNotification {\n"
      if let outDescFocusNotification = focusNotification {
        output += try outDescFocusNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTypingNotification {
      output += "\(indent) typingNotification {\n"
      if let outDescTypingNotification = typingNotification {
        output += try outDescTypingNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNotificationLevelNotification {
      output += "\(indent) notificationLevelNotification {\n"
      if let outDescNotificationLevelNotification = notificationLevelNotification {
        output += try outDescNotificationLevelNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasReplyToInviteNotification {
      output += "\(indent) replyToInviteNotification {\n"
      if let outDescReplyToInviteNotification = replyToInviteNotification {
        output += try outDescReplyToInviteNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasWatermarkNotification {
      output += "\(indent) watermarkNotification {\n"
      if let outDescWatermarkNotification = watermarkNotification {
        output += try outDescWatermarkNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasViewModification {
      output += "\(indent) viewModification {\n"
      if let outDescViewModification = viewModification {
        output += try outDescViewModification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEasterEggNotification {
      output += "\(indent) easterEggNotification {\n"
      if let outDescEasterEggNotification = easterEggNotification {
        output += try outDescEasterEggNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversation {
      output += "\(indent) conversation {\n"
      if let outDescConversation = conversation {
        output += try outDescConversation.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSelfPresenceNotification {
      output += "\(indent) selfPresenceNotification {\n"
      if let outDescSelfPresenceNotification = selfPresenceNotification {
        output += try outDescSelfPresenceNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDeleteNotification {
      output += "\(indent) deleteNotification {\n"
      if let outDescDeleteNotification = deleteNotification {
        output += try outDescDeleteNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPresenceNotification {
      output += "\(indent) presenceNotification {\n"
      if let outDescPresenceNotification = presenceNotification {
        output += try outDescPresenceNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasBlockNotification {
      output += "\(indent) blockNotification {\n"
      if let outDescBlockNotification = blockNotification {
        output += try outDescBlockNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNotificationSettingNotification {
      output += "\(indent) notificationSettingNotification {\n"
      if let outDescNotificationSettingNotification = notificationSettingNotification {
        output += try outDescNotificationSettingNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasRichPresenceEnabledStateNotification {
      output += "\(indent) richPresenceEnabledStateNotification {\n"
      if let outDescRichPresenceEnabledStateNotification = richPresenceEnabledStateNotification {
        output += try outDescRichPresenceEnabledStateNotification.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStateUpdateHeader {
              if let hashValuestateUpdateHeader = stateUpdateHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestateUpdateHeader
              }
          }
          if hasConversationNotification {
              if let hashValueconversationNotification = conversationNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationNotification
              }
          }
          if hasEventNotification {
              if let hashValueeventNotification = eventNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventNotification
              }
          }
          if hasFocusNotification {
              if let hashValuefocusNotification = focusNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuefocusNotification
              }
          }
          if hasTypingNotification {
              if let hashValuetypingNotification = typingNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuetypingNotification
              }
          }
          if hasNotificationLevelNotification {
              if let hashValuenotificationLevelNotification = notificationLevelNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenotificationLevelNotification
              }
          }
          if hasReplyToInviteNotification {
              if let hashValuereplyToInviteNotification = replyToInviteNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuereplyToInviteNotification
              }
          }
          if hasWatermarkNotification {
              if let hashValuewatermarkNotification = watermarkNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuewatermarkNotification
              }
          }
          if hasViewModification {
              if let hashValueviewModification = viewModification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueviewModification
              }
          }
          if hasEasterEggNotification {
              if let hashValueeasterEggNotification = easterEggNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeasterEggNotification
              }
          }
          if hasConversation {
              if let hashValueconversation = conversation?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversation
              }
          }
          if hasSelfPresenceNotification {
              if let hashValueselfPresenceNotification = selfPresenceNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueselfPresenceNotification
              }
          }
          if hasDeleteNotification {
              if let hashValuedeleteNotification = deleteNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeleteNotification
              }
          }
          if hasPresenceNotification {
              if let hashValuepresenceNotification = presenceNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepresenceNotification
              }
          }
          if hasBlockNotification {
              if let hashValueblockNotification = blockNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueblockNotification
              }
          }
          if hasNotificationSettingNotification {
              if let hashValuenotificationSettingNotification = notificationSettingNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenotificationSettingNotification
              }
          }
          if hasRichPresenceEnabledStateNotification {
              if let hashValuerichPresenceEnabledStateNotification = richPresenceEnabledStateNotification?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerichPresenceEnabledStateNotification
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "StateUpdate"
  }
  override public func className() -> String {
      return "StateUpdate"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return StateUpdate.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:StateUpdate = StateUpdate()
    public func getMessage() -> StateUpdate {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStateUpdateHeader:Bool {
         get {
             return builderResult.hasStateUpdateHeader
         }
    }
    public var stateUpdateHeader:StateUpdateHeader! {
         get {
             if stateUpdateHeaderBuilder_ != nil {
                builderResult.stateUpdateHeader = stateUpdateHeaderBuilder_.getMessage()
             }
             return builderResult.stateUpdateHeader
         }
         set (value) {
             builderResult.hasStateUpdateHeader = true
             builderResult.stateUpdateHeader = value
         }
    }
    private var stateUpdateHeaderBuilder_:StateUpdateHeader.Builder! {
         didSet {
            builderResult.hasStateUpdateHeader = true
         }
    }
    public func getStateUpdateHeaderBuilder() -> StateUpdateHeader.Builder {
      if stateUpdateHeaderBuilder_ == nil {
         stateUpdateHeaderBuilder_ = StateUpdateHeader.Builder()
         builderResult.stateUpdateHeader = stateUpdateHeaderBuilder_.getMessage()
         if stateUpdateHeader != nil {
            try! stateUpdateHeaderBuilder_.mergeFrom(stateUpdateHeader)
         }
      }
      return stateUpdateHeaderBuilder_
    }
    public func setStateUpdateHeader(_ value:StateUpdateHeader!) -> StateUpdate.Builder {
      self.stateUpdateHeader = value
      return self
    }
    public func mergeStateUpdateHeader(_ value:StateUpdateHeader) throws -> StateUpdate.Builder {
      if builderResult.hasStateUpdateHeader {
        builderResult.stateUpdateHeader = try StateUpdateHeader.builderWithPrototype(builderResult.stateUpdateHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.stateUpdateHeader = value
      }
      builderResult.hasStateUpdateHeader = true
      return self
    }
    public func clearStateUpdateHeader() -> StateUpdate.Builder {
      stateUpdateHeaderBuilder_ = nil
      builderResult.hasStateUpdateHeader = false
      builderResult.stateUpdateHeader = nil
      return self
    }
    public var hasConversation:Bool {
         get {
             return builderResult.hasConversation
         }
    }
    public var conversation:Conversation! {
         get {
             if conversationBuilder_ != nil {
                builderResult.conversation = conversationBuilder_.getMessage()
             }
             return builderResult.conversation
         }
         set (value) {
             builderResult.hasConversation = true
             builderResult.conversation = value
         }
    }
    private var conversationBuilder_:Conversation.Builder! {
         didSet {
            builderResult.hasConversation = true
         }
    }
    public func getConversationBuilder() -> Conversation.Builder {
      if conversationBuilder_ == nil {
         conversationBuilder_ = Conversation.Builder()
         builderResult.conversation = conversationBuilder_.getMessage()
         if conversation != nil {
            try! conversationBuilder_.mergeFrom(conversation)
         }
      }
      return conversationBuilder_
    }
    public func setConversation(_ value:Conversation!) -> StateUpdate.Builder {
      self.conversation = value
      return self
    }
    public func mergeConversation(_ value:Conversation) throws -> StateUpdate.Builder {
      if builderResult.hasConversation {
        builderResult.conversation = try Conversation.builderWithPrototype(builderResult.conversation).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversation = value
      }
      builderResult.hasConversation = true
      return self
    }
    public func clearConversation() -> StateUpdate.Builder {
      conversationBuilder_ = nil
      builderResult.hasConversation = false
      builderResult.conversation = nil
      return self
    }
    public var hasConversationNotification:Bool {
         get {
             return builderResult.hasConversationNotification
         }
    }
    public var conversationNotification:ConversationNotification! {
         get {
             if conversationNotificationBuilder_ != nil {
                builderResult.conversationNotification = conversationNotificationBuilder_.getMessage()
             }
             return builderResult.conversationNotification
         }
         set (value) {
             builderResult.hasConversationNotification = true
             builderResult.conversationNotification = value
         }
    }
    private var conversationNotificationBuilder_:ConversationNotification.Builder! {
         didSet {
            builderResult.hasConversationNotification = true
         }
    }
    public func getConversationNotificationBuilder() -> ConversationNotification.Builder {
      if conversationNotificationBuilder_ == nil {
         conversationNotificationBuilder_ = ConversationNotification.Builder()
         builderResult.conversationNotification = conversationNotificationBuilder_.getMessage()
         if conversationNotification != nil {
            try! conversationNotificationBuilder_.mergeFrom(conversationNotification)
         }
      }
      return conversationNotificationBuilder_
    }
    public func setConversationNotification(_ value:ConversationNotification!) -> StateUpdate.Builder {
      self.conversationNotification = value
      return self
    }
    public func mergeConversationNotification(_ value:ConversationNotification) throws -> StateUpdate.Builder {
      if builderResult.hasConversationNotification {
        builderResult.conversationNotification = try ConversationNotification.builderWithPrototype(builderResult.conversationNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationNotification = value
      }
      builderResult.hasConversationNotification = true
      return self
    }
    public func clearConversationNotification() -> StateUpdate.Builder {
      conversationNotificationBuilder_ = nil
      builderResult.hasConversationNotification = false
      builderResult.conversationNotification = nil
      return self
    }
    public var hasEventNotification:Bool {
         get {
             return builderResult.hasEventNotification
         }
    }
    public var eventNotification:EventNotification! {
         get {
             if eventNotificationBuilder_ != nil {
                builderResult.eventNotification = eventNotificationBuilder_.getMessage()
             }
             return builderResult.eventNotification
         }
         set (value) {
             builderResult.hasEventNotification = true
             builderResult.eventNotification = value
         }
    }
    private var eventNotificationBuilder_:EventNotification.Builder! {
         didSet {
            builderResult.hasEventNotification = true
         }
    }
    public func getEventNotificationBuilder() -> EventNotification.Builder {
      if eventNotificationBuilder_ == nil {
         eventNotificationBuilder_ = EventNotification.Builder()
         builderResult.eventNotification = eventNotificationBuilder_.getMessage()
         if eventNotification != nil {
            try! eventNotificationBuilder_.mergeFrom(eventNotification)
         }
      }
      return eventNotificationBuilder_
    }
    public func setEventNotification(_ value:EventNotification!) -> StateUpdate.Builder {
      self.eventNotification = value
      return self
    }
    public func mergeEventNotification(_ value:EventNotification) throws -> StateUpdate.Builder {
      if builderResult.hasEventNotification {
        builderResult.eventNotification = try EventNotification.builderWithPrototype(builderResult.eventNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventNotification = value
      }
      builderResult.hasEventNotification = true
      return self
    }
    public func clearEventNotification() -> StateUpdate.Builder {
      eventNotificationBuilder_ = nil
      builderResult.hasEventNotification = false
      builderResult.eventNotification = nil
      return self
    }
    public var hasFocusNotification:Bool {
         get {
             return builderResult.hasFocusNotification
         }
    }
    public var focusNotification:SetFocusNotification! {
         get {
             if focusNotificationBuilder_ != nil {
                builderResult.focusNotification = focusNotificationBuilder_.getMessage()
             }
             return builderResult.focusNotification
         }
         set (value) {
             builderResult.hasFocusNotification = true
             builderResult.focusNotification = value
         }
    }
    private var focusNotificationBuilder_:SetFocusNotification.Builder! {
         didSet {
            builderResult.hasFocusNotification = true
         }
    }
    public func getFocusNotificationBuilder() -> SetFocusNotification.Builder {
      if focusNotificationBuilder_ == nil {
         focusNotificationBuilder_ = SetFocusNotification.Builder()
         builderResult.focusNotification = focusNotificationBuilder_.getMessage()
         if focusNotification != nil {
            try! focusNotificationBuilder_.mergeFrom(focusNotification)
         }
      }
      return focusNotificationBuilder_
    }
    public func setFocusNotification(_ value:SetFocusNotification!) -> StateUpdate.Builder {
      self.focusNotification = value
      return self
    }
    public func mergeFocusNotification(_ value:SetFocusNotification) throws -> StateUpdate.Builder {
      if builderResult.hasFocusNotification {
        builderResult.focusNotification = try SetFocusNotification.builderWithPrototype(builderResult.focusNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.focusNotification = value
      }
      builderResult.hasFocusNotification = true
      return self
    }
    public func clearFocusNotification() -> StateUpdate.Builder {
      focusNotificationBuilder_ = nil
      builderResult.hasFocusNotification = false
      builderResult.focusNotification = nil
      return self
    }
    public var hasTypingNotification:Bool {
         get {
             return builderResult.hasTypingNotification
         }
    }
    public var typingNotification:SetTypingNotification! {
         get {
             if typingNotificationBuilder_ != nil {
                builderResult.typingNotification = typingNotificationBuilder_.getMessage()
             }
             return builderResult.typingNotification
         }
         set (value) {
             builderResult.hasTypingNotification = true
             builderResult.typingNotification = value
         }
    }
    private var typingNotificationBuilder_:SetTypingNotification.Builder! {
         didSet {
            builderResult.hasTypingNotification = true
         }
    }
    public func getTypingNotificationBuilder() -> SetTypingNotification.Builder {
      if typingNotificationBuilder_ == nil {
         typingNotificationBuilder_ = SetTypingNotification.Builder()
         builderResult.typingNotification = typingNotificationBuilder_.getMessage()
         if typingNotification != nil {
            try! typingNotificationBuilder_.mergeFrom(typingNotification)
         }
      }
      return typingNotificationBuilder_
    }
    public func setTypingNotification(_ value:SetTypingNotification!) -> StateUpdate.Builder {
      self.typingNotification = value
      return self
    }
    public func mergeTypingNotification(_ value:SetTypingNotification) throws -> StateUpdate.Builder {
      if builderResult.hasTypingNotification {
        builderResult.typingNotification = try SetTypingNotification.builderWithPrototype(builderResult.typingNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.typingNotification = value
      }
      builderResult.hasTypingNotification = true
      return self
    }
    public func clearTypingNotification() -> StateUpdate.Builder {
      typingNotificationBuilder_ = nil
      builderResult.hasTypingNotification = false
      builderResult.typingNotification = nil
      return self
    }
    public var hasNotificationLevelNotification:Bool {
         get {
             return builderResult.hasNotificationLevelNotification
         }
    }
    public var notificationLevelNotification:SetConversationNotificationLevelNotification! {
         get {
             if notificationLevelNotificationBuilder_ != nil {
                builderResult.notificationLevelNotification = notificationLevelNotificationBuilder_.getMessage()
             }
             return builderResult.notificationLevelNotification
         }
         set (value) {
             builderResult.hasNotificationLevelNotification = true
             builderResult.notificationLevelNotification = value
         }
    }
    private var notificationLevelNotificationBuilder_:SetConversationNotificationLevelNotification.Builder! {
         didSet {
            builderResult.hasNotificationLevelNotification = true
         }
    }
    public func getNotificationLevelNotificationBuilder() -> SetConversationNotificationLevelNotification.Builder {
      if notificationLevelNotificationBuilder_ == nil {
         notificationLevelNotificationBuilder_ = SetConversationNotificationLevelNotification.Builder()
         builderResult.notificationLevelNotification = notificationLevelNotificationBuilder_.getMessage()
         if notificationLevelNotification != nil {
            try! notificationLevelNotificationBuilder_.mergeFrom(notificationLevelNotification)
         }
      }
      return notificationLevelNotificationBuilder_
    }
    public func setNotificationLevelNotification(_ value:SetConversationNotificationLevelNotification!) -> StateUpdate.Builder {
      self.notificationLevelNotification = value
      return self
    }
    public func mergeNotificationLevelNotification(_ value:SetConversationNotificationLevelNotification) throws -> StateUpdate.Builder {
      if builderResult.hasNotificationLevelNotification {
        builderResult.notificationLevelNotification = try SetConversationNotificationLevelNotification.builderWithPrototype(builderResult.notificationLevelNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.notificationLevelNotification = value
      }
      builderResult.hasNotificationLevelNotification = true
      return self
    }
    public func clearNotificationLevelNotification() -> StateUpdate.Builder {
      notificationLevelNotificationBuilder_ = nil
      builderResult.hasNotificationLevelNotification = false
      builderResult.notificationLevelNotification = nil
      return self
    }
    public var hasReplyToInviteNotification:Bool {
         get {
             return builderResult.hasReplyToInviteNotification
         }
    }
    public var replyToInviteNotification:ReplyToInviteNotification! {
         get {
             if replyToInviteNotificationBuilder_ != nil {
                builderResult.replyToInviteNotification = replyToInviteNotificationBuilder_.getMessage()
             }
             return builderResult.replyToInviteNotification
         }
         set (value) {
             builderResult.hasReplyToInviteNotification = true
             builderResult.replyToInviteNotification = value
         }
    }
    private var replyToInviteNotificationBuilder_:ReplyToInviteNotification.Builder! {
         didSet {
            builderResult.hasReplyToInviteNotification = true
         }
    }
    public func getReplyToInviteNotificationBuilder() -> ReplyToInviteNotification.Builder {
      if replyToInviteNotificationBuilder_ == nil {
         replyToInviteNotificationBuilder_ = ReplyToInviteNotification.Builder()
         builderResult.replyToInviteNotification = replyToInviteNotificationBuilder_.getMessage()
         if replyToInviteNotification != nil {
            try! replyToInviteNotificationBuilder_.mergeFrom(replyToInviteNotification)
         }
      }
      return replyToInviteNotificationBuilder_
    }
    public func setReplyToInviteNotification(_ value:ReplyToInviteNotification!) -> StateUpdate.Builder {
      self.replyToInviteNotification = value
      return self
    }
    public func mergeReplyToInviteNotification(_ value:ReplyToInviteNotification) throws -> StateUpdate.Builder {
      if builderResult.hasReplyToInviteNotification {
        builderResult.replyToInviteNotification = try ReplyToInviteNotification.builderWithPrototype(builderResult.replyToInviteNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.replyToInviteNotification = value
      }
      builderResult.hasReplyToInviteNotification = true
      return self
    }
    public func clearReplyToInviteNotification() -> StateUpdate.Builder {
      replyToInviteNotificationBuilder_ = nil
      builderResult.hasReplyToInviteNotification = false
      builderResult.replyToInviteNotification = nil
      return self
    }
    public var hasWatermarkNotification:Bool {
         get {
             return builderResult.hasWatermarkNotification
         }
    }
    public var watermarkNotification:WatermarkNotification! {
         get {
             if watermarkNotificationBuilder_ != nil {
                builderResult.watermarkNotification = watermarkNotificationBuilder_.getMessage()
             }
             return builderResult.watermarkNotification
         }
         set (value) {
             builderResult.hasWatermarkNotification = true
             builderResult.watermarkNotification = value
         }
    }
    private var watermarkNotificationBuilder_:WatermarkNotification.Builder! {
         didSet {
            builderResult.hasWatermarkNotification = true
         }
    }
    public func getWatermarkNotificationBuilder() -> WatermarkNotification.Builder {
      if watermarkNotificationBuilder_ == nil {
         watermarkNotificationBuilder_ = WatermarkNotification.Builder()
         builderResult.watermarkNotification = watermarkNotificationBuilder_.getMessage()
         if watermarkNotification != nil {
            try! watermarkNotificationBuilder_.mergeFrom(watermarkNotification)
         }
      }
      return watermarkNotificationBuilder_
    }
    public func setWatermarkNotification(_ value:WatermarkNotification!) -> StateUpdate.Builder {
      self.watermarkNotification = value
      return self
    }
    public func mergeWatermarkNotification(_ value:WatermarkNotification) throws -> StateUpdate.Builder {
      if builderResult.hasWatermarkNotification {
        builderResult.watermarkNotification = try WatermarkNotification.builderWithPrototype(builderResult.watermarkNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.watermarkNotification = value
      }
      builderResult.hasWatermarkNotification = true
      return self
    }
    public func clearWatermarkNotification() -> StateUpdate.Builder {
      watermarkNotificationBuilder_ = nil
      builderResult.hasWatermarkNotification = false
      builderResult.watermarkNotification = nil
      return self
    }
    public var hasViewModification:Bool {
         get {
             return builderResult.hasViewModification
         }
    }
    public var viewModification:ConversationViewModification! {
         get {
             if viewModificationBuilder_ != nil {
                builderResult.viewModification = viewModificationBuilder_.getMessage()
             }
             return builderResult.viewModification
         }
         set (value) {
             builderResult.hasViewModification = true
             builderResult.viewModification = value
         }
    }
    private var viewModificationBuilder_:ConversationViewModification.Builder! {
         didSet {
            builderResult.hasViewModification = true
         }
    }
    public func getViewModificationBuilder() -> ConversationViewModification.Builder {
      if viewModificationBuilder_ == nil {
         viewModificationBuilder_ = ConversationViewModification.Builder()
         builderResult.viewModification = viewModificationBuilder_.getMessage()
         if viewModification != nil {
            try! viewModificationBuilder_.mergeFrom(viewModification)
         }
      }
      return viewModificationBuilder_
    }
    public func setViewModification(_ value:ConversationViewModification!) -> StateUpdate.Builder {
      self.viewModification = value
      return self
    }
    public func mergeViewModification(_ value:ConversationViewModification) throws -> StateUpdate.Builder {
      if builderResult.hasViewModification {
        builderResult.viewModification = try ConversationViewModification.builderWithPrototype(builderResult.viewModification).mergeFrom(value).buildPartial()
      } else {
        builderResult.viewModification = value
      }
      builderResult.hasViewModification = true
      return self
    }
    public func clearViewModification() -> StateUpdate.Builder {
      viewModificationBuilder_ = nil
      builderResult.hasViewModification = false
      builderResult.viewModification = nil
      return self
    }
    public var hasEasterEggNotification:Bool {
         get {
             return builderResult.hasEasterEggNotification
         }
    }
    public var easterEggNotification:EasterEggNotification! {
         get {
             if easterEggNotificationBuilder_ != nil {
                builderResult.easterEggNotification = easterEggNotificationBuilder_.getMessage()
             }
             return builderResult.easterEggNotification
         }
         set (value) {
             builderResult.hasEasterEggNotification = true
             builderResult.easterEggNotification = value
         }
    }
    private var easterEggNotificationBuilder_:EasterEggNotification.Builder! {
         didSet {
            builderResult.hasEasterEggNotification = true
         }
    }
    public func getEasterEggNotificationBuilder() -> EasterEggNotification.Builder {
      if easterEggNotificationBuilder_ == nil {
         easterEggNotificationBuilder_ = EasterEggNotification.Builder()
         builderResult.easterEggNotification = easterEggNotificationBuilder_.getMessage()
         if easterEggNotification != nil {
            try! easterEggNotificationBuilder_.mergeFrom(easterEggNotification)
         }
      }
      return easterEggNotificationBuilder_
    }
    public func setEasterEggNotification(_ value:EasterEggNotification!) -> StateUpdate.Builder {
      self.easterEggNotification = value
      return self
    }
    public func mergeEasterEggNotification(_ value:EasterEggNotification) throws -> StateUpdate.Builder {
      if builderResult.hasEasterEggNotification {
        builderResult.easterEggNotification = try EasterEggNotification.builderWithPrototype(builderResult.easterEggNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.easterEggNotification = value
      }
      builderResult.hasEasterEggNotification = true
      return self
    }
    public func clearEasterEggNotification() -> StateUpdate.Builder {
      easterEggNotificationBuilder_ = nil
      builderResult.hasEasterEggNotification = false
      builderResult.easterEggNotification = nil
      return self
    }
    public var hasSelfPresenceNotification:Bool {
         get {
             return builderResult.hasSelfPresenceNotification
         }
    }
    public var selfPresenceNotification:SelfPresenceNotification! {
         get {
             if selfPresenceNotificationBuilder_ != nil {
                builderResult.selfPresenceNotification = selfPresenceNotificationBuilder_.getMessage()
             }
             return builderResult.selfPresenceNotification
         }
         set (value) {
             builderResult.hasSelfPresenceNotification = true
             builderResult.selfPresenceNotification = value
         }
    }
    private var selfPresenceNotificationBuilder_:SelfPresenceNotification.Builder! {
         didSet {
            builderResult.hasSelfPresenceNotification = true
         }
    }
    public func getSelfPresenceNotificationBuilder() -> SelfPresenceNotification.Builder {
      if selfPresenceNotificationBuilder_ == nil {
         selfPresenceNotificationBuilder_ = SelfPresenceNotification.Builder()
         builderResult.selfPresenceNotification = selfPresenceNotificationBuilder_.getMessage()
         if selfPresenceNotification != nil {
            try! selfPresenceNotificationBuilder_.mergeFrom(selfPresenceNotification)
         }
      }
      return selfPresenceNotificationBuilder_
    }
    public func setSelfPresenceNotification(_ value:SelfPresenceNotification!) -> StateUpdate.Builder {
      self.selfPresenceNotification = value
      return self
    }
    public func mergeSelfPresenceNotification(_ value:SelfPresenceNotification) throws -> StateUpdate.Builder {
      if builderResult.hasSelfPresenceNotification {
        builderResult.selfPresenceNotification = try SelfPresenceNotification.builderWithPrototype(builderResult.selfPresenceNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.selfPresenceNotification = value
      }
      builderResult.hasSelfPresenceNotification = true
      return self
    }
    public func clearSelfPresenceNotification() -> StateUpdate.Builder {
      selfPresenceNotificationBuilder_ = nil
      builderResult.hasSelfPresenceNotification = false
      builderResult.selfPresenceNotification = nil
      return self
    }
    public var hasDeleteNotification:Bool {
         get {
             return builderResult.hasDeleteNotification
         }
    }
    public var deleteNotification:DeleteActionNotification! {
         get {
             if deleteNotificationBuilder_ != nil {
                builderResult.deleteNotification = deleteNotificationBuilder_.getMessage()
             }
             return builderResult.deleteNotification
         }
         set (value) {
             builderResult.hasDeleteNotification = true
             builderResult.deleteNotification = value
         }
    }
    private var deleteNotificationBuilder_:DeleteActionNotification.Builder! {
         didSet {
            builderResult.hasDeleteNotification = true
         }
    }
    public func getDeleteNotificationBuilder() -> DeleteActionNotification.Builder {
      if deleteNotificationBuilder_ == nil {
         deleteNotificationBuilder_ = DeleteActionNotification.Builder()
         builderResult.deleteNotification = deleteNotificationBuilder_.getMessage()
         if deleteNotification != nil {
            try! deleteNotificationBuilder_.mergeFrom(deleteNotification)
         }
      }
      return deleteNotificationBuilder_
    }
    public func setDeleteNotification(_ value:DeleteActionNotification!) -> StateUpdate.Builder {
      self.deleteNotification = value
      return self
    }
    public func mergeDeleteNotification(_ value:DeleteActionNotification) throws -> StateUpdate.Builder {
      if builderResult.hasDeleteNotification {
        builderResult.deleteNotification = try DeleteActionNotification.builderWithPrototype(builderResult.deleteNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.deleteNotification = value
      }
      builderResult.hasDeleteNotification = true
      return self
    }
    public func clearDeleteNotification() -> StateUpdate.Builder {
      deleteNotificationBuilder_ = nil
      builderResult.hasDeleteNotification = false
      builderResult.deleteNotification = nil
      return self
    }
    public var hasPresenceNotification:Bool {
         get {
             return builderResult.hasPresenceNotification
         }
    }
    public var presenceNotification:PresenceNotification! {
         get {
             if presenceNotificationBuilder_ != nil {
                builderResult.presenceNotification = presenceNotificationBuilder_.getMessage()
             }
             return builderResult.presenceNotification
         }
         set (value) {
             builderResult.hasPresenceNotification = true
             builderResult.presenceNotification = value
         }
    }
    private var presenceNotificationBuilder_:PresenceNotification.Builder! {
         didSet {
            builderResult.hasPresenceNotification = true
         }
    }
    public func getPresenceNotificationBuilder() -> PresenceNotification.Builder {
      if presenceNotificationBuilder_ == nil {
         presenceNotificationBuilder_ = PresenceNotification.Builder()
         builderResult.presenceNotification = presenceNotificationBuilder_.getMessage()
         if presenceNotification != nil {
            try! presenceNotificationBuilder_.mergeFrom(presenceNotification)
         }
      }
      return presenceNotificationBuilder_
    }
    public func setPresenceNotification(_ value:PresenceNotification!) -> StateUpdate.Builder {
      self.presenceNotification = value
      return self
    }
    public func mergePresenceNotification(_ value:PresenceNotification) throws -> StateUpdate.Builder {
      if builderResult.hasPresenceNotification {
        builderResult.presenceNotification = try PresenceNotification.builderWithPrototype(builderResult.presenceNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.presenceNotification = value
      }
      builderResult.hasPresenceNotification = true
      return self
    }
    public func clearPresenceNotification() -> StateUpdate.Builder {
      presenceNotificationBuilder_ = nil
      builderResult.hasPresenceNotification = false
      builderResult.presenceNotification = nil
      return self
    }
    public var hasBlockNotification:Bool {
         get {
             return builderResult.hasBlockNotification
         }
    }
    public var blockNotification:BlockNotification! {
         get {
             if blockNotificationBuilder_ != nil {
                builderResult.blockNotification = blockNotificationBuilder_.getMessage()
             }
             return builderResult.blockNotification
         }
         set (value) {
             builderResult.hasBlockNotification = true
             builderResult.blockNotification = value
         }
    }
    private var blockNotificationBuilder_:BlockNotification.Builder! {
         didSet {
            builderResult.hasBlockNotification = true
         }
    }
    public func getBlockNotificationBuilder() -> BlockNotification.Builder {
      if blockNotificationBuilder_ == nil {
         blockNotificationBuilder_ = BlockNotification.Builder()
         builderResult.blockNotification = blockNotificationBuilder_.getMessage()
         if blockNotification != nil {
            try! blockNotificationBuilder_.mergeFrom(blockNotification)
         }
      }
      return blockNotificationBuilder_
    }
    public func setBlockNotification(_ value:BlockNotification!) -> StateUpdate.Builder {
      self.blockNotification = value
      return self
    }
    public func mergeBlockNotification(_ value:BlockNotification) throws -> StateUpdate.Builder {
      if builderResult.hasBlockNotification {
        builderResult.blockNotification = try BlockNotification.builderWithPrototype(builderResult.blockNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.blockNotification = value
      }
      builderResult.hasBlockNotification = true
      return self
    }
    public func clearBlockNotification() -> StateUpdate.Builder {
      blockNotificationBuilder_ = nil
      builderResult.hasBlockNotification = false
      builderResult.blockNotification = nil
      return self
    }
    public var hasNotificationSettingNotification:Bool {
         get {
             return builderResult.hasNotificationSettingNotification
         }
    }
    public var notificationSettingNotification:SetNotificationSettingNotification! {
         get {
             if notificationSettingNotificationBuilder_ != nil {
                builderResult.notificationSettingNotification = notificationSettingNotificationBuilder_.getMessage()
             }
             return builderResult.notificationSettingNotification
         }
         set (value) {
             builderResult.hasNotificationSettingNotification = true
             builderResult.notificationSettingNotification = value
         }
    }
    private var notificationSettingNotificationBuilder_:SetNotificationSettingNotification.Builder! {
         didSet {
            builderResult.hasNotificationSettingNotification = true
         }
    }
    public func getNotificationSettingNotificationBuilder() -> SetNotificationSettingNotification.Builder {
      if notificationSettingNotificationBuilder_ == nil {
         notificationSettingNotificationBuilder_ = SetNotificationSettingNotification.Builder()
         builderResult.notificationSettingNotification = notificationSettingNotificationBuilder_.getMessage()
         if notificationSettingNotification != nil {
            try! notificationSettingNotificationBuilder_.mergeFrom(notificationSettingNotification)
         }
      }
      return notificationSettingNotificationBuilder_
    }
    public func setNotificationSettingNotification(_ value:SetNotificationSettingNotification!) -> StateUpdate.Builder {
      self.notificationSettingNotification = value
      return self
    }
    public func mergeNotificationSettingNotification(_ value:SetNotificationSettingNotification) throws -> StateUpdate.Builder {
      if builderResult.hasNotificationSettingNotification {
        builderResult.notificationSettingNotification = try SetNotificationSettingNotification.builderWithPrototype(builderResult.notificationSettingNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.notificationSettingNotification = value
      }
      builderResult.hasNotificationSettingNotification = true
      return self
    }
    public func clearNotificationSettingNotification() -> StateUpdate.Builder {
      notificationSettingNotificationBuilder_ = nil
      builderResult.hasNotificationSettingNotification = false
      builderResult.notificationSettingNotification = nil
      return self
    }
    public var hasRichPresenceEnabledStateNotification:Bool {
         get {
             return builderResult.hasRichPresenceEnabledStateNotification
         }
    }
    public var richPresenceEnabledStateNotification:RichPresenceEnabledStateNotification! {
         get {
             if richPresenceEnabledStateNotificationBuilder_ != nil {
                builderResult.richPresenceEnabledStateNotification = richPresenceEnabledStateNotificationBuilder_.getMessage()
             }
             return builderResult.richPresenceEnabledStateNotification
         }
         set (value) {
             builderResult.hasRichPresenceEnabledStateNotification = true
             builderResult.richPresenceEnabledStateNotification = value
         }
    }
    private var richPresenceEnabledStateNotificationBuilder_:RichPresenceEnabledStateNotification.Builder! {
         didSet {
            builderResult.hasRichPresenceEnabledStateNotification = true
         }
    }
    public func getRichPresenceEnabledStateNotificationBuilder() -> RichPresenceEnabledStateNotification.Builder {
      if richPresenceEnabledStateNotificationBuilder_ == nil {
         richPresenceEnabledStateNotificationBuilder_ = RichPresenceEnabledStateNotification.Builder()
         builderResult.richPresenceEnabledStateNotification = richPresenceEnabledStateNotificationBuilder_.getMessage()
         if richPresenceEnabledStateNotification != nil {
            try! richPresenceEnabledStateNotificationBuilder_.mergeFrom(richPresenceEnabledStateNotification)
         }
      }
      return richPresenceEnabledStateNotificationBuilder_
    }
    public func setRichPresenceEnabledStateNotification(_ value:RichPresenceEnabledStateNotification!) -> StateUpdate.Builder {
      self.richPresenceEnabledStateNotification = value
      return self
    }
    public func mergeRichPresenceEnabledStateNotification(_ value:RichPresenceEnabledStateNotification) throws -> StateUpdate.Builder {
      if builderResult.hasRichPresenceEnabledStateNotification {
        builderResult.richPresenceEnabledStateNotification = try RichPresenceEnabledStateNotification.builderWithPrototype(builderResult.richPresenceEnabledStateNotification).mergeFrom(value).buildPartial()
      } else {
        builderResult.richPresenceEnabledStateNotification = value
      }
      builderResult.hasRichPresenceEnabledStateNotification = true
      return self
    }
    public func clearRichPresenceEnabledStateNotification() -> StateUpdate.Builder {
      richPresenceEnabledStateNotificationBuilder_ = nil
      builderResult.hasRichPresenceEnabledStateNotification = false
      builderResult.richPresenceEnabledStateNotification = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> StateUpdate.Builder {
      builderResult = StateUpdate()
      return self
    }
    public override func clone() throws -> StateUpdate.Builder {
      return try StateUpdate.builderWithPrototype(builderResult)
    }
    public override func build() throws -> StateUpdate {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> StateUpdate {
      let returnMe:StateUpdate = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:StateUpdate) throws -> StateUpdate.Builder {
      if other == StateUpdate() {
       return self
      }
      if (other.hasStateUpdateHeader) {
          try mergeStateUpdateHeader(other.stateUpdateHeader)
      }
      if (other.hasConversation) {
          try mergeConversation(other.conversation)
      }
      if (other.hasConversationNotification) {
          try mergeConversationNotification(other.conversationNotification)
      }
      if (other.hasEventNotification) {
          try mergeEventNotification(other.eventNotification)
      }
      if (other.hasFocusNotification) {
          try mergeFocusNotification(other.focusNotification)
      }
      if (other.hasTypingNotification) {
          try mergeTypingNotification(other.typingNotification)
      }
      if (other.hasNotificationLevelNotification) {
          try mergeNotificationLevelNotification(other.notificationLevelNotification)
      }
      if (other.hasReplyToInviteNotification) {
          try mergeReplyToInviteNotification(other.replyToInviteNotification)
      }
      if (other.hasWatermarkNotification) {
          try mergeWatermarkNotification(other.watermarkNotification)
      }
      if (other.hasViewModification) {
          try mergeViewModification(other.viewModification)
      }
      if (other.hasEasterEggNotification) {
          try mergeEasterEggNotification(other.easterEggNotification)
      }
      if (other.hasSelfPresenceNotification) {
          try mergeSelfPresenceNotification(other.selfPresenceNotification)
      }
      if (other.hasDeleteNotification) {
          try mergeDeleteNotification(other.deleteNotification)
      }
      if (other.hasPresenceNotification) {
          try mergePresenceNotification(other.presenceNotification)
      }
      if (other.hasBlockNotification) {
          try mergeBlockNotification(other.blockNotification)
      }
      if (other.hasNotificationSettingNotification) {
          try mergeNotificationSettingNotification(other.notificationSettingNotification)
      }
      if (other.hasRichPresenceEnabledStateNotification) {
          try mergeRichPresenceEnabledStateNotification(other.richPresenceEnabledStateNotification)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> StateUpdate.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdate.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:StateUpdateHeader.Builder = StateUpdateHeader.Builder()
          if hasStateUpdateHeader {
            try subBuilder.mergeFrom(stateUpdateHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          stateUpdateHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationNotification.Builder = ConversationNotification.Builder()
          if hasConversationNotification {
            try subBuilder.mergeFrom(conversationNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationNotification = subBuilder.buildPartial()

        case 26:
          let subBuilder:EventNotification.Builder = EventNotification.Builder()
          if hasEventNotification {
            try subBuilder.mergeFrom(eventNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventNotification = subBuilder.buildPartial()

        case 34:
          let subBuilder:SetFocusNotification.Builder = SetFocusNotification.Builder()
          if hasFocusNotification {
            try subBuilder.mergeFrom(focusNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          focusNotification = subBuilder.buildPartial()

        case 42:
          let subBuilder:SetTypingNotification.Builder = SetTypingNotification.Builder()
          if hasTypingNotification {
            try subBuilder.mergeFrom(typingNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          typingNotification = subBuilder.buildPartial()

        case 50:
          let subBuilder:SetConversationNotificationLevelNotification.Builder = SetConversationNotificationLevelNotification.Builder()
          if hasNotificationLevelNotification {
            try subBuilder.mergeFrom(notificationLevelNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          notificationLevelNotification = subBuilder.buildPartial()

        case 58:
          let subBuilder:ReplyToInviteNotification.Builder = ReplyToInviteNotification.Builder()
          if hasReplyToInviteNotification {
            try subBuilder.mergeFrom(replyToInviteNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          replyToInviteNotification = subBuilder.buildPartial()

        case 66:
          let subBuilder:WatermarkNotification.Builder = WatermarkNotification.Builder()
          if hasWatermarkNotification {
            try subBuilder.mergeFrom(watermarkNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          watermarkNotification = subBuilder.buildPartial()

        case 90:
          let subBuilder:ConversationViewModification.Builder = ConversationViewModification.Builder()
          if hasViewModification {
            try subBuilder.mergeFrom(viewModification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          viewModification = subBuilder.buildPartial()

        case 98:
          let subBuilder:EasterEggNotification.Builder = EasterEggNotification.Builder()
          if hasEasterEggNotification {
            try subBuilder.mergeFrom(easterEggNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          easterEggNotification = subBuilder.buildPartial()

        case 106:
          let subBuilder:Conversation.Builder = Conversation.Builder()
          if hasConversation {
            try subBuilder.mergeFrom(conversation)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversation = subBuilder.buildPartial()

        case 114:
          let subBuilder:SelfPresenceNotification.Builder = SelfPresenceNotification.Builder()
          if hasSelfPresenceNotification {
            try subBuilder.mergeFrom(selfPresenceNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          selfPresenceNotification = subBuilder.buildPartial()

        case 122:
          let subBuilder:DeleteActionNotification.Builder = DeleteActionNotification.Builder()
          if hasDeleteNotification {
            try subBuilder.mergeFrom(deleteNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deleteNotification = subBuilder.buildPartial()

        case 130:
          let subBuilder:PresenceNotification.Builder = PresenceNotification.Builder()
          if hasPresenceNotification {
            try subBuilder.mergeFrom(presenceNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          presenceNotification = subBuilder.buildPartial()

        case 138:
          let subBuilder:BlockNotification.Builder = BlockNotification.Builder()
          if hasBlockNotification {
            try subBuilder.mergeFrom(blockNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          blockNotification = subBuilder.buildPartial()

        case 154:
          let subBuilder:SetNotificationSettingNotification.Builder = SetNotificationSettingNotification.Builder()
          if hasNotificationSettingNotification {
            try subBuilder.mergeFrom(notificationSettingNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          notificationSettingNotification = subBuilder.buildPartial()

        case 162:
          let subBuilder:RichPresenceEnabledStateNotification.Builder = RichPresenceEnabledStateNotification.Builder()
          if hasRichPresenceEnabledStateNotification {
            try subBuilder.mergeFrom(richPresenceEnabledStateNotification)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          richPresenceEnabledStateNotification = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Header for StateUpdate messages.
final public class StateUpdateHeader : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var activeClientState:ActiveClientState = ActiveClientState.ActiveClientStateNoActive
  public private(set) var hasActiveClientState:Bool = false
  public private(set) var requestTraceId:String = ""

  public private(set) var hasRequestTraceId:Bool = false
  public private(set) var notificationSettings:NotificationSettings!
  public private(set) var hasNotificationSettings:Bool = false
  public private(set) var currentServerTime:UInt64 = UInt64(0)

  public private(set) var hasCurrentServerTime:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasActiveClientState {
      try output.writeEnum(1, value:activeClientState.rawValue)
    }
    if hasRequestTraceId {
      try output.writeString(3, value:requestTraceId)
    }
    if hasNotificationSettings {
      try output.writeMessage(4, value:notificationSettings)
    }
    if hasCurrentServerTime {
      try output.writeUInt64(5, value:currentServerTime)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasActiveClientState) {
      serialize_size += activeClientState.rawValue.computeEnumSize(1)
    }
    if hasRequestTraceId {
      serialize_size += requestTraceId.computeStringSize(3)
    }
    if hasNotificationSettings {
        if let varSizenotificationSettings = notificationSettings?.computeMessageSize(4) {
            serialize_size += varSizenotificationSettings
        }
    }
    if hasCurrentServerTime {
      serialize_size += currentServerTime.computeUInt64Size(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<StateUpdateHeader> {
    var mergedArray = Array<StateUpdateHeader>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> StateUpdateHeader? {
    return try StateUpdateHeader.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdateHeader {
    return try StateUpdateHeader.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> StateUpdateHeader.Builder {
    return StateUpdateHeader.classBuilder() as! StateUpdateHeader.Builder
  }
  public func getBuilder() -> StateUpdateHeader.Builder {
    return classBuilder() as! StateUpdateHeader.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return StateUpdateHeader.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return StateUpdateHeader.Builder()
  }
  public func toBuilder() throws -> StateUpdateHeader.Builder {
    return try StateUpdateHeader.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:StateUpdateHeader) throws -> StateUpdateHeader.Builder {
    return try StateUpdateHeader.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasActiveClientState) {
      output += "\(indent) activeClientState: \(activeClientState.description)\n"
    }
    if hasRequestTraceId {
      output += "\(indent) requestTraceId: \(requestTraceId) \n"
    }
    if hasNotificationSettings {
      output += "\(indent) notificationSettings {\n"
      if let outDescNotificationSettings = notificationSettings {
        output += try outDescNotificationSettings.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCurrentServerTime {
      output += "\(indent) currentServerTime: \(currentServerTime) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasActiveClientState {
             hashCode = (hashCode &* 31) &+ Int(activeClientState.rawValue)
          }
          if hasRequestTraceId {
             hashCode = (hashCode &* 31) &+ requestTraceId.hashValue
          }
          if hasNotificationSettings {
              if let hashValuenotificationSettings = notificationSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenotificationSettings
              }
          }
          if hasCurrentServerTime {
             hashCode = (hashCode &* 31) &+ currentServerTime.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "StateUpdateHeader"
  }
  override public func className() -> String {
      return "StateUpdateHeader"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return StateUpdateHeader.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:StateUpdateHeader = StateUpdateHeader()
    public func getMessage() -> StateUpdateHeader {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasActiveClientState:Bool{
          get {
              return builderResult.hasActiveClientState
          }
      }
      public var activeClientState:ActiveClientState {
          get {
              return builderResult.activeClientState
          }
          set (value) {
              builderResult.hasActiveClientState = true
              builderResult.activeClientState = value
          }
      }
      public func setActiveClientState(_ value:ActiveClientState) -> StateUpdateHeader.Builder {
        self.activeClientState = value
        return self
      }
      public func clearActiveClientState() -> StateUpdateHeader.Builder {
         builderResult.hasActiveClientState = false
         builderResult.activeClientState = .ActiveClientStateNoActive
         return self
      }
    public var hasRequestTraceId:Bool {
         get {
              return builderResult.hasRequestTraceId
         }
    }
    public var requestTraceId:String {
         get {
              return builderResult.requestTraceId
         }
         set (value) {
             builderResult.hasRequestTraceId = true
             builderResult.requestTraceId = value
         }
    }
    public func setRequestTraceId(_ value:String) -> StateUpdateHeader.Builder {
      self.requestTraceId = value
      return self
    }
    public func clearRequestTraceId() -> StateUpdateHeader.Builder{
         builderResult.hasRequestTraceId = false
         builderResult.requestTraceId = ""
         return self
    }
    public var hasNotificationSettings:Bool {
         get {
             return builderResult.hasNotificationSettings
         }
    }
    public var notificationSettings:NotificationSettings! {
         get {
             if notificationSettingsBuilder_ != nil {
                builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
             }
             return builderResult.notificationSettings
         }
         set (value) {
             builderResult.hasNotificationSettings = true
             builderResult.notificationSettings = value
         }
    }
    private var notificationSettingsBuilder_:NotificationSettings.Builder! {
         didSet {
            builderResult.hasNotificationSettings = true
         }
    }
    public func getNotificationSettingsBuilder() -> NotificationSettings.Builder {
      if notificationSettingsBuilder_ == nil {
         notificationSettingsBuilder_ = NotificationSettings.Builder()
         builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
         if notificationSettings != nil {
            try! notificationSettingsBuilder_.mergeFrom(notificationSettings)
         }
      }
      return notificationSettingsBuilder_
    }
    public func setNotificationSettings(_ value:NotificationSettings!) -> StateUpdateHeader.Builder {
      self.notificationSettings = value
      return self
    }
    public func mergeNotificationSettings(_ value:NotificationSettings) throws -> StateUpdateHeader.Builder {
      if builderResult.hasNotificationSettings {
        builderResult.notificationSettings = try NotificationSettings.builderWithPrototype(builderResult.notificationSettings).mergeFrom(value).buildPartial()
      } else {
        builderResult.notificationSettings = value
      }
      builderResult.hasNotificationSettings = true
      return self
    }
    public func clearNotificationSettings() -> StateUpdateHeader.Builder {
      notificationSettingsBuilder_ = nil
      builderResult.hasNotificationSettings = false
      builderResult.notificationSettings = nil
      return self
    }
    public var hasCurrentServerTime:Bool {
         get {
              return builderResult.hasCurrentServerTime
         }
    }
    public var currentServerTime:UInt64 {
         get {
              return builderResult.currentServerTime
         }
         set (value) {
             builderResult.hasCurrentServerTime = true
             builderResult.currentServerTime = value
         }
    }
    public func setCurrentServerTime(_ value:UInt64) -> StateUpdateHeader.Builder {
      self.currentServerTime = value
      return self
    }
    public func clearCurrentServerTime() -> StateUpdateHeader.Builder{
         builderResult.hasCurrentServerTime = false
         builderResult.currentServerTime = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> StateUpdateHeader.Builder {
      builderResult = StateUpdateHeader()
      return self
    }
    public override func clone() throws -> StateUpdateHeader.Builder {
      return try StateUpdateHeader.builderWithPrototype(builderResult)
    }
    public override func build() throws -> StateUpdateHeader {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> StateUpdateHeader {
      let returnMe:StateUpdateHeader = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:StateUpdateHeader) throws -> StateUpdateHeader.Builder {
      if other == StateUpdateHeader() {
       return self
      }
      if other.hasActiveClientState {
           activeClientState = other.activeClientState
      }
      if other.hasRequestTraceId {
           requestTraceId = other.requestTraceId
      }
      if (other.hasNotificationSettings) {
          try mergeNotificationSettings(other.notificationSettings)
      }
      if other.hasCurrentServerTime {
           currentServerTime = other.currentServerTime
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> StateUpdateHeader.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StateUpdateHeader.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntactiveClientState = try input.readEnum()
          if let enumsactiveClientState = ActiveClientState(rawValue:valueIntactiveClientState){
               activeClientState = enumsactiveClientState
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntactiveClientState))
          }

        case 26:
          requestTraceId = try input.readString()

        case 34:
          let subBuilder:NotificationSettings.Builder = NotificationSettings.Builder()
          if hasNotificationSettings {
            try subBuilder.mergeFrom(notificationSettings)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          notificationSettings = subBuilder.buildPartial()

        case 40:
          currentServerTime = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// List of StateUpdate messages to allow pushing multiple notifications from
// the server to the client simultaneously.
final public class BatchUpdate : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var stateUpdate:Array<StateUpdate>  = Array<StateUpdate>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitstateUpdate:Bool = true
    for oneElementstateUpdate in stateUpdate {
        if (!oneElementstateUpdate.isInitialized()) {
            isInitstateUpdate = false
            break 
        }
    }
    if !isInitstateUpdate {
     return isInitstateUpdate
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementstateUpdate in stateUpdate {
        try output.writeMessage(1, value:oneElementstateUpdate)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementstateUpdate in stateUpdate {
        serialize_size += oneElementstateUpdate.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<BatchUpdate> {
    var mergedArray = Array<BatchUpdate>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> BatchUpdate? {
    return try BatchUpdate.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BatchUpdate {
    return try BatchUpdate.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> BatchUpdate.Builder {
    return BatchUpdate.classBuilder() as! BatchUpdate.Builder
  }
  public func getBuilder() -> BatchUpdate.Builder {
    return classBuilder() as! BatchUpdate.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return BatchUpdate.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return BatchUpdate.Builder()
  }
  public func toBuilder() throws -> BatchUpdate.Builder {
    return try BatchUpdate.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:BatchUpdate) throws -> BatchUpdate.Builder {
    return try BatchUpdate.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var stateUpdateElementIndex:Int = 0
    for oneElementstateUpdate in stateUpdate {
        output += "\(indent) stateUpdate[\(stateUpdateElementIndex)] {\n"
        output += try oneElementstateUpdate.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        stateUpdateElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementstateUpdate in stateUpdate {
              hashCode = (hashCode &* 31) &+ oneElementstateUpdate.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BatchUpdate"
  }
  override public func className() -> String {
      return "BatchUpdate"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BatchUpdate.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:BatchUpdate = BatchUpdate()
    public func getMessage() -> BatchUpdate {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var stateUpdate:Array<StateUpdate> {
         get {
             return builderResult.stateUpdate
         }
         set (value) {
             builderResult.stateUpdate = value
         }
    }
    public func setStateUpdate(_ value:Array<StateUpdate>) -> BatchUpdate.Builder {
      self.stateUpdate = value
      return self
    }
    public func clearStateUpdate() -> BatchUpdate.Builder {
      builderResult.stateUpdate.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> BatchUpdate.Builder {
      builderResult = BatchUpdate()
      return self
    }
    public override func clone() throws -> BatchUpdate.Builder {
      return try BatchUpdate.builderWithPrototype(builderResult)
    }
    public override func build() throws -> BatchUpdate {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> BatchUpdate {
      let returnMe:BatchUpdate = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:BatchUpdate) throws -> BatchUpdate.Builder {
      if other == BatchUpdate() {
       return self
      }
      if !other.stateUpdate.isEmpty  {
         builderResult.stateUpdate += other.stateUpdate
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> BatchUpdate.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BatchUpdate.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = StateUpdate.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          stateUpdate += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConversationNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversation:Conversation!
  public private(set) var hasConversation:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversation {
      try output.writeMessage(1, value:conversation)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversation {
        if let varSizeconversation = conversation?.computeMessageSize(1) {
            serialize_size += varSizeconversation
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationNotification> {
    var mergedArray = Array<ConversationNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationNotification? {
    return try ConversationNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationNotification {
    return try ConversationNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationNotification.Builder {
    return ConversationNotification.classBuilder() as! ConversationNotification.Builder
  }
  public func getBuilder() -> ConversationNotification.Builder {
    return classBuilder() as! ConversationNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationNotification.Builder()
  }
  public func toBuilder() throws -> ConversationNotification.Builder {
    return try ConversationNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationNotification) throws -> ConversationNotification.Builder {
    return try ConversationNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversation {
      output += "\(indent) conversation {\n"
      if let outDescConversation = conversation {
        output += try outDescConversation.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversation {
              if let hashValueconversation = conversation?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversation
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationNotification"
  }
  override public func className() -> String {
      return "ConversationNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationNotification = ConversationNotification()
    public func getMessage() -> ConversationNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversation:Bool {
         get {
             return builderResult.hasConversation
         }
    }
    public var conversation:Conversation! {
         get {
             if conversationBuilder_ != nil {
                builderResult.conversation = conversationBuilder_.getMessage()
             }
             return builderResult.conversation
         }
         set (value) {
             builderResult.hasConversation = true
             builderResult.conversation = value
         }
    }
    private var conversationBuilder_:Conversation.Builder! {
         didSet {
            builderResult.hasConversation = true
         }
    }
    public func getConversationBuilder() -> Conversation.Builder {
      if conversationBuilder_ == nil {
         conversationBuilder_ = Conversation.Builder()
         builderResult.conversation = conversationBuilder_.getMessage()
         if conversation != nil {
            try! conversationBuilder_.mergeFrom(conversation)
         }
      }
      return conversationBuilder_
    }
    public func setConversation(_ value:Conversation!) -> ConversationNotification.Builder {
      self.conversation = value
      return self
    }
    public func mergeConversation(_ value:Conversation) throws -> ConversationNotification.Builder {
      if builderResult.hasConversation {
        builderResult.conversation = try Conversation.builderWithPrototype(builderResult.conversation).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversation = value
      }
      builderResult.hasConversation = true
      return self
    }
    public func clearConversation() -> ConversationNotification.Builder {
      conversationBuilder_ = nil
      builderResult.hasConversation = false
      builderResult.conversation = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationNotification.Builder {
      builderResult = ConversationNotification()
      return self
    }
    public override func clone() throws -> ConversationNotification.Builder {
      return try ConversationNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationNotification {
      let returnMe:ConversationNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationNotification) throws -> ConversationNotification.Builder {
      if other == ConversationNotification() {
       return self
      }
      if (other.hasConversation) {
          try mergeConversation(other.conversation)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:Conversation.Builder = Conversation.Builder()
          if hasConversation {
            try subBuilder.mergeFrom(conversation)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversation = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EventNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var event:Event!
  public private(set) var hasEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasEvent {
     if !event.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEvent {
      try output.writeMessage(1, value:event)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEvent {
        if let varSizeevent = event?.computeMessageSize(1) {
            serialize_size += varSizeevent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EventNotification> {
    var mergedArray = Array<EventNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EventNotification? {
    return try EventNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventNotification {
    return try EventNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EventNotification.Builder {
    return EventNotification.classBuilder() as! EventNotification.Builder
  }
  public func getBuilder() -> EventNotification.Builder {
    return classBuilder() as! EventNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EventNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EventNotification.Builder()
  }
  public func toBuilder() throws -> EventNotification.Builder {
    return try EventNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EventNotification) throws -> EventNotification.Builder {
    return try EventNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasEvent {
      output += "\(indent) event {\n"
      if let outDescEvent = event {
        output += try outDescEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEvent {
              if let hashValueevent = event?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueevent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EventNotification"
  }
  override public func className() -> String {
      return "EventNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EventNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EventNotification = EventNotification()
    public func getMessage() -> EventNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEvent:Bool {
         get {
             return builderResult.hasEvent
         }
    }
    public var event:Event! {
         get {
             if eventBuilder_ != nil {
                builderResult.event = eventBuilder_.getMessage()
             }
             return builderResult.event
         }
         set (value) {
             builderResult.hasEvent = true
             builderResult.event = value
         }
    }
    private var eventBuilder_:Event.Builder! {
         didSet {
            builderResult.hasEvent = true
         }
    }
    public func getEventBuilder() -> Event.Builder {
      if eventBuilder_ == nil {
         eventBuilder_ = Event.Builder()
         builderResult.event = eventBuilder_.getMessage()
         if event != nil {
            try! eventBuilder_.mergeFrom(event)
         }
      }
      return eventBuilder_
    }
    public func setEvent(_ value:Event!) -> EventNotification.Builder {
      self.event = value
      return self
    }
    public func mergeEvent(_ value:Event) throws -> EventNotification.Builder {
      if builderResult.hasEvent {
        builderResult.event = try Event.builderWithPrototype(builderResult.event).mergeFrom(value).buildPartial()
      } else {
        builderResult.event = value
      }
      builderResult.hasEvent = true
      return self
    }
    public func clearEvent() -> EventNotification.Builder {
      eventBuilder_ = nil
      builderResult.hasEvent = false
      builderResult.event = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EventNotification.Builder {
      builderResult = EventNotification()
      return self
    }
    public override func clone() throws -> EventNotification.Builder {
      return try EventNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EventNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EventNotification {
      let returnMe:EventNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EventNotification) throws -> EventNotification.Builder {
      if other == EventNotification() {
       return self
      }
      if (other.hasEvent) {
          try mergeEvent(other.event)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EventNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EventNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:Event.Builder = Event.Builder()
          if hasEvent {
            try subBuilder.mergeFrom(event)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          event = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetFocusNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var senderId:ParticipantId!
  public private(set) var hasSenderId:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  public private(set) var types:FocusType = FocusType.FocusTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var device:FocusDevice = FocusDevice.FocusDeviceUnspecified
  public private(set) var hasDevice:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasSenderId {
      try output.writeMessage(2, value:senderId)
    }
    if hasTimestamp {
      try output.writeUInt64(3, value:timestamp)
    }
    if hasTypes {
      try output.writeEnum(4, value:types.rawValue)
    }
    if hasDevice {
      try output.writeEnum(5, value:device.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasSenderId {
        if let varSizesenderId = senderId?.computeMessageSize(2) {
            serialize_size += varSizesenderId
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(3)
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(4)
    }
    if (hasDevice) {
      serialize_size += device.rawValue.computeEnumSize(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetFocusNotification> {
    var mergedArray = Array<SetFocusNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetFocusNotification? {
    return try SetFocusNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusNotification {
    return try SetFocusNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetFocusNotification.Builder {
    return SetFocusNotification.classBuilder() as! SetFocusNotification.Builder
  }
  public func getBuilder() -> SetFocusNotification.Builder {
    return classBuilder() as! SetFocusNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetFocusNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetFocusNotification.Builder()
  }
  public func toBuilder() throws -> SetFocusNotification.Builder {
    return try SetFocusNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetFocusNotification) throws -> SetFocusNotification.Builder {
    return try SetFocusNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSenderId {
      output += "\(indent) senderId {\n"
      if let outDescSenderId = senderId {
        output += try outDescSenderId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if (hasDevice) {
      output += "\(indent) device: \(device.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasSenderId {
              if let hashValuesenderId = senderId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesenderId
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasDevice {
             hashCode = (hashCode &* 31) &+ Int(device.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetFocusNotification"
  }
  override public func className() -> String {
      return "SetFocusNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetFocusNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetFocusNotification = SetFocusNotification()
    public func getMessage() -> SetFocusNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetFocusNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetFocusNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetFocusNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasSenderId:Bool {
         get {
             return builderResult.hasSenderId
         }
    }
    public var senderId:ParticipantId! {
         get {
             if senderIdBuilder_ != nil {
                builderResult.senderId = senderIdBuilder_.getMessage()
             }
             return builderResult.senderId
         }
         set (value) {
             builderResult.hasSenderId = true
             builderResult.senderId = value
         }
    }
    private var senderIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasSenderId = true
         }
    }
    public func getSenderIdBuilder() -> ParticipantId.Builder {
      if senderIdBuilder_ == nil {
         senderIdBuilder_ = ParticipantId.Builder()
         builderResult.senderId = senderIdBuilder_.getMessage()
         if senderId != nil {
            try! senderIdBuilder_.mergeFrom(senderId)
         }
      }
      return senderIdBuilder_
    }
    public func setSenderId(_ value:ParticipantId!) -> SetFocusNotification.Builder {
      self.senderId = value
      return self
    }
    public func mergeSenderId(_ value:ParticipantId) throws -> SetFocusNotification.Builder {
      if builderResult.hasSenderId {
        builderResult.senderId = try ParticipantId.builderWithPrototype(builderResult.senderId).mergeFrom(value).buildPartial()
      } else {
        builderResult.senderId = value
      }
      builderResult.hasSenderId = true
      return self
    }
    public func clearSenderId() -> SetFocusNotification.Builder {
      senderIdBuilder_ = nil
      builderResult.hasSenderId = false
      builderResult.senderId = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetFocusNotification.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetFocusNotification.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:FocusType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:FocusType) -> SetFocusNotification.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> SetFocusNotification.Builder {
         builderResult.hasTypes = false
         builderResult.types = .FocusTypeUnknown
         return self
      }
      public var hasDevice:Bool{
          get {
              return builderResult.hasDevice
          }
      }
      public var device:FocusDevice {
          get {
              return builderResult.device
          }
          set (value) {
              builderResult.hasDevice = true
              builderResult.device = value
          }
      }
      public func setDevice(_ value:FocusDevice) -> SetFocusNotification.Builder {
        self.device = value
        return self
      }
      public func clearDevice() -> SetFocusNotification.Builder {
         builderResult.hasDevice = false
         builderResult.device = .FocusDeviceUnspecified
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetFocusNotification.Builder {
      builderResult = SetFocusNotification()
      return self
    }
    public override func clone() throws -> SetFocusNotification.Builder {
      return try SetFocusNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetFocusNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetFocusNotification {
      let returnMe:SetFocusNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetFocusNotification) throws -> SetFocusNotification.Builder {
      if other == SetFocusNotification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasSenderId) {
          try mergeSenderId(other.senderId)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasDevice {
           device = other.device
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 18:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasSenderId {
            try subBuilder.mergeFrom(senderId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          senderId = subBuilder.buildPartial()

        case 24:
          timestamp = try input.readUInt64()

        case 32:
          let valueInttypes = try input.readEnum()
          if let enumstypes = FocusType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueInttypes))
          }

        case 40:
          let valueIntdevice = try input.readEnum()
          if let enumsdevice = FocusDevice(rawValue:valueIntdevice){
               device = enumsdevice
          } else {
               try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntdevice))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetTypingNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var senderId:ParticipantId!
  public private(set) var hasSenderId:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  public private(set) var types:TypingType = TypingType.TypingTypeUnknown
  public private(set) var hasTypes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasSenderId {
      try output.writeMessage(2, value:senderId)
    }
    if hasTimestamp {
      try output.writeUInt64(3, value:timestamp)
    }
    if hasTypes {
      try output.writeEnum(4, value:types.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasSenderId {
        if let varSizesenderId = senderId?.computeMessageSize(2) {
            serialize_size += varSizesenderId
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(3)
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetTypingNotification> {
    var mergedArray = Array<SetTypingNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetTypingNotification? {
    return try SetTypingNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingNotification {
    return try SetTypingNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetTypingNotification.Builder {
    return SetTypingNotification.classBuilder() as! SetTypingNotification.Builder
  }
  public func getBuilder() -> SetTypingNotification.Builder {
    return classBuilder() as! SetTypingNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetTypingNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetTypingNotification.Builder()
  }
  public func toBuilder() throws -> SetTypingNotification.Builder {
    return try SetTypingNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetTypingNotification) throws -> SetTypingNotification.Builder {
    return try SetTypingNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSenderId {
      output += "\(indent) senderId {\n"
      if let outDescSenderId = senderId {
        output += try outDescSenderId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasSenderId {
              if let hashValuesenderId = senderId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesenderId
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetTypingNotification"
  }
  override public func className() -> String {
      return "SetTypingNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetTypingNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetTypingNotification = SetTypingNotification()
    public func getMessage() -> SetTypingNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetTypingNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetTypingNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetTypingNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasSenderId:Bool {
         get {
             return builderResult.hasSenderId
         }
    }
    public var senderId:ParticipantId! {
         get {
             if senderIdBuilder_ != nil {
                builderResult.senderId = senderIdBuilder_.getMessage()
             }
             return builderResult.senderId
         }
         set (value) {
             builderResult.hasSenderId = true
             builderResult.senderId = value
         }
    }
    private var senderIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasSenderId = true
         }
    }
    public func getSenderIdBuilder() -> ParticipantId.Builder {
      if senderIdBuilder_ == nil {
         senderIdBuilder_ = ParticipantId.Builder()
         builderResult.senderId = senderIdBuilder_.getMessage()
         if senderId != nil {
            try! senderIdBuilder_.mergeFrom(senderId)
         }
      }
      return senderIdBuilder_
    }
    public func setSenderId(_ value:ParticipantId!) -> SetTypingNotification.Builder {
      self.senderId = value
      return self
    }
    public func mergeSenderId(_ value:ParticipantId) throws -> SetTypingNotification.Builder {
      if builderResult.hasSenderId {
        builderResult.senderId = try ParticipantId.builderWithPrototype(builderResult.senderId).mergeFrom(value).buildPartial()
      } else {
        builderResult.senderId = value
      }
      builderResult.hasSenderId = true
      return self
    }
    public func clearSenderId() -> SetTypingNotification.Builder {
      senderIdBuilder_ = nil
      builderResult.hasSenderId = false
      builderResult.senderId = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetTypingNotification.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetTypingNotification.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:TypingType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:TypingType) -> SetTypingNotification.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> SetTypingNotification.Builder {
         builderResult.hasTypes = false
         builderResult.types = .TypingTypeUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetTypingNotification.Builder {
      builderResult = SetTypingNotification()
      return self
    }
    public override func clone() throws -> SetTypingNotification.Builder {
      return try SetTypingNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetTypingNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetTypingNotification {
      let returnMe:SetTypingNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetTypingNotification) throws -> SetTypingNotification.Builder {
      if other == SetTypingNotification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasSenderId) {
          try mergeSenderId(other.senderId)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      if other.hasTypes {
           types = other.types
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 18:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasSenderId {
            try subBuilder.mergeFrom(senderId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          senderId = subBuilder.buildPartial()

        case 24:
          timestamp = try input.readUInt64()

        case 32:
          let valueInttypes = try input.readEnum()
          if let enumstypes = TypingType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueInttypes))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetConversationNotificationLevelNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var level:NotificationLevel = NotificationLevel.NotificationLevelUnknown
  public private(set) var hasLevel:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasLevel {
      try output.writeEnum(2, value:level.rawValue)
    }
    if hasTimestamp {
      try output.writeUInt64(4, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasLevel) {
      serialize_size += level.rawValue.computeEnumSize(2)
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetConversationNotificationLevelNotification> {
    var mergedArray = Array<SetConversationNotificationLevelNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelNotification? {
    return try SetConversationNotificationLevelNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelNotification {
    return try SetConversationNotificationLevelNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetConversationNotificationLevelNotification.Builder {
    return SetConversationNotificationLevelNotification.classBuilder() as! SetConversationNotificationLevelNotification.Builder
  }
  public func getBuilder() -> SetConversationNotificationLevelNotification.Builder {
    return classBuilder() as! SetConversationNotificationLevelNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelNotification.Builder()
  }
  public func toBuilder() throws -> SetConversationNotificationLevelNotification.Builder {
    return try SetConversationNotificationLevelNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetConversationNotificationLevelNotification) throws -> SetConversationNotificationLevelNotification.Builder {
    return try SetConversationNotificationLevelNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasLevel) {
      output += "\(indent) level: \(level.description)\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasLevel {
             hashCode = (hashCode &* 31) &+ Int(level.rawValue)
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetConversationNotificationLevelNotification"
  }
  override public func className() -> String {
      return "SetConversationNotificationLevelNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetConversationNotificationLevelNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetConversationNotificationLevelNotification = SetConversationNotificationLevelNotification()
    public func getMessage() -> SetConversationNotificationLevelNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetConversationNotificationLevelNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetConversationNotificationLevelNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetConversationNotificationLevelNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasLevel:Bool{
          get {
              return builderResult.hasLevel
          }
      }
      public var level:NotificationLevel {
          get {
              return builderResult.level
          }
          set (value) {
              builderResult.hasLevel = true
              builderResult.level = value
          }
      }
      public func setLevel(_ value:NotificationLevel) -> SetConversationNotificationLevelNotification.Builder {
        self.level = value
        return self
      }
      public func clearLevel() -> SetConversationNotificationLevelNotification.Builder {
         builderResult.hasLevel = false
         builderResult.level = .NotificationLevelUnknown
         return self
      }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetConversationNotificationLevelNotification.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetConversationNotificationLevelNotification.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetConversationNotificationLevelNotification.Builder {
      builderResult = SetConversationNotificationLevelNotification()
      return self
    }
    public override func clone() throws -> SetConversationNotificationLevelNotification.Builder {
      return try SetConversationNotificationLevelNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetConversationNotificationLevelNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetConversationNotificationLevelNotification {
      let returnMe:SetConversationNotificationLevelNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetConversationNotificationLevelNotification) throws -> SetConversationNotificationLevelNotification.Builder {
      if other == SetConversationNotificationLevelNotification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasLevel {
           level = other.level
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 16:
          let valueIntlevel = try input.readEnum()
          if let enumslevel = NotificationLevel(rawValue:valueIntlevel){
               level = enumslevel
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntlevel))
          }

        case 32:
          timestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ReplyToInviteNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var types:ReplyToInviteType = ReplyToInviteType.ReplyToInviteTypeUnknown
  public private(set) var hasTypes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasTypes {
      try output.writeEnum(2, value:types.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ReplyToInviteNotification> {
    var mergedArray = Array<ReplyToInviteNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ReplyToInviteNotification? {
    return try ReplyToInviteNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReplyToInviteNotification {
    return try ReplyToInviteNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ReplyToInviteNotification.Builder {
    return ReplyToInviteNotification.classBuilder() as! ReplyToInviteNotification.Builder
  }
  public func getBuilder() -> ReplyToInviteNotification.Builder {
    return classBuilder() as! ReplyToInviteNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ReplyToInviteNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ReplyToInviteNotification.Builder()
  }
  public func toBuilder() throws -> ReplyToInviteNotification.Builder {
    return try ReplyToInviteNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ReplyToInviteNotification) throws -> ReplyToInviteNotification.Builder {
    return try ReplyToInviteNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ReplyToInviteNotification"
  }
  override public func className() -> String {
      return "ReplyToInviteNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ReplyToInviteNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ReplyToInviteNotification = ReplyToInviteNotification()
    public func getMessage() -> ReplyToInviteNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> ReplyToInviteNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> ReplyToInviteNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> ReplyToInviteNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ReplyToInviteType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ReplyToInviteType) -> ReplyToInviteNotification.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> ReplyToInviteNotification.Builder {
         builderResult.hasTypes = false
         builderResult.types = .ReplyToInviteTypeUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ReplyToInviteNotification.Builder {
      builderResult = ReplyToInviteNotification()
      return self
    }
    public override func clone() throws -> ReplyToInviteNotification.Builder {
      return try ReplyToInviteNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ReplyToInviteNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ReplyToInviteNotification {
      let returnMe:ReplyToInviteNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ReplyToInviteNotification) throws -> ReplyToInviteNotification.Builder {
      if other == ReplyToInviteNotification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasTypes {
           types = other.types
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ReplyToInviteNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ReplyToInviteNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 16:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ReplyToInviteType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueInttypes))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class WatermarkNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var senderId:ParticipantId!
  public private(set) var hasSenderId:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var latestReadTimestamp:UInt64 = UInt64(0)

  public private(set) var hasLatestReadTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasSenderId {
      try output.writeMessage(1, value:senderId)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasLatestReadTimestamp {
      try output.writeUInt64(3, value:latestReadTimestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasSenderId {
        if let varSizesenderId = senderId?.computeMessageSize(1) {
            serialize_size += varSizesenderId
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if hasLatestReadTimestamp {
      serialize_size += latestReadTimestamp.computeUInt64Size(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<WatermarkNotification> {
    var mergedArray = Array<WatermarkNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> WatermarkNotification? {
    return try WatermarkNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WatermarkNotification {
    return try WatermarkNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> WatermarkNotification.Builder {
    return WatermarkNotification.classBuilder() as! WatermarkNotification.Builder
  }
  public func getBuilder() -> WatermarkNotification.Builder {
    return classBuilder() as! WatermarkNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return WatermarkNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return WatermarkNotification.Builder()
  }
  public func toBuilder() throws -> WatermarkNotification.Builder {
    return try WatermarkNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:WatermarkNotification) throws -> WatermarkNotification.Builder {
    return try WatermarkNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasSenderId {
      output += "\(indent) senderId {\n"
      if let outDescSenderId = senderId {
        output += try outDescSenderId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLatestReadTimestamp {
      output += "\(indent) latestReadTimestamp: \(latestReadTimestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSenderId {
              if let hashValuesenderId = senderId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesenderId
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasLatestReadTimestamp {
             hashCode = (hashCode &* 31) &+ latestReadTimestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "WatermarkNotification"
  }
  override public func className() -> String {
      return "WatermarkNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return WatermarkNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:WatermarkNotification = WatermarkNotification()
    public func getMessage() -> WatermarkNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasSenderId:Bool {
         get {
             return builderResult.hasSenderId
         }
    }
    public var senderId:ParticipantId! {
         get {
             if senderIdBuilder_ != nil {
                builderResult.senderId = senderIdBuilder_.getMessage()
             }
             return builderResult.senderId
         }
         set (value) {
             builderResult.hasSenderId = true
             builderResult.senderId = value
         }
    }
    private var senderIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasSenderId = true
         }
    }
    public func getSenderIdBuilder() -> ParticipantId.Builder {
      if senderIdBuilder_ == nil {
         senderIdBuilder_ = ParticipantId.Builder()
         builderResult.senderId = senderIdBuilder_.getMessage()
         if senderId != nil {
            try! senderIdBuilder_.mergeFrom(senderId)
         }
      }
      return senderIdBuilder_
    }
    public func setSenderId(_ value:ParticipantId!) -> WatermarkNotification.Builder {
      self.senderId = value
      return self
    }
    public func mergeSenderId(_ value:ParticipantId) throws -> WatermarkNotification.Builder {
      if builderResult.hasSenderId {
        builderResult.senderId = try ParticipantId.builderWithPrototype(builderResult.senderId).mergeFrom(value).buildPartial()
      } else {
        builderResult.senderId = value
      }
      builderResult.hasSenderId = true
      return self
    }
    public func clearSenderId() -> WatermarkNotification.Builder {
      senderIdBuilder_ = nil
      builderResult.hasSenderId = false
      builderResult.senderId = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> WatermarkNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> WatermarkNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> WatermarkNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasLatestReadTimestamp:Bool {
         get {
              return builderResult.hasLatestReadTimestamp
         }
    }
    public var latestReadTimestamp:UInt64 {
         get {
              return builderResult.latestReadTimestamp
         }
         set (value) {
             builderResult.hasLatestReadTimestamp = true
             builderResult.latestReadTimestamp = value
         }
    }
    public func setLatestReadTimestamp(_ value:UInt64) -> WatermarkNotification.Builder {
      self.latestReadTimestamp = value
      return self
    }
    public func clearLatestReadTimestamp() -> WatermarkNotification.Builder{
         builderResult.hasLatestReadTimestamp = false
         builderResult.latestReadTimestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> WatermarkNotification.Builder {
      builderResult = WatermarkNotification()
      return self
    }
    public override func clone() throws -> WatermarkNotification.Builder {
      return try WatermarkNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> WatermarkNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> WatermarkNotification {
      let returnMe:WatermarkNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:WatermarkNotification) throws -> WatermarkNotification.Builder {
      if other == WatermarkNotification() {
       return self
      }
      if (other.hasSenderId) {
          try mergeSenderId(other.senderId)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasLatestReadTimestamp {
           latestReadTimestamp = other.latestReadTimestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> WatermarkNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> WatermarkNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasSenderId {
            try subBuilder.mergeFrom(senderId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          senderId = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          latestReadTimestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConversationViewModification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var oldView:ConversationView = ConversationView.ConversationViewUnknown
  public private(set) var hasOldView:Bool = false
  public private(set) var newView:ConversationView = ConversationView.ConversationViewUnknown
  public private(set) var hasNewView:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasOldView {
      try output.writeEnum(2, value:oldView.rawValue)
    }
    if hasNewView {
      try output.writeEnum(3, value:newView.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasOldView) {
      serialize_size += oldView.rawValue.computeEnumSize(2)
    }
    if (hasNewView) {
      serialize_size += newView.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationViewModification> {
    var mergedArray = Array<ConversationViewModification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationViewModification? {
    return try ConversationViewModification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationViewModification {
    return try ConversationViewModification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationViewModification.Builder {
    return ConversationViewModification.classBuilder() as! ConversationViewModification.Builder
  }
  public func getBuilder() -> ConversationViewModification.Builder {
    return classBuilder() as! ConversationViewModification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationViewModification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationViewModification.Builder()
  }
  public func toBuilder() throws -> ConversationViewModification.Builder {
    return try ConversationViewModification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationViewModification) throws -> ConversationViewModification.Builder {
    return try ConversationViewModification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasOldView) {
      output += "\(indent) oldView: \(oldView.description)\n"
    }
    if (hasNewView) {
      output += "\(indent) newView: \(newView.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasOldView {
             hashCode = (hashCode &* 31) &+ Int(oldView.rawValue)
          }
          if hasNewView {
             hashCode = (hashCode &* 31) &+ Int(newView.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationViewModification"
  }
  override public func className() -> String {
      return "ConversationViewModification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationViewModification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationViewModification = ConversationViewModification()
    public func getMessage() -> ConversationViewModification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> ConversationViewModification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> ConversationViewModification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> ConversationViewModification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasOldView:Bool{
          get {
              return builderResult.hasOldView
          }
      }
      public var oldView:ConversationView {
          get {
              return builderResult.oldView
          }
          set (value) {
              builderResult.hasOldView = true
              builderResult.oldView = value
          }
      }
      public func setOldView(_ value:ConversationView) -> ConversationViewModification.Builder {
        self.oldView = value
        return self
      }
      public func clearOldView() -> ConversationViewModification.Builder {
         builderResult.hasOldView = false
         builderResult.oldView = .ConversationViewUnknown
         return self
      }
      public var hasNewView:Bool{
          get {
              return builderResult.hasNewView
          }
      }
      public var newView:ConversationView {
          get {
              return builderResult.newView
          }
          set (value) {
              builderResult.hasNewView = true
              builderResult.newView = value
          }
      }
      public func setNewView(_ value:ConversationView) -> ConversationViewModification.Builder {
        self.newView = value
        return self
      }
      public func clearNewView() -> ConversationViewModification.Builder {
         builderResult.hasNewView = false
         builderResult.newView = .ConversationViewUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationViewModification.Builder {
      builderResult = ConversationViewModification()
      return self
    }
    public override func clone() throws -> ConversationViewModification.Builder {
      return try ConversationViewModification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationViewModification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationViewModification {
      let returnMe:ConversationViewModification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationViewModification) throws -> ConversationViewModification.Builder {
      if other == ConversationViewModification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasOldView {
           oldView = other.oldView
      }
      if other.hasNewView {
           newView = other.newView
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationViewModification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationViewModification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 16:
          let valueIntoldView = try input.readEnum()
          if let enumsoldView = ConversationView(rawValue:valueIntoldView){
               oldView = enumsoldView
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntoldView))
          }

        case 24:
          let valueIntnewView = try input.readEnum()
          if let enumsnewView = ConversationView(rawValue:valueIntnewView){
               newView = enumsnewView
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntnewView))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EasterEggNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var senderId:ParticipantId!
  public private(set) var hasSenderId:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var easterEgg:EasterEgg!
  public private(set) var hasEasterEgg:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasSenderId {
      try output.writeMessage(1, value:senderId)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasEasterEgg {
      try output.writeMessage(3, value:easterEgg)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasSenderId {
        if let varSizesenderId = senderId?.computeMessageSize(1) {
            serialize_size += varSizesenderId
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if hasEasterEgg {
        if let varSizeeasterEgg = easterEgg?.computeMessageSize(3) {
            serialize_size += varSizeeasterEgg
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EasterEggNotification> {
    var mergedArray = Array<EasterEggNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EasterEggNotification? {
    return try EasterEggNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggNotification {
    return try EasterEggNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EasterEggNotification.Builder {
    return EasterEggNotification.classBuilder() as! EasterEggNotification.Builder
  }
  public func getBuilder() -> EasterEggNotification.Builder {
    return classBuilder() as! EasterEggNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EasterEggNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EasterEggNotification.Builder()
  }
  public func toBuilder() throws -> EasterEggNotification.Builder {
    return try EasterEggNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EasterEggNotification) throws -> EasterEggNotification.Builder {
    return try EasterEggNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasSenderId {
      output += "\(indent) senderId {\n"
      if let outDescSenderId = senderId {
        output += try outDescSenderId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEasterEgg {
      output += "\(indent) easterEgg {\n"
      if let outDescEasterEgg = easterEgg {
        output += try outDescEasterEgg.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSenderId {
              if let hashValuesenderId = senderId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesenderId
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasEasterEgg {
              if let hashValueeasterEgg = easterEgg?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeasterEgg
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EasterEggNotification"
  }
  override public func className() -> String {
      return "EasterEggNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EasterEggNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EasterEggNotification = EasterEggNotification()
    public func getMessage() -> EasterEggNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasSenderId:Bool {
         get {
             return builderResult.hasSenderId
         }
    }
    public var senderId:ParticipantId! {
         get {
             if senderIdBuilder_ != nil {
                builderResult.senderId = senderIdBuilder_.getMessage()
             }
             return builderResult.senderId
         }
         set (value) {
             builderResult.hasSenderId = true
             builderResult.senderId = value
         }
    }
    private var senderIdBuilder_:ParticipantId.Builder! {
         didSet {
            builderResult.hasSenderId = true
         }
    }
    public func getSenderIdBuilder() -> ParticipantId.Builder {
      if senderIdBuilder_ == nil {
         senderIdBuilder_ = ParticipantId.Builder()
         builderResult.senderId = senderIdBuilder_.getMessage()
         if senderId != nil {
            try! senderIdBuilder_.mergeFrom(senderId)
         }
      }
      return senderIdBuilder_
    }
    public func setSenderId(_ value:ParticipantId!) -> EasterEggNotification.Builder {
      self.senderId = value
      return self
    }
    public func mergeSenderId(_ value:ParticipantId) throws -> EasterEggNotification.Builder {
      if builderResult.hasSenderId {
        builderResult.senderId = try ParticipantId.builderWithPrototype(builderResult.senderId).mergeFrom(value).buildPartial()
      } else {
        builderResult.senderId = value
      }
      builderResult.hasSenderId = true
      return self
    }
    public func clearSenderId() -> EasterEggNotification.Builder {
      senderIdBuilder_ = nil
      builderResult.hasSenderId = false
      builderResult.senderId = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> EasterEggNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> EasterEggNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> EasterEggNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasEasterEgg:Bool {
         get {
             return builderResult.hasEasterEgg
         }
    }
    public var easterEgg:EasterEgg! {
         get {
             if easterEggBuilder_ != nil {
                builderResult.easterEgg = easterEggBuilder_.getMessage()
             }
             return builderResult.easterEgg
         }
         set (value) {
             builderResult.hasEasterEgg = true
             builderResult.easterEgg = value
         }
    }
    private var easterEggBuilder_:EasterEgg.Builder! {
         didSet {
            builderResult.hasEasterEgg = true
         }
    }
    public func getEasterEggBuilder() -> EasterEgg.Builder {
      if easterEggBuilder_ == nil {
         easterEggBuilder_ = EasterEgg.Builder()
         builderResult.easterEgg = easterEggBuilder_.getMessage()
         if easterEgg != nil {
            try! easterEggBuilder_.mergeFrom(easterEgg)
         }
      }
      return easterEggBuilder_
    }
    public func setEasterEgg(_ value:EasterEgg!) -> EasterEggNotification.Builder {
      self.easterEgg = value
      return self
    }
    public func mergeEasterEgg(_ value:EasterEgg) throws -> EasterEggNotification.Builder {
      if builderResult.hasEasterEgg {
        builderResult.easterEgg = try EasterEgg.builderWithPrototype(builderResult.easterEgg).mergeFrom(value).buildPartial()
      } else {
        builderResult.easterEgg = value
      }
      builderResult.hasEasterEgg = true
      return self
    }
    public func clearEasterEgg() -> EasterEggNotification.Builder {
      easterEggBuilder_ = nil
      builderResult.hasEasterEgg = false
      builderResult.easterEgg = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EasterEggNotification.Builder {
      builderResult = EasterEggNotification()
      return self
    }
    public override func clone() throws -> EasterEggNotification.Builder {
      return try EasterEggNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EasterEggNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EasterEggNotification {
      let returnMe:EasterEggNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EasterEggNotification) throws -> EasterEggNotification.Builder {
      if other == EasterEggNotification() {
       return self
      }
      if (other.hasSenderId) {
          try mergeSenderId(other.senderId)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasEasterEgg) {
          try mergeEasterEgg(other.easterEgg)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ParticipantId.Builder = ParticipantId.Builder()
          if hasSenderId {
            try subBuilder.mergeFrom(senderId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          senderId = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 26:
          let subBuilder:EasterEgg.Builder = EasterEgg.Builder()
          if hasEasterEgg {
            try subBuilder.mergeFrom(easterEgg)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          easterEgg = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Notifies the status of other clients and mood.
final public class SelfPresenceNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var clientPresenceState:ClientPresenceState!
  public private(set) var hasClientPresenceState:Bool = false
  public private(set) var doNotDisturbSetting:DoNotDisturbSetting!
  public private(set) var hasDoNotDisturbSetting:Bool = false
  public private(set) var desktopOffSetting:DesktopOffSetting!
  public private(set) var hasDesktopOffSetting:Bool = false
  public private(set) var desktopOffState:DesktopOffState!
  public private(set) var hasDesktopOffState:Bool = false
  public private(set) var moodState:MoodState!
  public private(set) var hasMoodState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodState {
     if !moodState.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasClientPresenceState {
      try output.writeMessage(1, value:clientPresenceState)
    }
    if hasDoNotDisturbSetting {
      try output.writeMessage(3, value:doNotDisturbSetting)
    }
    if hasDesktopOffSetting {
      try output.writeMessage(4, value:desktopOffSetting)
    }
    if hasDesktopOffState {
      try output.writeMessage(5, value:desktopOffState)
    }
    if hasMoodState {
      try output.writeMessage(6, value:moodState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasClientPresenceState {
        if let varSizeclientPresenceState = clientPresenceState?.computeMessageSize(1) {
            serialize_size += varSizeclientPresenceState
        }
    }
    if hasDoNotDisturbSetting {
        if let varSizedoNotDisturbSetting = doNotDisturbSetting?.computeMessageSize(3) {
            serialize_size += varSizedoNotDisturbSetting
        }
    }
    if hasDesktopOffSetting {
        if let varSizedesktopOffSetting = desktopOffSetting?.computeMessageSize(4) {
            serialize_size += varSizedesktopOffSetting
        }
    }
    if hasDesktopOffState {
        if let varSizedesktopOffState = desktopOffState?.computeMessageSize(5) {
            serialize_size += varSizedesktopOffState
        }
    }
    if hasMoodState {
        if let varSizemoodState = moodState?.computeMessageSize(6) {
            serialize_size += varSizemoodState
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SelfPresenceNotification> {
    var mergedArray = Array<SelfPresenceNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SelfPresenceNotification? {
    return try SelfPresenceNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SelfPresenceNotification {
    return try SelfPresenceNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SelfPresenceNotification.Builder {
    return SelfPresenceNotification.classBuilder() as! SelfPresenceNotification.Builder
  }
  public func getBuilder() -> SelfPresenceNotification.Builder {
    return classBuilder() as! SelfPresenceNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SelfPresenceNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SelfPresenceNotification.Builder()
  }
  public func toBuilder() throws -> SelfPresenceNotification.Builder {
    return try SelfPresenceNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SelfPresenceNotification) throws -> SelfPresenceNotification.Builder {
    return try SelfPresenceNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasClientPresenceState {
      output += "\(indent) clientPresenceState {\n"
      if let outDescClientPresenceState = clientPresenceState {
        output += try outDescClientPresenceState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDoNotDisturbSetting {
      output += "\(indent) doNotDisturbSetting {\n"
      if let outDescDoNotDisturbSetting = doNotDisturbSetting {
        output += try outDescDoNotDisturbSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDesktopOffSetting {
      output += "\(indent) desktopOffSetting {\n"
      if let outDescDesktopOffSetting = desktopOffSetting {
        output += try outDescDesktopOffSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDesktopOffState {
      output += "\(indent) desktopOffState {\n"
      if let outDescDesktopOffState = desktopOffState {
        output += try outDescDesktopOffState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMoodState {
      output += "\(indent) moodState {\n"
      if let outDescMoodState = moodState {
        output += try outDescMoodState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasClientPresenceState {
              if let hashValueclientPresenceState = clientPresenceState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueclientPresenceState
              }
          }
          if hasDoNotDisturbSetting {
              if let hashValuedoNotDisturbSetting = doNotDisturbSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedoNotDisturbSetting
              }
          }
          if hasDesktopOffSetting {
              if let hashValuedesktopOffSetting = desktopOffSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopOffSetting
              }
          }
          if hasDesktopOffState {
              if let hashValuedesktopOffState = desktopOffState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopOffState
              }
          }
          if hasMoodState {
              if let hashValuemoodState = moodState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodState
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SelfPresenceNotification"
  }
  override public func className() -> String {
      return "SelfPresenceNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SelfPresenceNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SelfPresenceNotification = SelfPresenceNotification()
    public func getMessage() -> SelfPresenceNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasClientPresenceState:Bool {
         get {
             return builderResult.hasClientPresenceState
         }
    }
    public var clientPresenceState:ClientPresenceState! {
         get {
             if clientPresenceStateBuilder_ != nil {
                builderResult.clientPresenceState = clientPresenceStateBuilder_.getMessage()
             }
             return builderResult.clientPresenceState
         }
         set (value) {
             builderResult.hasClientPresenceState = true
             builderResult.clientPresenceState = value
         }
    }
    private var clientPresenceStateBuilder_:ClientPresenceState.Builder! {
         didSet {
            builderResult.hasClientPresenceState = true
         }
    }
    public func getClientPresenceStateBuilder() -> ClientPresenceState.Builder {
      if clientPresenceStateBuilder_ == nil {
         clientPresenceStateBuilder_ = ClientPresenceState.Builder()
         builderResult.clientPresenceState = clientPresenceStateBuilder_.getMessage()
         if clientPresenceState != nil {
            try! clientPresenceStateBuilder_.mergeFrom(clientPresenceState)
         }
      }
      return clientPresenceStateBuilder_
    }
    public func setClientPresenceState(_ value:ClientPresenceState!) -> SelfPresenceNotification.Builder {
      self.clientPresenceState = value
      return self
    }
    public func mergeClientPresenceState(_ value:ClientPresenceState) throws -> SelfPresenceNotification.Builder {
      if builderResult.hasClientPresenceState {
        builderResult.clientPresenceState = try ClientPresenceState.builderWithPrototype(builderResult.clientPresenceState).mergeFrom(value).buildPartial()
      } else {
        builderResult.clientPresenceState = value
      }
      builderResult.hasClientPresenceState = true
      return self
    }
    public func clearClientPresenceState() -> SelfPresenceNotification.Builder {
      clientPresenceStateBuilder_ = nil
      builderResult.hasClientPresenceState = false
      builderResult.clientPresenceState = nil
      return self
    }
    public var hasDoNotDisturbSetting:Bool {
         get {
             return builderResult.hasDoNotDisturbSetting
         }
    }
    public var doNotDisturbSetting:DoNotDisturbSetting! {
         get {
             if doNotDisturbSettingBuilder_ != nil {
                builderResult.doNotDisturbSetting = doNotDisturbSettingBuilder_.getMessage()
             }
             return builderResult.doNotDisturbSetting
         }
         set (value) {
             builderResult.hasDoNotDisturbSetting = true
             builderResult.doNotDisturbSetting = value
         }
    }
    private var doNotDisturbSettingBuilder_:DoNotDisturbSetting.Builder! {
         didSet {
            builderResult.hasDoNotDisturbSetting = true
         }
    }
    public func getDoNotDisturbSettingBuilder() -> DoNotDisturbSetting.Builder {
      if doNotDisturbSettingBuilder_ == nil {
         doNotDisturbSettingBuilder_ = DoNotDisturbSetting.Builder()
         builderResult.doNotDisturbSetting = doNotDisturbSettingBuilder_.getMessage()
         if doNotDisturbSetting != nil {
            try! doNotDisturbSettingBuilder_.mergeFrom(doNotDisturbSetting)
         }
      }
      return doNotDisturbSettingBuilder_
    }
    public func setDoNotDisturbSetting(_ value:DoNotDisturbSetting!) -> SelfPresenceNotification.Builder {
      self.doNotDisturbSetting = value
      return self
    }
    public func mergeDoNotDisturbSetting(_ value:DoNotDisturbSetting) throws -> SelfPresenceNotification.Builder {
      if builderResult.hasDoNotDisturbSetting {
        builderResult.doNotDisturbSetting = try DoNotDisturbSetting.builderWithPrototype(builderResult.doNotDisturbSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.doNotDisturbSetting = value
      }
      builderResult.hasDoNotDisturbSetting = true
      return self
    }
    public func clearDoNotDisturbSetting() -> SelfPresenceNotification.Builder {
      doNotDisturbSettingBuilder_ = nil
      builderResult.hasDoNotDisturbSetting = false
      builderResult.doNotDisturbSetting = nil
      return self
    }
    public var hasDesktopOffSetting:Bool {
         get {
             return builderResult.hasDesktopOffSetting
         }
    }
    public var desktopOffSetting:DesktopOffSetting! {
         get {
             if desktopOffSettingBuilder_ != nil {
                builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
             }
             return builderResult.desktopOffSetting
         }
         set (value) {
             builderResult.hasDesktopOffSetting = true
             builderResult.desktopOffSetting = value
         }
    }
    private var desktopOffSettingBuilder_:DesktopOffSetting.Builder! {
         didSet {
            builderResult.hasDesktopOffSetting = true
         }
    }
    public func getDesktopOffSettingBuilder() -> DesktopOffSetting.Builder {
      if desktopOffSettingBuilder_ == nil {
         desktopOffSettingBuilder_ = DesktopOffSetting.Builder()
         builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
         if desktopOffSetting != nil {
            try! desktopOffSettingBuilder_.mergeFrom(desktopOffSetting)
         }
      }
      return desktopOffSettingBuilder_
    }
    public func setDesktopOffSetting(_ value:DesktopOffSetting!) -> SelfPresenceNotification.Builder {
      self.desktopOffSetting = value
      return self
    }
    public func mergeDesktopOffSetting(_ value:DesktopOffSetting) throws -> SelfPresenceNotification.Builder {
      if builderResult.hasDesktopOffSetting {
        builderResult.desktopOffSetting = try DesktopOffSetting.builderWithPrototype(builderResult.desktopOffSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopOffSetting = value
      }
      builderResult.hasDesktopOffSetting = true
      return self
    }
    public func clearDesktopOffSetting() -> SelfPresenceNotification.Builder {
      desktopOffSettingBuilder_ = nil
      builderResult.hasDesktopOffSetting = false
      builderResult.desktopOffSetting = nil
      return self
    }
    public var hasDesktopOffState:Bool {
         get {
             return builderResult.hasDesktopOffState
         }
    }
    public var desktopOffState:DesktopOffState! {
         get {
             if desktopOffStateBuilder_ != nil {
                builderResult.desktopOffState = desktopOffStateBuilder_.getMessage()
             }
             return builderResult.desktopOffState
         }
         set (value) {
             builderResult.hasDesktopOffState = true
             builderResult.desktopOffState = value
         }
    }
    private var desktopOffStateBuilder_:DesktopOffState.Builder! {
         didSet {
            builderResult.hasDesktopOffState = true
         }
    }
    public func getDesktopOffStateBuilder() -> DesktopOffState.Builder {
      if desktopOffStateBuilder_ == nil {
         desktopOffStateBuilder_ = DesktopOffState.Builder()
         builderResult.desktopOffState = desktopOffStateBuilder_.getMessage()
         if desktopOffState != nil {
            try! desktopOffStateBuilder_.mergeFrom(desktopOffState)
         }
      }
      return desktopOffStateBuilder_
    }
    public func setDesktopOffState(_ value:DesktopOffState!) -> SelfPresenceNotification.Builder {
      self.desktopOffState = value
      return self
    }
    public func mergeDesktopOffState(_ value:DesktopOffState) throws -> SelfPresenceNotification.Builder {
      if builderResult.hasDesktopOffState {
        builderResult.desktopOffState = try DesktopOffState.builderWithPrototype(builderResult.desktopOffState).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopOffState = value
      }
      builderResult.hasDesktopOffState = true
      return self
    }
    public func clearDesktopOffState() -> SelfPresenceNotification.Builder {
      desktopOffStateBuilder_ = nil
      builderResult.hasDesktopOffState = false
      builderResult.desktopOffState = nil
      return self
    }
    public var hasMoodState:Bool {
         get {
             return builderResult.hasMoodState
         }
    }
    public var moodState:MoodState! {
         get {
             if moodStateBuilder_ != nil {
                builderResult.moodState = moodStateBuilder_.getMessage()
             }
             return builderResult.moodState
         }
         set (value) {
             builderResult.hasMoodState = true
             builderResult.moodState = value
         }
    }
    private var moodStateBuilder_:MoodState.Builder! {
         didSet {
            builderResult.hasMoodState = true
         }
    }
    public func getMoodStateBuilder() -> MoodState.Builder {
      if moodStateBuilder_ == nil {
         moodStateBuilder_ = MoodState.Builder()
         builderResult.moodState = moodStateBuilder_.getMessage()
         if moodState != nil {
            try! moodStateBuilder_.mergeFrom(moodState)
         }
      }
      return moodStateBuilder_
    }
    public func setMoodState(_ value:MoodState!) -> SelfPresenceNotification.Builder {
      self.moodState = value
      return self
    }
    public func mergeMoodState(_ value:MoodState) throws -> SelfPresenceNotification.Builder {
      if builderResult.hasMoodState {
        builderResult.moodState = try MoodState.builderWithPrototype(builderResult.moodState).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodState = value
      }
      builderResult.hasMoodState = true
      return self
    }
    public func clearMoodState() -> SelfPresenceNotification.Builder {
      moodStateBuilder_ = nil
      builderResult.hasMoodState = false
      builderResult.moodState = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SelfPresenceNotification.Builder {
      builderResult = SelfPresenceNotification()
      return self
    }
    public override func clone() throws -> SelfPresenceNotification.Builder {
      return try SelfPresenceNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SelfPresenceNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SelfPresenceNotification {
      let returnMe:SelfPresenceNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SelfPresenceNotification) throws -> SelfPresenceNotification.Builder {
      if other == SelfPresenceNotification() {
       return self
      }
      if (other.hasClientPresenceState) {
          try mergeClientPresenceState(other.clientPresenceState)
      }
      if (other.hasDoNotDisturbSetting) {
          try mergeDoNotDisturbSetting(other.doNotDisturbSetting)
      }
      if (other.hasDesktopOffSetting) {
          try mergeDesktopOffSetting(other.desktopOffSetting)
      }
      if (other.hasDesktopOffState) {
          try mergeDesktopOffState(other.desktopOffState)
      }
      if (other.hasMoodState) {
          try mergeMoodState(other.moodState)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SelfPresenceNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SelfPresenceNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ClientPresenceState.Builder = ClientPresenceState.Builder()
          if hasClientPresenceState {
            try subBuilder.mergeFrom(clientPresenceState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          clientPresenceState = subBuilder.buildPartial()

        case 26:
          let subBuilder:DoNotDisturbSetting.Builder = DoNotDisturbSetting.Builder()
          if hasDoNotDisturbSetting {
            try subBuilder.mergeFrom(doNotDisturbSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          doNotDisturbSetting = subBuilder.buildPartial()

        case 34:
          let subBuilder:DesktopOffSetting.Builder = DesktopOffSetting.Builder()
          if hasDesktopOffSetting {
            try subBuilder.mergeFrom(desktopOffSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopOffSetting = subBuilder.buildPartial()

        case 42:
          let subBuilder:DesktopOffState.Builder = DesktopOffState.Builder()
          if hasDesktopOffState {
            try subBuilder.mergeFrom(desktopOffState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopOffState = subBuilder.buildPartial()

        case 50:
          let subBuilder:MoodState.Builder = MoodState.Builder()
          if hasMoodState {
            try subBuilder.mergeFrom(moodState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodState = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeleteActionNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var deleteAction:DeleteAction!
  public private(set) var hasDeleteAction:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    if hasDeleteAction {
      try output.writeMessage(2, value:deleteAction)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    if hasDeleteAction {
        if let varSizedeleteAction = deleteAction?.computeMessageSize(2) {
            serialize_size += varSizedeleteAction
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeleteActionNotification> {
    var mergedArray = Array<DeleteActionNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeleteActionNotification? {
    return try DeleteActionNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteActionNotification {
    return try DeleteActionNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeleteActionNotification.Builder {
    return DeleteActionNotification.classBuilder() as! DeleteActionNotification.Builder
  }
  public func getBuilder() -> DeleteActionNotification.Builder {
    return classBuilder() as! DeleteActionNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeleteActionNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeleteActionNotification.Builder()
  }
  public func toBuilder() throws -> DeleteActionNotification.Builder {
    return try DeleteActionNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeleteActionNotification) throws -> DeleteActionNotification.Builder {
    return try DeleteActionNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDeleteAction {
      output += "\(indent) deleteAction {\n"
      if let outDescDeleteAction = deleteAction {
        output += try outDescDeleteAction.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasDeleteAction {
              if let hashValuedeleteAction = deleteAction?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeleteAction
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeleteActionNotification"
  }
  override public func className() -> String {
      return "DeleteActionNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeleteActionNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeleteActionNotification = DeleteActionNotification()
    public func getMessage() -> DeleteActionNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> DeleteActionNotification.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> DeleteActionNotification.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> DeleteActionNotification.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasDeleteAction:Bool {
         get {
             return builderResult.hasDeleteAction
         }
    }
    public var deleteAction:DeleteAction! {
         get {
             if deleteActionBuilder_ != nil {
                builderResult.deleteAction = deleteActionBuilder_.getMessage()
             }
             return builderResult.deleteAction
         }
         set (value) {
             builderResult.hasDeleteAction = true
             builderResult.deleteAction = value
         }
    }
    private var deleteActionBuilder_:DeleteAction.Builder! {
         didSet {
            builderResult.hasDeleteAction = true
         }
    }
    public func getDeleteActionBuilder() -> DeleteAction.Builder {
      if deleteActionBuilder_ == nil {
         deleteActionBuilder_ = DeleteAction.Builder()
         builderResult.deleteAction = deleteActionBuilder_.getMessage()
         if deleteAction != nil {
            try! deleteActionBuilder_.mergeFrom(deleteAction)
         }
      }
      return deleteActionBuilder_
    }
    public func setDeleteAction(_ value:DeleteAction!) -> DeleteActionNotification.Builder {
      self.deleteAction = value
      return self
    }
    public func mergeDeleteAction(_ value:DeleteAction) throws -> DeleteActionNotification.Builder {
      if builderResult.hasDeleteAction {
        builderResult.deleteAction = try DeleteAction.builderWithPrototype(builderResult.deleteAction).mergeFrom(value).buildPartial()
      } else {
        builderResult.deleteAction = value
      }
      builderResult.hasDeleteAction = true
      return self
    }
    public func clearDeleteAction() -> DeleteActionNotification.Builder {
      deleteActionBuilder_ = nil
      builderResult.hasDeleteAction = false
      builderResult.deleteAction = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeleteActionNotification.Builder {
      builderResult = DeleteActionNotification()
      return self
    }
    public override func clone() throws -> DeleteActionNotification.Builder {
      return try DeleteActionNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeleteActionNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeleteActionNotification {
      let returnMe:DeleteActionNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeleteActionNotification) throws -> DeleteActionNotification.Builder {
      if other == DeleteActionNotification() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasDeleteAction) {
          try mergeDeleteAction(other.deleteAction)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteActionNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteActionNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 18:
          let subBuilder:DeleteAction.Builder = DeleteAction.Builder()
          if hasDeleteAction {
            try subBuilder.mergeFrom(deleteAction)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deleteAction = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PresenceNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var presence:Array<PresenceResult>  = Array<PresenceResult>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitpresence:Bool = true
    for oneElementpresence in presence {
        if (!oneElementpresence.isInitialized()) {
            isInitpresence = false
            break 
        }
    }
    if !isInitpresence {
     return isInitpresence
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementpresence in presence {
        try output.writeMessage(1, value:oneElementpresence)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementpresence in presence {
        serialize_size += oneElementpresence.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<PresenceNotification> {
    var mergedArray = Array<PresenceNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> PresenceNotification? {
    return try PresenceNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceNotification {
    return try PresenceNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PresenceNotification.Builder {
    return PresenceNotification.classBuilder() as! PresenceNotification.Builder
  }
  public func getBuilder() -> PresenceNotification.Builder {
    return classBuilder() as! PresenceNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PresenceNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PresenceNotification.Builder()
  }
  public func toBuilder() throws -> PresenceNotification.Builder {
    return try PresenceNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PresenceNotification) throws -> PresenceNotification.Builder {
    return try PresenceNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var presenceElementIndex:Int = 0
    for oneElementpresence in presence {
        output += "\(indent) presence[\(presenceElementIndex)] {\n"
        output += try oneElementpresence.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        presenceElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementpresence in presence {
              hashCode = (hashCode &* 31) &+ oneElementpresence.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PresenceNotification"
  }
  override public func className() -> String {
      return "PresenceNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PresenceNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PresenceNotification = PresenceNotification()
    public func getMessage() -> PresenceNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var presence:Array<PresenceResult> {
         get {
             return builderResult.presence
         }
         set (value) {
             builderResult.presence = value
         }
    }
    public func setPresence(_ value:Array<PresenceResult>) -> PresenceNotification.Builder {
      self.presence = value
      return self
    }
    public func clearPresence() -> PresenceNotification.Builder {
      builderResult.presence.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PresenceNotification.Builder {
      builderResult = PresenceNotification()
      return self
    }
    public override func clone() throws -> PresenceNotification.Builder {
      return try PresenceNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> PresenceNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PresenceNotification {
      let returnMe:PresenceNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PresenceNotification) throws -> PresenceNotification.Builder {
      if other == PresenceNotification() {
       return self
      }
      if !other.presence.isEmpty  {
         builderResult.presence += other.presence
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PresenceNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PresenceNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = PresenceResult.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          presence += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class BlockNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var blockStateChange:Array<BlockStateChange>  = Array<BlockStateChange>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementblockStateChange in blockStateChange {
        try output.writeMessage(1, value:oneElementblockStateChange)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementblockStateChange in blockStateChange {
        serialize_size += oneElementblockStateChange.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<BlockNotification> {
    var mergedArray = Array<BlockNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> BlockNotification? {
    return try BlockNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockNotification {
    return try BlockNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> BlockNotification.Builder {
    return BlockNotification.classBuilder() as! BlockNotification.Builder
  }
  public func getBuilder() -> BlockNotification.Builder {
    return classBuilder() as! BlockNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return BlockNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return BlockNotification.Builder()
  }
  public func toBuilder() throws -> BlockNotification.Builder {
    return try BlockNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:BlockNotification) throws -> BlockNotification.Builder {
    return try BlockNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var blockStateChangeElementIndex:Int = 0
    for oneElementblockStateChange in blockStateChange {
        output += "\(indent) blockStateChange[\(blockStateChangeElementIndex)] {\n"
        output += try oneElementblockStateChange.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        blockStateChangeElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementblockStateChange in blockStateChange {
              hashCode = (hashCode &* 31) &+ oneElementblockStateChange.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BlockNotification"
  }
  override public func className() -> String {
      return "BlockNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BlockNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:BlockNotification = BlockNotification()
    public func getMessage() -> BlockNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var blockStateChange:Array<BlockStateChange> {
         get {
             return builderResult.blockStateChange
         }
         set (value) {
             builderResult.blockStateChange = value
         }
    }
    public func setBlockStateChange(_ value:Array<BlockStateChange>) -> BlockNotification.Builder {
      self.blockStateChange = value
      return self
    }
    public func clearBlockStateChange() -> BlockNotification.Builder {
      builderResult.blockStateChange.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> BlockNotification.Builder {
      builderResult = BlockNotification()
      return self
    }
    public override func clone() throws -> BlockNotification.Builder {
      return try BlockNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> BlockNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> BlockNotification {
      let returnMe:BlockNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:BlockNotification) throws -> BlockNotification.Builder {
      if other == BlockNotification() {
       return self
      }
      if !other.blockStateChange.isEmpty  {
         builderResult.blockStateChange += other.blockStateChange
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> BlockNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BlockNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = BlockStateChange.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          blockStateChange += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetNotificationSettingNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var desktopSoundSetting:DesktopSoundSetting!
  public private(set) var hasDesktopSoundSetting:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasDesktopSoundSetting {
      try output.writeMessage(2, value:desktopSoundSetting)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasDesktopSoundSetting {
        if let varSizedesktopSoundSetting = desktopSoundSetting?.computeMessageSize(2) {
            serialize_size += varSizedesktopSoundSetting
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetNotificationSettingNotification> {
    var mergedArray = Array<SetNotificationSettingNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetNotificationSettingNotification? {
    return try SetNotificationSettingNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetNotificationSettingNotification {
    return try SetNotificationSettingNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetNotificationSettingNotification.Builder {
    return SetNotificationSettingNotification.classBuilder() as! SetNotificationSettingNotification.Builder
  }
  public func getBuilder() -> SetNotificationSettingNotification.Builder {
    return classBuilder() as! SetNotificationSettingNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetNotificationSettingNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetNotificationSettingNotification.Builder()
  }
  public func toBuilder() throws -> SetNotificationSettingNotification.Builder {
    return try SetNotificationSettingNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetNotificationSettingNotification) throws -> SetNotificationSettingNotification.Builder {
    return try SetNotificationSettingNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasDesktopSoundSetting {
      output += "\(indent) desktopSoundSetting {\n"
      if let outDescDesktopSoundSetting = desktopSoundSetting {
        output += try outDescDesktopSoundSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDesktopSoundSetting {
              if let hashValuedesktopSoundSetting = desktopSoundSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopSoundSetting
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetNotificationSettingNotification"
  }
  override public func className() -> String {
      return "SetNotificationSettingNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetNotificationSettingNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetNotificationSettingNotification = SetNotificationSettingNotification()
    public func getMessage() -> SetNotificationSettingNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasDesktopSoundSetting:Bool {
         get {
             return builderResult.hasDesktopSoundSetting
         }
    }
    public var desktopSoundSetting:DesktopSoundSetting! {
         get {
             if desktopSoundSettingBuilder_ != nil {
                builderResult.desktopSoundSetting = desktopSoundSettingBuilder_.getMessage()
             }
             return builderResult.desktopSoundSetting
         }
         set (value) {
             builderResult.hasDesktopSoundSetting = true
             builderResult.desktopSoundSetting = value
         }
    }
    private var desktopSoundSettingBuilder_:DesktopSoundSetting.Builder! {
         didSet {
            builderResult.hasDesktopSoundSetting = true
         }
    }
    public func getDesktopSoundSettingBuilder() -> DesktopSoundSetting.Builder {
      if desktopSoundSettingBuilder_ == nil {
         desktopSoundSettingBuilder_ = DesktopSoundSetting.Builder()
         builderResult.desktopSoundSetting = desktopSoundSettingBuilder_.getMessage()
         if desktopSoundSetting != nil {
            try! desktopSoundSettingBuilder_.mergeFrom(desktopSoundSetting)
         }
      }
      return desktopSoundSettingBuilder_
    }
    public func setDesktopSoundSetting(_ value:DesktopSoundSetting!) -> SetNotificationSettingNotification.Builder {
      self.desktopSoundSetting = value
      return self
    }
    public func mergeDesktopSoundSetting(_ value:DesktopSoundSetting) throws -> SetNotificationSettingNotification.Builder {
      if builderResult.hasDesktopSoundSetting {
        builderResult.desktopSoundSetting = try DesktopSoundSetting.builderWithPrototype(builderResult.desktopSoundSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopSoundSetting = value
      }
      builderResult.hasDesktopSoundSetting = true
      return self
    }
    public func clearDesktopSoundSetting() -> SetNotificationSettingNotification.Builder {
      desktopSoundSettingBuilder_ = nil
      builderResult.hasDesktopSoundSetting = false
      builderResult.desktopSoundSetting = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetNotificationSettingNotification.Builder {
      builderResult = SetNotificationSettingNotification()
      return self
    }
    public override func clone() throws -> SetNotificationSettingNotification.Builder {
      return try SetNotificationSettingNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetNotificationSettingNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetNotificationSettingNotification {
      let returnMe:SetNotificationSettingNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetNotificationSettingNotification) throws -> SetNotificationSettingNotification.Builder {
      if other == SetNotificationSettingNotification() {
       return self
      }
      if (other.hasDesktopSoundSetting) {
          try mergeDesktopSoundSetting(other.desktopSoundSetting)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetNotificationSettingNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetNotificationSettingNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 18:
          let subBuilder:DesktopSoundSetting.Builder = DesktopSoundSetting.Builder()
          if hasDesktopSoundSetting {
            try subBuilder.mergeFrom(desktopSoundSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopSoundSetting = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RichPresenceEnabledStateNotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var richPresenceEnabledState:Array<RichPresenceEnabledState>  = Array<RichPresenceEnabledState>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    for oneElementrichPresenceEnabledState in richPresenceEnabledState {
        try output.writeMessage(1, value:oneElementrichPresenceEnabledState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementrichPresenceEnabledState in richPresenceEnabledState {
        serialize_size += oneElementrichPresenceEnabledState.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RichPresenceEnabledStateNotification> {
    var mergedArray = Array<RichPresenceEnabledStateNotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RichPresenceEnabledStateNotification? {
    return try RichPresenceEnabledStateNotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledStateNotification {
    return try RichPresenceEnabledStateNotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RichPresenceEnabledStateNotification.Builder {
    return RichPresenceEnabledStateNotification.classBuilder() as! RichPresenceEnabledStateNotification.Builder
  }
  public func getBuilder() -> RichPresenceEnabledStateNotification.Builder {
    return classBuilder() as! RichPresenceEnabledStateNotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RichPresenceEnabledStateNotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RichPresenceEnabledStateNotification.Builder()
  }
  public func toBuilder() throws -> RichPresenceEnabledStateNotification.Builder {
    return try RichPresenceEnabledStateNotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RichPresenceEnabledStateNotification) throws -> RichPresenceEnabledStateNotification.Builder {
    return try RichPresenceEnabledStateNotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    var richPresenceEnabledStateElementIndex:Int = 0
    for oneElementrichPresenceEnabledState in richPresenceEnabledState {
        output += "\(indent) richPresenceEnabledState[\(richPresenceEnabledStateElementIndex)] {\n"
        output += try oneElementrichPresenceEnabledState.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        richPresenceEnabledStateElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementrichPresenceEnabledState in richPresenceEnabledState {
              hashCode = (hashCode &* 31) &+ oneElementrichPresenceEnabledState.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RichPresenceEnabledStateNotification"
  }
  override public func className() -> String {
      return "RichPresenceEnabledStateNotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RichPresenceEnabledStateNotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RichPresenceEnabledStateNotification = RichPresenceEnabledStateNotification()
    public func getMessage() -> RichPresenceEnabledStateNotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var richPresenceEnabledState:Array<RichPresenceEnabledState> {
         get {
             return builderResult.richPresenceEnabledState
         }
         set (value) {
             builderResult.richPresenceEnabledState = value
         }
    }
    public func setRichPresenceEnabledState(_ value:Array<RichPresenceEnabledState>) -> RichPresenceEnabledStateNotification.Builder {
      self.richPresenceEnabledState = value
      return self
    }
    public func clearRichPresenceEnabledState() -> RichPresenceEnabledStateNotification.Builder {
      builderResult.richPresenceEnabledState.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RichPresenceEnabledStateNotification.Builder {
      builderResult = RichPresenceEnabledStateNotification()
      return self
    }
    public override func clone() throws -> RichPresenceEnabledStateNotification.Builder {
      return try RichPresenceEnabledStateNotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RichPresenceEnabledStateNotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RichPresenceEnabledStateNotification {
      let returnMe:RichPresenceEnabledStateNotification = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RichPresenceEnabledStateNotification) throws -> RichPresenceEnabledStateNotification.Builder {
      if other == RichPresenceEnabledStateNotification() {
       return self
      }
      if !other.richPresenceEnabledState.isEmpty  {
         builderResult.richPresenceEnabledState += other.richPresenceEnabledState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RichPresenceEnabledStateNotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RichPresenceEnabledStateNotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = RichPresenceEnabledState.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          richPresenceEnabledState += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConversationSpec : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasConversationId {
      try output.writeMessage(1, value:conversationId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(1) {
            serialize_size += varSizeconversationId
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<ConversationSpec> {
    var mergedArray = Array<ConversationSpec>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> ConversationSpec? {
    return try ConversationSpec.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationSpec {
    return try ConversationSpec.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConversationSpec.Builder {
    return ConversationSpec.classBuilder() as! ConversationSpec.Builder
  }
  public func getBuilder() -> ConversationSpec.Builder {
    return classBuilder() as! ConversationSpec.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConversationSpec.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConversationSpec.Builder()
  }
  public func toBuilder() throws -> ConversationSpec.Builder {
    return try ConversationSpec.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ConversationSpec) throws -> ConversationSpec.Builder {
    return try ConversationSpec.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConversationSpec"
  }
  override public func className() -> String {
      return "ConversationSpec"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConversationSpec.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConversationSpec = ConversationSpec()
    public func getMessage() -> ConversationSpec {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> ConversationSpec.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> ConversationSpec.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> ConversationSpec.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConversationSpec.Builder {
      builderResult = ConversationSpec()
      return self
    }
    public override func clone() throws -> ConversationSpec.Builder {
      return try ConversationSpec.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConversationSpec {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConversationSpec {
      let returnMe:ConversationSpec = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ConversationSpec) throws -> ConversationSpec.Builder {
      if other == ConversationSpec() {
       return self
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ConversationSpec.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConversationSpec.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class OffnetworkAddress : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var types:OffnetworkAddressType = OffnetworkAddressType.OffnetworkAddressTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var email:String = ""

  public private(set) var hasEmail:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    if hasEmail {
      try output.writeString(3, value:email)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    if hasEmail {
      serialize_size += email.computeStringSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<OffnetworkAddress> {
    var mergedArray = Array<OffnetworkAddress>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> OffnetworkAddress? {
    return try OffnetworkAddress.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> OffnetworkAddress {
    return try OffnetworkAddress.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> OffnetworkAddress.Builder {
    return OffnetworkAddress.classBuilder() as! OffnetworkAddress.Builder
  }
  public func getBuilder() -> OffnetworkAddress.Builder {
    return classBuilder() as! OffnetworkAddress.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return OffnetworkAddress.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return OffnetworkAddress.Builder()
  }
  public func toBuilder() throws -> OffnetworkAddress.Builder {
    return try OffnetworkAddress.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:OffnetworkAddress) throws -> OffnetworkAddress.Builder {
    return try OffnetworkAddress.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasEmail {
      output += "\(indent) email: \(email) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasEmail {
             hashCode = (hashCode &* 31) &+ email.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "OffnetworkAddress"
  }
  override public func className() -> String {
      return "OffnetworkAddress"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return OffnetworkAddress.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:OffnetworkAddress = OffnetworkAddress()
    public func getMessage() -> OffnetworkAddress {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:OffnetworkAddressType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:OffnetworkAddressType) -> OffnetworkAddress.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> OffnetworkAddress.Builder {
         builderResult.hasTypes = false
         builderResult.types = .OffnetworkAddressTypeUnknown
         return self
      }
    public var hasEmail:Bool {
         get {
              return builderResult.hasEmail
         }
    }
    public var email:String {
         get {
              return builderResult.email
         }
         set (value) {
             builderResult.hasEmail = true
             builderResult.email = value
         }
    }
    public func setEmail(_ value:String) -> OffnetworkAddress.Builder {
      self.email = value
      return self
    }
    public func clearEmail() -> OffnetworkAddress.Builder{
         builderResult.hasEmail = false
         builderResult.email = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> OffnetworkAddress.Builder {
      builderResult = OffnetworkAddress()
      return self
    }
    public override func clone() throws -> OffnetworkAddress.Builder {
      return try OffnetworkAddress.builderWithPrototype(builderResult)
    }
    public override func build() throws -> OffnetworkAddress {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> OffnetworkAddress {
      let returnMe:OffnetworkAddress = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:OffnetworkAddress) throws -> OffnetworkAddress.Builder {
      if other == OffnetworkAddress() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasEmail {
           email = other.email
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> OffnetworkAddress.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> OffnetworkAddress.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = OffnetworkAddressType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        case 26:
          email = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EntityResult : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var lookupSpec:EntityLookupSpec!
  public private(set) var hasLookupSpec:Bool = false
  public private(set) var entity:Array<Entity>  = Array<Entity>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitentity:Bool = true
    for oneElemententity in entity {
        if (!oneElemententity.isInitialized()) {
            isInitentity = false
            break 
        }
    }
    if !isInitentity {
     return isInitentity
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasLookupSpec {
      try output.writeMessage(1, value:lookupSpec)
    }
    for oneElemententity in entity {
        try output.writeMessage(2, value:oneElemententity)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLookupSpec {
        if let varSizelookupSpec = lookupSpec?.computeMessageSize(1) {
            serialize_size += varSizelookupSpec
        }
    }
    for oneElemententity in entity {
        serialize_size += oneElemententity.computeMessageSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EntityResult> {
    var mergedArray = Array<EntityResult>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EntityResult? {
    return try EntityResult.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityResult {
    return try EntityResult.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EntityResult.Builder {
    return EntityResult.classBuilder() as! EntityResult.Builder
  }
  public func getBuilder() -> EntityResult.Builder {
    return classBuilder() as! EntityResult.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EntityResult.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EntityResult.Builder()
  }
  public func toBuilder() throws -> EntityResult.Builder {
    return try EntityResult.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EntityResult) throws -> EntityResult.Builder {
    return try EntityResult.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasLookupSpec {
      output += "\(indent) lookupSpec {\n"
      if let outDescLookupSpec = lookupSpec {
        output += try outDescLookupSpec.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var entityElementIndex:Int = 0
    for oneElemententity in entity {
        output += "\(indent) entity[\(entityElementIndex)] {\n"
        output += try oneElemententity.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        entityElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLookupSpec {
              if let hashValuelookupSpec = lookupSpec?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuelookupSpec
              }
          }
          for oneElemententity in entity {
              hashCode = (hashCode &* 31) &+ oneElemententity.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EntityResult"
  }
  override public func className() -> String {
      return "EntityResult"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EntityResult.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EntityResult = EntityResult()
    public func getMessage() -> EntityResult {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasLookupSpec:Bool {
         get {
             return builderResult.hasLookupSpec
         }
    }
    public var lookupSpec:EntityLookupSpec! {
         get {
             if lookupSpecBuilder_ != nil {
                builderResult.lookupSpec = lookupSpecBuilder_.getMessage()
             }
             return builderResult.lookupSpec
         }
         set (value) {
             builderResult.hasLookupSpec = true
             builderResult.lookupSpec = value
         }
    }
    private var lookupSpecBuilder_:EntityLookupSpec.Builder! {
         didSet {
            builderResult.hasLookupSpec = true
         }
    }
    public func getLookupSpecBuilder() -> EntityLookupSpec.Builder {
      if lookupSpecBuilder_ == nil {
         lookupSpecBuilder_ = EntityLookupSpec.Builder()
         builderResult.lookupSpec = lookupSpecBuilder_.getMessage()
         if lookupSpec != nil {
            try! lookupSpecBuilder_.mergeFrom(lookupSpec)
         }
      }
      return lookupSpecBuilder_
    }
    public func setLookupSpec(_ value:EntityLookupSpec!) -> EntityResult.Builder {
      self.lookupSpec = value
      return self
    }
    public func mergeLookupSpec(_ value:EntityLookupSpec) throws -> EntityResult.Builder {
      if builderResult.hasLookupSpec {
        builderResult.lookupSpec = try EntityLookupSpec.builderWithPrototype(builderResult.lookupSpec).mergeFrom(value).buildPartial()
      } else {
        builderResult.lookupSpec = value
      }
      builderResult.hasLookupSpec = true
      return self
    }
    public func clearLookupSpec() -> EntityResult.Builder {
      lookupSpecBuilder_ = nil
      builderResult.hasLookupSpec = false
      builderResult.lookupSpec = nil
      return self
    }
    public var entity:Array<Entity> {
         get {
             return builderResult.entity
         }
         set (value) {
             builderResult.entity = value
         }
    }
    public func setEntity(_ value:Array<Entity>) -> EntityResult.Builder {
      self.entity = value
      return self
    }
    public func clearEntity() -> EntityResult.Builder {
      builderResult.entity.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EntityResult.Builder {
      builderResult = EntityResult()
      return self
    }
    public override func clone() throws -> EntityResult.Builder {
      return try EntityResult.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EntityResult {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EntityResult {
      let returnMe:EntityResult = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EntityResult) throws -> EntityResult.Builder {
      if other == EntityResult() {
       return self
      }
      if (other.hasLookupSpec) {
          try mergeLookupSpec(other.lookupSpec)
      }
      if !other.entity.isEmpty  {
         builderResult.entity += other.entity
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EntityResult.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EntityResult.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:EntityLookupSpec.Builder = EntityLookupSpec.Builder()
          if hasLookupSpec {
            try subBuilder.mergeFrom(lookupSpec)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          lookupSpec = subBuilder.buildPartial()

        case 18:
          let subBuilder = Entity.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          entity += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class AddUserRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var inviteeId:Array<InviteeId>  = Array<InviteeId>()
  public private(set) var eventRequestHeader:EventRequestHeader!
  public private(set) var hasEventRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    for oneElementinviteeId in inviteeId {
        try output.writeMessage(3, value:oneElementinviteeId)
    }
    if hasEventRequestHeader {
      try output.writeMessage(5, value:eventRequestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    for oneElementinviteeId in inviteeId {
        serialize_size += oneElementinviteeId.computeMessageSize(3)
    }
    if hasEventRequestHeader {
        if let varSizeeventRequestHeader = eventRequestHeader?.computeMessageSize(5) {
            serialize_size += varSizeeventRequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<AddUserRequest> {
    var mergedArray = Array<AddUserRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> AddUserRequest? {
    return try AddUserRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserRequest {
    return try AddUserRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> AddUserRequest.Builder {
    return AddUserRequest.classBuilder() as! AddUserRequest.Builder
  }
  public func getBuilder() -> AddUserRequest.Builder {
    return classBuilder() as! AddUserRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return AddUserRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return AddUserRequest.Builder()
  }
  public func toBuilder() throws -> AddUserRequest.Builder {
    return try AddUserRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:AddUserRequest) throws -> AddUserRequest.Builder {
    return try AddUserRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var inviteeIdElementIndex:Int = 0
    for oneElementinviteeId in inviteeId {
        output += "\(indent) inviteeId[\(inviteeIdElementIndex)] {\n"
        output += try oneElementinviteeId.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        inviteeIdElementIndex += 1
    }
    if hasEventRequestHeader {
      output += "\(indent) eventRequestHeader {\n"
      if let outDescEventRequestHeader = eventRequestHeader {
        output += try outDescEventRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          for oneElementinviteeId in inviteeId {
              hashCode = (hashCode &* 31) &+ oneElementinviteeId.hashValue
          }
          if hasEventRequestHeader {
              if let hashValueeventRequestHeader = eventRequestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventRequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "AddUserRequest"
  }
  override public func className() -> String {
      return "AddUserRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return AddUserRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:AddUserRequest = AddUserRequest()
    public func getMessage() -> AddUserRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> AddUserRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> AddUserRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> AddUserRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var inviteeId:Array<InviteeId> {
         get {
             return builderResult.inviteeId
         }
         set (value) {
             builderResult.inviteeId = value
         }
    }
    public func setInviteeId(_ value:Array<InviteeId>) -> AddUserRequest.Builder {
      self.inviteeId = value
      return self
    }
    public func clearInviteeId() -> AddUserRequest.Builder {
      builderResult.inviteeId.removeAll(keepingCapacity: false)
      return self
    }
    public var hasEventRequestHeader:Bool {
         get {
             return builderResult.hasEventRequestHeader
         }
    }
    public var eventRequestHeader:EventRequestHeader! {
         get {
             if eventRequestHeaderBuilder_ != nil {
                builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
             }
             return builderResult.eventRequestHeader
         }
         set (value) {
             builderResult.hasEventRequestHeader = true
             builderResult.eventRequestHeader = value
         }
    }
    private var eventRequestHeaderBuilder_:EventRequestHeader.Builder! {
         didSet {
            builderResult.hasEventRequestHeader = true
         }
    }
    public func getEventRequestHeaderBuilder() -> EventRequestHeader.Builder {
      if eventRequestHeaderBuilder_ == nil {
         eventRequestHeaderBuilder_ = EventRequestHeader.Builder()
         builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
         if eventRequestHeader != nil {
            try! eventRequestHeaderBuilder_.mergeFrom(eventRequestHeader)
         }
      }
      return eventRequestHeaderBuilder_
    }
    public func setEventRequestHeader(_ value:EventRequestHeader!) -> AddUserRequest.Builder {
      self.eventRequestHeader = value
      return self
    }
    public func mergeEventRequestHeader(_ value:EventRequestHeader) throws -> AddUserRequest.Builder {
      if builderResult.hasEventRequestHeader {
        builderResult.eventRequestHeader = try EventRequestHeader.builderWithPrototype(builderResult.eventRequestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventRequestHeader = value
      }
      builderResult.hasEventRequestHeader = true
      return self
    }
    public func clearEventRequestHeader() -> AddUserRequest.Builder {
      eventRequestHeaderBuilder_ = nil
      builderResult.hasEventRequestHeader = false
      builderResult.eventRequestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> AddUserRequest.Builder {
      builderResult = AddUserRequest()
      return self
    }
    public override func clone() throws -> AddUserRequest.Builder {
      return try AddUserRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> AddUserRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> AddUserRequest {
      let returnMe:AddUserRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:AddUserRequest) throws -> AddUserRequest.Builder {
      if other == AddUserRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if !other.inviteeId.isEmpty  {
         builderResult.inviteeId += other.inviteeId
      }
      if (other.hasEventRequestHeader) {
          try mergeEventRequestHeader(other.eventRequestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> AddUserRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 26:
          let subBuilder = InviteeId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          inviteeId += [subBuilder.buildPartial()]

        case 42:
          let subBuilder:EventRequestHeader.Builder = EventRequestHeader.Builder()
          if hasEventRequestHeader {
            try subBuilder.mergeFrom(eventRequestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventRequestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class AddUserResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var createdEvent:Event!
  public private(set) var hasCreatedEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasCreatedEvent {
     if !createdEvent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasCreatedEvent {
      try output.writeMessage(5, value:createdEvent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasCreatedEvent {
        if let varSizecreatedEvent = createdEvent?.computeMessageSize(5) {
            serialize_size += varSizecreatedEvent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<AddUserResponse> {
    var mergedArray = Array<AddUserResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> AddUserResponse? {
    return try AddUserResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserResponse {
    return try AddUserResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> AddUserResponse.Builder {
    return AddUserResponse.classBuilder() as! AddUserResponse.Builder
  }
  public func getBuilder() -> AddUserResponse.Builder {
    return classBuilder() as! AddUserResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return AddUserResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return AddUserResponse.Builder()
  }
  public func toBuilder() throws -> AddUserResponse.Builder {
    return try AddUserResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:AddUserResponse) throws -> AddUserResponse.Builder {
    return try AddUserResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCreatedEvent {
      output += "\(indent) createdEvent {\n"
      if let outDescCreatedEvent = createdEvent {
        output += try outDescCreatedEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasCreatedEvent {
              if let hashValuecreatedEvent = createdEvent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecreatedEvent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "AddUserResponse"
  }
  override public func className() -> String {
      return "AddUserResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return AddUserResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:AddUserResponse = AddUserResponse()
    public func getMessage() -> AddUserResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> AddUserResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> AddUserResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> AddUserResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasCreatedEvent:Bool {
         get {
             return builderResult.hasCreatedEvent
         }
    }
    public var createdEvent:Event! {
         get {
             if createdEventBuilder_ != nil {
                builderResult.createdEvent = createdEventBuilder_.getMessage()
             }
             return builderResult.createdEvent
         }
         set (value) {
             builderResult.hasCreatedEvent = true
             builderResult.createdEvent = value
         }
    }
    private var createdEventBuilder_:Event.Builder! {
         didSet {
            builderResult.hasCreatedEvent = true
         }
    }
    public func getCreatedEventBuilder() -> Event.Builder {
      if createdEventBuilder_ == nil {
         createdEventBuilder_ = Event.Builder()
         builderResult.createdEvent = createdEventBuilder_.getMessage()
         if createdEvent != nil {
            try! createdEventBuilder_.mergeFrom(createdEvent)
         }
      }
      return createdEventBuilder_
    }
    public func setCreatedEvent(_ value:Event!) -> AddUserResponse.Builder {
      self.createdEvent = value
      return self
    }
    public func mergeCreatedEvent(_ value:Event) throws -> AddUserResponse.Builder {
      if builderResult.hasCreatedEvent {
        builderResult.createdEvent = try Event.builderWithPrototype(builderResult.createdEvent).mergeFrom(value).buildPartial()
      } else {
        builderResult.createdEvent = value
      }
      builderResult.hasCreatedEvent = true
      return self
    }
    public func clearCreatedEvent() -> AddUserResponse.Builder {
      createdEventBuilder_ = nil
      builderResult.hasCreatedEvent = false
      builderResult.createdEvent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> AddUserResponse.Builder {
      builderResult = AddUserResponse()
      return self
    }
    public override func clone() throws -> AddUserResponse.Builder {
      return try AddUserResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> AddUserResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> AddUserResponse {
      let returnMe:AddUserResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:AddUserResponse) throws -> AddUserResponse.Builder {
      if other == AddUserResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasCreatedEvent) {
          try mergeCreatedEvent(other.createdEvent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> AddUserResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AddUserResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 42:
          let subBuilder:Event.Builder = Event.Builder()
          if hasCreatedEvent {
            try subBuilder.mergeFrom(createdEvent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          createdEvent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class CreateConversationRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var types:ConversationType = ConversationType.ConversationTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var clientGeneratedId:UInt64 = UInt64(0)

  public private(set) var hasClientGeneratedId:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var inviteeId:Array<InviteeId>  = Array<InviteeId>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasTypes {
      try output.writeEnum(2, value:types.rawValue)
    }
    if hasClientGeneratedId {
      try output.writeUInt64(3, value:clientGeneratedId)
    }
    if hasName {
      try output.writeString(4, value:name)
    }
    for oneElementinviteeId in inviteeId {
        try output.writeMessage(5, value:oneElementinviteeId)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(2)
    }
    if hasClientGeneratedId {
      serialize_size += clientGeneratedId.computeUInt64Size(3)
    }
    if hasName {
      serialize_size += name.computeStringSize(4)
    }
    for oneElementinviteeId in inviteeId {
        serialize_size += oneElementinviteeId.computeMessageSize(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<CreateConversationRequest> {
    var mergedArray = Array<CreateConversationRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> CreateConversationRequest? {
    return try CreateConversationRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationRequest {
    return try CreateConversationRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> CreateConversationRequest.Builder {
    return CreateConversationRequest.classBuilder() as! CreateConversationRequest.Builder
  }
  public func getBuilder() -> CreateConversationRequest.Builder {
    return classBuilder() as! CreateConversationRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return CreateConversationRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return CreateConversationRequest.Builder()
  }
  public func toBuilder() throws -> CreateConversationRequest.Builder {
    return try CreateConversationRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:CreateConversationRequest) throws -> CreateConversationRequest.Builder {
    return try CreateConversationRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasClientGeneratedId {
      output += "\(indent) clientGeneratedId: \(clientGeneratedId) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    var inviteeIdElementIndex:Int = 0
    for oneElementinviteeId in inviteeId {
        output += "\(indent) inviteeId[\(inviteeIdElementIndex)] {\n"
        output += try oneElementinviteeId.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        inviteeIdElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasClientGeneratedId {
             hashCode = (hashCode &* 31) &+ clientGeneratedId.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          for oneElementinviteeId in inviteeId {
              hashCode = (hashCode &* 31) &+ oneElementinviteeId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CreateConversationRequest"
  }
  override public func className() -> String {
      return "CreateConversationRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return CreateConversationRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:CreateConversationRequest = CreateConversationRequest()
    public func getMessage() -> CreateConversationRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> CreateConversationRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> CreateConversationRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> CreateConversationRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ConversationType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ConversationType) -> CreateConversationRequest.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> CreateConversationRequest.Builder {
         builderResult.hasTypes = false
         builderResult.types = .ConversationTypeUnknown
         return self
      }
    public var hasClientGeneratedId:Bool {
         get {
              return builderResult.hasClientGeneratedId
         }
    }
    public var clientGeneratedId:UInt64 {
         get {
              return builderResult.clientGeneratedId
         }
         set (value) {
             builderResult.hasClientGeneratedId = true
             builderResult.clientGeneratedId = value
         }
    }
    public func setClientGeneratedId(_ value:UInt64) -> CreateConversationRequest.Builder {
      self.clientGeneratedId = value
      return self
    }
    public func clearClientGeneratedId() -> CreateConversationRequest.Builder{
         builderResult.hasClientGeneratedId = false
         builderResult.clientGeneratedId = UInt64(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> CreateConversationRequest.Builder {
      self.name = value
      return self
    }
    public func clearName() -> CreateConversationRequest.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var inviteeId:Array<InviteeId> {
         get {
             return builderResult.inviteeId
         }
         set (value) {
             builderResult.inviteeId = value
         }
    }
    public func setInviteeId(_ value:Array<InviteeId>) -> CreateConversationRequest.Builder {
      self.inviteeId = value
      return self
    }
    public func clearInviteeId() -> CreateConversationRequest.Builder {
      builderResult.inviteeId.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> CreateConversationRequest.Builder {
      builderResult = CreateConversationRequest()
      return self
    }
    public override func clone() throws -> CreateConversationRequest.Builder {
      return try CreateConversationRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> CreateConversationRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CreateConversationRequest {
      let returnMe:CreateConversationRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:CreateConversationRequest) throws -> CreateConversationRequest.Builder {
      if other == CreateConversationRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasClientGeneratedId {
           clientGeneratedId = other.clientGeneratedId
      }
      if other.hasName {
           name = other.name
      }
      if !other.inviteeId.isEmpty  {
         builderResult.inviteeId += other.inviteeId
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> CreateConversationRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 16:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ConversationType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueInttypes))
          }

        case 24:
          clientGeneratedId = try input.readUInt64()

        case 34:
          name = try input.readString()

        case 42:
          let subBuilder = InviteeId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          inviteeId += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class CreateConversationResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var conversation:Conversation!
  public private(set) var hasConversation:Bool = false
  public private(set) var newConversationCreated:Bool = false

  public private(set) var hasNewConversationCreated:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasConversation {
      try output.writeMessage(2, value:conversation)
    }
    if hasNewConversationCreated {
      try output.writeBool(7, value:newConversationCreated)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasConversation {
        if let varSizeconversation = conversation?.computeMessageSize(2) {
            serialize_size += varSizeconversation
        }
    }
    if hasNewConversationCreated {
      serialize_size += newConversationCreated.computeBoolSize(7)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<CreateConversationResponse> {
    var mergedArray = Array<CreateConversationResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> CreateConversationResponse? {
    return try CreateConversationResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationResponse {
    return try CreateConversationResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> CreateConversationResponse.Builder {
    return CreateConversationResponse.classBuilder() as! CreateConversationResponse.Builder
  }
  public func getBuilder() -> CreateConversationResponse.Builder {
    return classBuilder() as! CreateConversationResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return CreateConversationResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return CreateConversationResponse.Builder()
  }
  public func toBuilder() throws -> CreateConversationResponse.Builder {
    return try CreateConversationResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:CreateConversationResponse) throws -> CreateConversationResponse.Builder {
    return try CreateConversationResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversation {
      output += "\(indent) conversation {\n"
      if let outDescConversation = conversation {
        output += try outDescConversation.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNewConversationCreated {
      output += "\(indent) newConversationCreated: \(newConversationCreated) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasConversation {
              if let hashValueconversation = conversation?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversation
              }
          }
          if hasNewConversationCreated {
             hashCode = (hashCode &* 31) &+ newConversationCreated.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CreateConversationResponse"
  }
  override public func className() -> String {
      return "CreateConversationResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return CreateConversationResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:CreateConversationResponse = CreateConversationResponse()
    public func getMessage() -> CreateConversationResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> CreateConversationResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> CreateConversationResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> CreateConversationResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasConversation:Bool {
         get {
             return builderResult.hasConversation
         }
    }
    public var conversation:Conversation! {
         get {
             if conversationBuilder_ != nil {
                builderResult.conversation = conversationBuilder_.getMessage()
             }
             return builderResult.conversation
         }
         set (value) {
             builderResult.hasConversation = true
             builderResult.conversation = value
         }
    }
    private var conversationBuilder_:Conversation.Builder! {
         didSet {
            builderResult.hasConversation = true
         }
    }
    public func getConversationBuilder() -> Conversation.Builder {
      if conversationBuilder_ == nil {
         conversationBuilder_ = Conversation.Builder()
         builderResult.conversation = conversationBuilder_.getMessage()
         if conversation != nil {
            try! conversationBuilder_.mergeFrom(conversation)
         }
      }
      return conversationBuilder_
    }
    public func setConversation(_ value:Conversation!) -> CreateConversationResponse.Builder {
      self.conversation = value
      return self
    }
    public func mergeConversation(_ value:Conversation) throws -> CreateConversationResponse.Builder {
      if builderResult.hasConversation {
        builderResult.conversation = try Conversation.builderWithPrototype(builderResult.conversation).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversation = value
      }
      builderResult.hasConversation = true
      return self
    }
    public func clearConversation() -> CreateConversationResponse.Builder {
      conversationBuilder_ = nil
      builderResult.hasConversation = false
      builderResult.conversation = nil
      return self
    }
    public var hasNewConversationCreated:Bool {
         get {
              return builderResult.hasNewConversationCreated
         }
    }
    public var newConversationCreated:Bool {
         get {
              return builderResult.newConversationCreated
         }
         set (value) {
             builderResult.hasNewConversationCreated = true
             builderResult.newConversationCreated = value
         }
    }
    public func setNewConversationCreated(_ value:Bool) -> CreateConversationResponse.Builder {
      self.newConversationCreated = value
      return self
    }
    public func clearNewConversationCreated() -> CreateConversationResponse.Builder{
         builderResult.hasNewConversationCreated = false
         builderResult.newConversationCreated = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> CreateConversationResponse.Builder {
      builderResult = CreateConversationResponse()
      return self
    }
    public override func clone() throws -> CreateConversationResponse.Builder {
      return try CreateConversationResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> CreateConversationResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CreateConversationResponse {
      let returnMe:CreateConversationResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:CreateConversationResponse) throws -> CreateConversationResponse.Builder {
      if other == CreateConversationResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasConversation) {
          try mergeConversation(other.conversation)
      }
      if other.hasNewConversationCreated {
           newConversationCreated = other.newConversationCreated
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> CreateConversationResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CreateConversationResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:Conversation.Builder = Conversation.Builder()
          if hasConversation {
            try subBuilder.mergeFrom(conversation)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversation = subBuilder.buildPartial()

        case 56:
          newConversationCreated = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeleteConversationRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var deleteUpperBoundTimestamp:UInt64 = UInt64(0)

  public private(set) var hasDeleteUpperBoundTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasDeleteUpperBoundTimestamp {
      try output.writeUInt64(3, value:deleteUpperBoundTimestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if hasDeleteUpperBoundTimestamp {
      serialize_size += deleteUpperBoundTimestamp.computeUInt64Size(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeleteConversationRequest> {
    var mergedArray = Array<DeleteConversationRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeleteConversationRequest? {
    return try DeleteConversationRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationRequest {
    return try DeleteConversationRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeleteConversationRequest.Builder {
    return DeleteConversationRequest.classBuilder() as! DeleteConversationRequest.Builder
  }
  public func getBuilder() -> DeleteConversationRequest.Builder {
    return classBuilder() as! DeleteConversationRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeleteConversationRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeleteConversationRequest.Builder()
  }
  public func toBuilder() throws -> DeleteConversationRequest.Builder {
    return try DeleteConversationRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeleteConversationRequest) throws -> DeleteConversationRequest.Builder {
    return try DeleteConversationRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDeleteUpperBoundTimestamp {
      output += "\(indent) deleteUpperBoundTimestamp: \(deleteUpperBoundTimestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasDeleteUpperBoundTimestamp {
             hashCode = (hashCode &* 31) &+ deleteUpperBoundTimestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeleteConversationRequest"
  }
  override public func className() -> String {
      return "DeleteConversationRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeleteConversationRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeleteConversationRequest = DeleteConversationRequest()
    public func getMessage() -> DeleteConversationRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> DeleteConversationRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> DeleteConversationRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> DeleteConversationRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> DeleteConversationRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> DeleteConversationRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> DeleteConversationRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasDeleteUpperBoundTimestamp:Bool {
         get {
              return builderResult.hasDeleteUpperBoundTimestamp
         }
    }
    public var deleteUpperBoundTimestamp:UInt64 {
         get {
              return builderResult.deleteUpperBoundTimestamp
         }
         set (value) {
             builderResult.hasDeleteUpperBoundTimestamp = true
             builderResult.deleteUpperBoundTimestamp = value
         }
    }
    public func setDeleteUpperBoundTimestamp(_ value:UInt64) -> DeleteConversationRequest.Builder {
      self.deleteUpperBoundTimestamp = value
      return self
    }
    public func clearDeleteUpperBoundTimestamp() -> DeleteConversationRequest.Builder{
         builderResult.hasDeleteUpperBoundTimestamp = false
         builderResult.deleteUpperBoundTimestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeleteConversationRequest.Builder {
      builderResult = DeleteConversationRequest()
      return self
    }
    public override func clone() throws -> DeleteConversationRequest.Builder {
      return try DeleteConversationRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeleteConversationRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeleteConversationRequest {
      let returnMe:DeleteConversationRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeleteConversationRequest) throws -> DeleteConversationRequest.Builder {
      if other == DeleteConversationRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasDeleteUpperBoundTimestamp {
           deleteUpperBoundTimestamp = other.deleteUpperBoundTimestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteConversationRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          deleteUpperBoundTimestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DeleteConversationResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var deleteAction:DeleteAction!
  public private(set) var hasDeleteAction:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasDeleteAction {
      try output.writeMessage(2, value:deleteAction)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasDeleteAction {
        if let varSizedeleteAction = deleteAction?.computeMessageSize(2) {
            serialize_size += varSizedeleteAction
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<DeleteConversationResponse> {
    var mergedArray = Array<DeleteConversationResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> DeleteConversationResponse? {
    return try DeleteConversationResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationResponse {
    return try DeleteConversationResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DeleteConversationResponse.Builder {
    return DeleteConversationResponse.classBuilder() as! DeleteConversationResponse.Builder
  }
  public func getBuilder() -> DeleteConversationResponse.Builder {
    return classBuilder() as! DeleteConversationResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return DeleteConversationResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return DeleteConversationResponse.Builder()
  }
  public func toBuilder() throws -> DeleteConversationResponse.Builder {
    return try DeleteConversationResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DeleteConversationResponse) throws -> DeleteConversationResponse.Builder {
    return try DeleteConversationResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDeleteAction {
      output += "\(indent) deleteAction {\n"
      if let outDescDeleteAction = deleteAction {
        output += try outDescDeleteAction.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasDeleteAction {
              if let hashValuedeleteAction = deleteAction?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedeleteAction
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DeleteConversationResponse"
  }
  override public func className() -> String {
      return "DeleteConversationResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DeleteConversationResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DeleteConversationResponse = DeleteConversationResponse()
    public func getMessage() -> DeleteConversationResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> DeleteConversationResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> DeleteConversationResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> DeleteConversationResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasDeleteAction:Bool {
         get {
             return builderResult.hasDeleteAction
         }
    }
    public var deleteAction:DeleteAction! {
         get {
             if deleteActionBuilder_ != nil {
                builderResult.deleteAction = deleteActionBuilder_.getMessage()
             }
             return builderResult.deleteAction
         }
         set (value) {
             builderResult.hasDeleteAction = true
             builderResult.deleteAction = value
         }
    }
    private var deleteActionBuilder_:DeleteAction.Builder! {
         didSet {
            builderResult.hasDeleteAction = true
         }
    }
    public func getDeleteActionBuilder() -> DeleteAction.Builder {
      if deleteActionBuilder_ == nil {
         deleteActionBuilder_ = DeleteAction.Builder()
         builderResult.deleteAction = deleteActionBuilder_.getMessage()
         if deleteAction != nil {
            try! deleteActionBuilder_.mergeFrom(deleteAction)
         }
      }
      return deleteActionBuilder_
    }
    public func setDeleteAction(_ value:DeleteAction!) -> DeleteConversationResponse.Builder {
      self.deleteAction = value
      return self
    }
    public func mergeDeleteAction(_ value:DeleteAction) throws -> DeleteConversationResponse.Builder {
      if builderResult.hasDeleteAction {
        builderResult.deleteAction = try DeleteAction.builderWithPrototype(builderResult.deleteAction).mergeFrom(value).buildPartial()
      } else {
        builderResult.deleteAction = value
      }
      builderResult.hasDeleteAction = true
      return self
    }
    public func clearDeleteAction() -> DeleteConversationResponse.Builder {
      deleteActionBuilder_ = nil
      builderResult.hasDeleteAction = false
      builderResult.deleteAction = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DeleteConversationResponse.Builder {
      builderResult = DeleteConversationResponse()
      return self
    }
    public override func clone() throws -> DeleteConversationResponse.Builder {
      return try DeleteConversationResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> DeleteConversationResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DeleteConversationResponse {
      let returnMe:DeleteConversationResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DeleteConversationResponse) throws -> DeleteConversationResponse.Builder {
      if other == DeleteConversationResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasDeleteAction) {
          try mergeDeleteAction(other.deleteAction)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DeleteConversationResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DeleteConversationResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:DeleteAction.Builder = DeleteAction.Builder()
          if hasDeleteAction {
            try subBuilder.mergeFrom(deleteAction)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          deleteAction = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EasterEggRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var easterEgg:EasterEgg!
  public private(set) var hasEasterEgg:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasEasterEgg {
      try output.writeMessage(3, value:easterEgg)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if hasEasterEgg {
        if let varSizeeasterEgg = easterEgg?.computeMessageSize(3) {
            serialize_size += varSizeeasterEgg
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EasterEggRequest> {
    var mergedArray = Array<EasterEggRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EasterEggRequest? {
    return try EasterEggRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggRequest {
    return try EasterEggRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EasterEggRequest.Builder {
    return EasterEggRequest.classBuilder() as! EasterEggRequest.Builder
  }
  public func getBuilder() -> EasterEggRequest.Builder {
    return classBuilder() as! EasterEggRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EasterEggRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EasterEggRequest.Builder()
  }
  public func toBuilder() throws -> EasterEggRequest.Builder {
    return try EasterEggRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EasterEggRequest) throws -> EasterEggRequest.Builder {
    return try EasterEggRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEasterEgg {
      output += "\(indent) easterEgg {\n"
      if let outDescEasterEgg = easterEgg {
        output += try outDescEasterEgg.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasEasterEgg {
              if let hashValueeasterEgg = easterEgg?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeasterEgg
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EasterEggRequest"
  }
  override public func className() -> String {
      return "EasterEggRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EasterEggRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EasterEggRequest = EasterEggRequest()
    public func getMessage() -> EasterEggRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> EasterEggRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> EasterEggRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> EasterEggRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> EasterEggRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> EasterEggRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> EasterEggRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasEasterEgg:Bool {
         get {
             return builderResult.hasEasterEgg
         }
    }
    public var easterEgg:EasterEgg! {
         get {
             if easterEggBuilder_ != nil {
                builderResult.easterEgg = easterEggBuilder_.getMessage()
             }
             return builderResult.easterEgg
         }
         set (value) {
             builderResult.hasEasterEgg = true
             builderResult.easterEgg = value
         }
    }
    private var easterEggBuilder_:EasterEgg.Builder! {
         didSet {
            builderResult.hasEasterEgg = true
         }
    }
    public func getEasterEggBuilder() -> EasterEgg.Builder {
      if easterEggBuilder_ == nil {
         easterEggBuilder_ = EasterEgg.Builder()
         builderResult.easterEgg = easterEggBuilder_.getMessage()
         if easterEgg != nil {
            try! easterEggBuilder_.mergeFrom(easterEgg)
         }
      }
      return easterEggBuilder_
    }
    public func setEasterEgg(_ value:EasterEgg!) -> EasterEggRequest.Builder {
      self.easterEgg = value
      return self
    }
    public func mergeEasterEgg(_ value:EasterEgg) throws -> EasterEggRequest.Builder {
      if builderResult.hasEasterEgg {
        builderResult.easterEgg = try EasterEgg.builderWithPrototype(builderResult.easterEgg).mergeFrom(value).buildPartial()
      } else {
        builderResult.easterEgg = value
      }
      builderResult.hasEasterEgg = true
      return self
    }
    public func clearEasterEgg() -> EasterEggRequest.Builder {
      easterEggBuilder_ = nil
      builderResult.hasEasterEgg = false
      builderResult.easterEgg = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EasterEggRequest.Builder {
      builderResult = EasterEggRequest()
      return self
    }
    public override func clone() throws -> EasterEggRequest.Builder {
      return try EasterEggRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EasterEggRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EasterEggRequest {
      let returnMe:EasterEggRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EasterEggRequest) throws -> EasterEggRequest.Builder {
      if other == EasterEggRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if (other.hasEasterEgg) {
          try mergeEasterEgg(other.easterEgg)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 26:
          let subBuilder:EasterEgg.Builder = EasterEgg.Builder()
          if hasEasterEgg {
            try subBuilder.mergeFrom(easterEgg)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          easterEgg = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class EasterEggResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasTimestamp {
      try output.writeUInt64(2, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<EasterEggResponse> {
    var mergedArray = Array<EasterEggResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> EasterEggResponse? {
    return try EasterEggResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggResponse {
    return try EasterEggResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> EasterEggResponse.Builder {
    return EasterEggResponse.classBuilder() as! EasterEggResponse.Builder
  }
  public func getBuilder() -> EasterEggResponse.Builder {
    return classBuilder() as! EasterEggResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return EasterEggResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return EasterEggResponse.Builder()
  }
  public func toBuilder() throws -> EasterEggResponse.Builder {
    return try EasterEggResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:EasterEggResponse) throws -> EasterEggResponse.Builder {
    return try EasterEggResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "EasterEggResponse"
  }
  override public func className() -> String {
      return "EasterEggResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return EasterEggResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:EasterEggResponse = EasterEggResponse()
    public func getMessage() -> EasterEggResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> EasterEggResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> EasterEggResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> EasterEggResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> EasterEggResponse.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> EasterEggResponse.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EasterEggResponse.Builder {
      builderResult = EasterEggResponse()
      return self
    }
    public override func clone() throws -> EasterEggResponse.Builder {
      return try EasterEggResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> EasterEggResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EasterEggResponse {
      let returnMe:EasterEggResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:EasterEggResponse) throws -> EasterEggResponse.Builder {
      if other == EasterEggResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> EasterEggResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EasterEggResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          timestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetConversationRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationSpec:ConversationSpec!
  public private(set) var hasConversationSpec:Bool = false
  public private(set) var includeEvent:Bool = false

  public private(set) var hasIncludeEvent:Bool = false
  public private(set) var maxEventsPerConversation:UInt64 = UInt64(0)

  public private(set) var hasMaxEventsPerConversation:Bool = false
  public private(set) var eventContinuationToken:EventContinuationToken!
  public private(set) var hasEventContinuationToken:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationSpec {
      try output.writeMessage(2, value:conversationSpec)
    }
    if hasIncludeEvent {
      try output.writeBool(4, value:includeEvent)
    }
    if hasMaxEventsPerConversation {
      try output.writeUInt64(6, value:maxEventsPerConversation)
    }
    if hasEventContinuationToken {
      try output.writeMessage(7, value:eventContinuationToken)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationSpec {
        if let varSizeconversationSpec = conversationSpec?.computeMessageSize(2) {
            serialize_size += varSizeconversationSpec
        }
    }
    if hasIncludeEvent {
      serialize_size += includeEvent.computeBoolSize(4)
    }
    if hasMaxEventsPerConversation {
      serialize_size += maxEventsPerConversation.computeUInt64Size(6)
    }
    if hasEventContinuationToken {
        if let varSizeeventContinuationToken = eventContinuationToken?.computeMessageSize(7) {
            serialize_size += varSizeeventContinuationToken
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetConversationRequest> {
    var mergedArray = Array<GetConversationRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetConversationRequest? {
    return try GetConversationRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationRequest {
    return try GetConversationRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetConversationRequest.Builder {
    return GetConversationRequest.classBuilder() as! GetConversationRequest.Builder
  }
  public func getBuilder() -> GetConversationRequest.Builder {
    return classBuilder() as! GetConversationRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetConversationRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetConversationRequest.Builder()
  }
  public func toBuilder() throws -> GetConversationRequest.Builder {
    return try GetConversationRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetConversationRequest) throws -> GetConversationRequest.Builder {
    return try GetConversationRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationSpec {
      output += "\(indent) conversationSpec {\n"
      if let outDescConversationSpec = conversationSpec {
        output += try outDescConversationSpec.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasIncludeEvent {
      output += "\(indent) includeEvent: \(includeEvent) \n"
    }
    if hasMaxEventsPerConversation {
      output += "\(indent) maxEventsPerConversation: \(maxEventsPerConversation) \n"
    }
    if hasEventContinuationToken {
      output += "\(indent) eventContinuationToken {\n"
      if let outDescEventContinuationToken = eventContinuationToken {
        output += try outDescEventContinuationToken.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationSpec {
              if let hashValueconversationSpec = conversationSpec?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationSpec
              }
          }
          if hasIncludeEvent {
             hashCode = (hashCode &* 31) &+ includeEvent.hashValue
          }
          if hasMaxEventsPerConversation {
             hashCode = (hashCode &* 31) &+ maxEventsPerConversation.hashValue
          }
          if hasEventContinuationToken {
              if let hashValueeventContinuationToken = eventContinuationToken?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventContinuationToken
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetConversationRequest"
  }
  override public func className() -> String {
      return "GetConversationRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetConversationRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetConversationRequest = GetConversationRequest()
    public func getMessage() -> GetConversationRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> GetConversationRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> GetConversationRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> GetConversationRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationSpec:Bool {
         get {
             return builderResult.hasConversationSpec
         }
    }
    public var conversationSpec:ConversationSpec! {
         get {
             if conversationSpecBuilder_ != nil {
                builderResult.conversationSpec = conversationSpecBuilder_.getMessage()
             }
             return builderResult.conversationSpec
         }
         set (value) {
             builderResult.hasConversationSpec = true
             builderResult.conversationSpec = value
         }
    }
    private var conversationSpecBuilder_:ConversationSpec.Builder! {
         didSet {
            builderResult.hasConversationSpec = true
         }
    }
    public func getConversationSpecBuilder() -> ConversationSpec.Builder {
      if conversationSpecBuilder_ == nil {
         conversationSpecBuilder_ = ConversationSpec.Builder()
         builderResult.conversationSpec = conversationSpecBuilder_.getMessage()
         if conversationSpec != nil {
            try! conversationSpecBuilder_.mergeFrom(conversationSpec)
         }
      }
      return conversationSpecBuilder_
    }
    public func setConversationSpec(_ value:ConversationSpec!) -> GetConversationRequest.Builder {
      self.conversationSpec = value
      return self
    }
    public func mergeConversationSpec(_ value:ConversationSpec) throws -> GetConversationRequest.Builder {
      if builderResult.hasConversationSpec {
        builderResult.conversationSpec = try ConversationSpec.builderWithPrototype(builderResult.conversationSpec).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationSpec = value
      }
      builderResult.hasConversationSpec = true
      return self
    }
    public func clearConversationSpec() -> GetConversationRequest.Builder {
      conversationSpecBuilder_ = nil
      builderResult.hasConversationSpec = false
      builderResult.conversationSpec = nil
      return self
    }
    public var hasIncludeEvent:Bool {
         get {
              return builderResult.hasIncludeEvent
         }
    }
    public var includeEvent:Bool {
         get {
              return builderResult.includeEvent
         }
         set (value) {
             builderResult.hasIncludeEvent = true
             builderResult.includeEvent = value
         }
    }
    public func setIncludeEvent(_ value:Bool) -> GetConversationRequest.Builder {
      self.includeEvent = value
      return self
    }
    public func clearIncludeEvent() -> GetConversationRequest.Builder{
         builderResult.hasIncludeEvent = false
         builderResult.includeEvent = false
         return self
    }
    public var hasMaxEventsPerConversation:Bool {
         get {
              return builderResult.hasMaxEventsPerConversation
         }
    }
    public var maxEventsPerConversation:UInt64 {
         get {
              return builderResult.maxEventsPerConversation
         }
         set (value) {
             builderResult.hasMaxEventsPerConversation = true
             builderResult.maxEventsPerConversation = value
         }
    }
    public func setMaxEventsPerConversation(_ value:UInt64) -> GetConversationRequest.Builder {
      self.maxEventsPerConversation = value
      return self
    }
    public func clearMaxEventsPerConversation() -> GetConversationRequest.Builder{
         builderResult.hasMaxEventsPerConversation = false
         builderResult.maxEventsPerConversation = UInt64(0)
         return self
    }
    public var hasEventContinuationToken:Bool {
         get {
             return builderResult.hasEventContinuationToken
         }
    }
    public var eventContinuationToken:EventContinuationToken! {
         get {
             if eventContinuationTokenBuilder_ != nil {
                builderResult.eventContinuationToken = eventContinuationTokenBuilder_.getMessage()
             }
             return builderResult.eventContinuationToken
         }
         set (value) {
             builderResult.hasEventContinuationToken = true
             builderResult.eventContinuationToken = value
         }
    }
    private var eventContinuationTokenBuilder_:EventContinuationToken.Builder! {
         didSet {
            builderResult.hasEventContinuationToken = true
         }
    }
    public func getEventContinuationTokenBuilder() -> EventContinuationToken.Builder {
      if eventContinuationTokenBuilder_ == nil {
         eventContinuationTokenBuilder_ = EventContinuationToken.Builder()
         builderResult.eventContinuationToken = eventContinuationTokenBuilder_.getMessage()
         if eventContinuationToken != nil {
            try! eventContinuationTokenBuilder_.mergeFrom(eventContinuationToken)
         }
      }
      return eventContinuationTokenBuilder_
    }
    public func setEventContinuationToken(_ value:EventContinuationToken!) -> GetConversationRequest.Builder {
      self.eventContinuationToken = value
      return self
    }
    public func mergeEventContinuationToken(_ value:EventContinuationToken) throws -> GetConversationRequest.Builder {
      if builderResult.hasEventContinuationToken {
        builderResult.eventContinuationToken = try EventContinuationToken.builderWithPrototype(builderResult.eventContinuationToken).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventContinuationToken = value
      }
      builderResult.hasEventContinuationToken = true
      return self
    }
    public func clearEventContinuationToken() -> GetConversationRequest.Builder {
      eventContinuationTokenBuilder_ = nil
      builderResult.hasEventContinuationToken = false
      builderResult.eventContinuationToken = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetConversationRequest.Builder {
      builderResult = GetConversationRequest()
      return self
    }
    public override func clone() throws -> GetConversationRequest.Builder {
      return try GetConversationRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetConversationRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetConversationRequest {
      let returnMe:GetConversationRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetConversationRequest) throws -> GetConversationRequest.Builder {
      if other == GetConversationRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationSpec) {
          try mergeConversationSpec(other.conversationSpec)
      }
      if other.hasIncludeEvent {
           includeEvent = other.includeEvent
      }
      if other.hasMaxEventsPerConversation {
           maxEventsPerConversation = other.maxEventsPerConversation
      }
      if (other.hasEventContinuationToken) {
          try mergeEventContinuationToken(other.eventContinuationToken)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetConversationRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationSpec.Builder = ConversationSpec.Builder()
          if hasConversationSpec {
            try subBuilder.mergeFrom(conversationSpec)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationSpec = subBuilder.buildPartial()

        case 32:
          includeEvent = try input.readBool()

        case 48:
          maxEventsPerConversation = try input.readUInt64()

        case 58:
          let subBuilder:EventContinuationToken.Builder = EventContinuationToken.Builder()
          if hasEventContinuationToken {
            try subBuilder.mergeFrom(eventContinuationToken)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventContinuationToken = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetConversationResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var conversationState:ConversationState!
  public private(set) var hasConversationState:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasConversationState {
     if !conversationState.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasConversationState {
      try output.writeMessage(2, value:conversationState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasConversationState {
        if let varSizeconversationState = conversationState?.computeMessageSize(2) {
            serialize_size += varSizeconversationState
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetConversationResponse> {
    var mergedArray = Array<GetConversationResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetConversationResponse? {
    return try GetConversationResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationResponse {
    return try GetConversationResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetConversationResponse.Builder {
    return GetConversationResponse.classBuilder() as! GetConversationResponse.Builder
  }
  public func getBuilder() -> GetConversationResponse.Builder {
    return classBuilder() as! GetConversationResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetConversationResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetConversationResponse.Builder()
  }
  public func toBuilder() throws -> GetConversationResponse.Builder {
    return try GetConversationResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetConversationResponse) throws -> GetConversationResponse.Builder {
    return try GetConversationResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationState {
      output += "\(indent) conversationState {\n"
      if let outDescConversationState = conversationState {
        output += try outDescConversationState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasConversationState {
              if let hashValueconversationState = conversationState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationState
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetConversationResponse"
  }
  override public func className() -> String {
      return "GetConversationResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetConversationResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetConversationResponse = GetConversationResponse()
    public func getMessage() -> GetConversationResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> GetConversationResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> GetConversationResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> GetConversationResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasConversationState:Bool {
         get {
             return builderResult.hasConversationState
         }
    }
    public var conversationState:ConversationState! {
         get {
             if conversationStateBuilder_ != nil {
                builderResult.conversationState = conversationStateBuilder_.getMessage()
             }
             return builderResult.conversationState
         }
         set (value) {
             builderResult.hasConversationState = true
             builderResult.conversationState = value
         }
    }
    private var conversationStateBuilder_:ConversationState.Builder! {
         didSet {
            builderResult.hasConversationState = true
         }
    }
    public func getConversationStateBuilder() -> ConversationState.Builder {
      if conversationStateBuilder_ == nil {
         conversationStateBuilder_ = ConversationState.Builder()
         builderResult.conversationState = conversationStateBuilder_.getMessage()
         if conversationState != nil {
            try! conversationStateBuilder_.mergeFrom(conversationState)
         }
      }
      return conversationStateBuilder_
    }
    public func setConversationState(_ value:ConversationState!) -> GetConversationResponse.Builder {
      self.conversationState = value
      return self
    }
    public func mergeConversationState(_ value:ConversationState) throws -> GetConversationResponse.Builder {
      if builderResult.hasConversationState {
        builderResult.conversationState = try ConversationState.builderWithPrototype(builderResult.conversationState).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationState = value
      }
      builderResult.hasConversationState = true
      return self
    }
    public func clearConversationState() -> GetConversationResponse.Builder {
      conversationStateBuilder_ = nil
      builderResult.hasConversationState = false
      builderResult.conversationState = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetConversationResponse.Builder {
      builderResult = GetConversationResponse()
      return self
    }
    public override func clone() throws -> GetConversationResponse.Builder {
      return try GetConversationResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetConversationResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetConversationResponse {
      let returnMe:GetConversationResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetConversationResponse) throws -> GetConversationResponse.Builder {
      if other == GetConversationResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasConversationState) {
          try mergeConversationState(other.conversationState)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetConversationResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetConversationResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationState.Builder = ConversationState.Builder()
          if hasConversationState {
            try subBuilder.mergeFrom(conversationState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationState = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetEntityByIdRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var batchLookupSpec:Array<EntityLookupSpec>  = Array<EntityLookupSpec>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    for oneElementbatchLookupSpec in batchLookupSpec {
        try output.writeMessage(3, value:oneElementbatchLookupSpec)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    for oneElementbatchLookupSpec in batchLookupSpec {
        serialize_size += oneElementbatchLookupSpec.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetEntityByIdRequest> {
    var mergedArray = Array<GetEntityByIdRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetEntityByIdRequest? {
    return try GetEntityByIdRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdRequest {
    return try GetEntityByIdRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetEntityByIdRequest.Builder {
    return GetEntityByIdRequest.classBuilder() as! GetEntityByIdRequest.Builder
  }
  public func getBuilder() -> GetEntityByIdRequest.Builder {
    return classBuilder() as! GetEntityByIdRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetEntityByIdRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetEntityByIdRequest.Builder()
  }
  public func toBuilder() throws -> GetEntityByIdRequest.Builder {
    return try GetEntityByIdRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetEntityByIdRequest) throws -> GetEntityByIdRequest.Builder {
    return try GetEntityByIdRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var batchLookupSpecElementIndex:Int = 0
    for oneElementbatchLookupSpec in batchLookupSpec {
        output += "\(indent) batchLookupSpec[\(batchLookupSpecElementIndex)] {\n"
        output += try oneElementbatchLookupSpec.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        batchLookupSpecElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          for oneElementbatchLookupSpec in batchLookupSpec {
              hashCode = (hashCode &* 31) &+ oneElementbatchLookupSpec.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetEntityByIdRequest"
  }
  override public func className() -> String {
      return "GetEntityByIdRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetEntityByIdRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetEntityByIdRequest = GetEntityByIdRequest()
    public func getMessage() -> GetEntityByIdRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> GetEntityByIdRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> GetEntityByIdRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> GetEntityByIdRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var batchLookupSpec:Array<EntityLookupSpec> {
         get {
             return builderResult.batchLookupSpec
         }
         set (value) {
             builderResult.batchLookupSpec = value
         }
    }
    public func setBatchLookupSpec(_ value:Array<EntityLookupSpec>) -> GetEntityByIdRequest.Builder {
      self.batchLookupSpec = value
      return self
    }
    public func clearBatchLookupSpec() -> GetEntityByIdRequest.Builder {
      builderResult.batchLookupSpec.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetEntityByIdRequest.Builder {
      builderResult = GetEntityByIdRequest()
      return self
    }
    public override func clone() throws -> GetEntityByIdRequest.Builder {
      return try GetEntityByIdRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetEntityByIdRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetEntityByIdRequest {
      let returnMe:GetEntityByIdRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetEntityByIdRequest) throws -> GetEntityByIdRequest.Builder {
      if other == GetEntityByIdRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if !other.batchLookupSpec.isEmpty  {
         builderResult.batchLookupSpec += other.batchLookupSpec
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetEntityByIdRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 26:
          let subBuilder = EntityLookupSpec.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          batchLookupSpec += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetEntityByIdResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var entity:Array<Entity>  = Array<Entity>()
  public private(set) var entityResult:Array<EntityResult>  = Array<EntityResult>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitentity:Bool = true
    for oneElemententity in entity {
        if (!oneElemententity.isInitialized()) {
            isInitentity = false
            break 
        }
    }
    if !isInitentity {
     return isInitentity
     }
    var isInitentityResult:Bool = true
    for oneElemententityResult in entityResult {
        if (!oneElemententityResult.isInitialized()) {
            isInitentityResult = false
            break 
        }
    }
    if !isInitentityResult {
     return isInitentityResult
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    for oneElemententity in entity {
        try output.writeMessage(2, value:oneElemententity)
    }
    for oneElemententityResult in entityResult {
        try output.writeMessage(3, value:oneElemententityResult)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    for oneElemententity in entity {
        serialize_size += oneElemententity.computeMessageSize(2)
    }
    for oneElemententityResult in entityResult {
        serialize_size += oneElemententityResult.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetEntityByIdResponse> {
    var mergedArray = Array<GetEntityByIdResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetEntityByIdResponse? {
    return try GetEntityByIdResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdResponse {
    return try GetEntityByIdResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetEntityByIdResponse.Builder {
    return GetEntityByIdResponse.classBuilder() as! GetEntityByIdResponse.Builder
  }
  public func getBuilder() -> GetEntityByIdResponse.Builder {
    return classBuilder() as! GetEntityByIdResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetEntityByIdResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetEntityByIdResponse.Builder()
  }
  public func toBuilder() throws -> GetEntityByIdResponse.Builder {
    return try GetEntityByIdResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetEntityByIdResponse) throws -> GetEntityByIdResponse.Builder {
    return try GetEntityByIdResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var entityElementIndex:Int = 0
    for oneElemententity in entity {
        output += "\(indent) entity[\(entityElementIndex)] {\n"
        output += try oneElemententity.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        entityElementIndex += 1
    }
    var entityResultElementIndex:Int = 0
    for oneElemententityResult in entityResult {
        output += "\(indent) entityResult[\(entityResultElementIndex)] {\n"
        output += try oneElemententityResult.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        entityResultElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          for oneElemententity in entity {
              hashCode = (hashCode &* 31) &+ oneElemententity.hashValue
          }
          for oneElemententityResult in entityResult {
              hashCode = (hashCode &* 31) &+ oneElemententityResult.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetEntityByIdResponse"
  }
  override public func className() -> String {
      return "GetEntityByIdResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetEntityByIdResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetEntityByIdResponse = GetEntityByIdResponse()
    public func getMessage() -> GetEntityByIdResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> GetEntityByIdResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> GetEntityByIdResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> GetEntityByIdResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var entity:Array<Entity> {
         get {
             return builderResult.entity
         }
         set (value) {
             builderResult.entity = value
         }
    }
    public func setEntity(_ value:Array<Entity>) -> GetEntityByIdResponse.Builder {
      self.entity = value
      return self
    }
    public func clearEntity() -> GetEntityByIdResponse.Builder {
      builderResult.entity.removeAll(keepingCapacity: false)
      return self
    }
    public var entityResult:Array<EntityResult> {
         get {
             return builderResult.entityResult
         }
         set (value) {
             builderResult.entityResult = value
         }
    }
    public func setEntityResult(_ value:Array<EntityResult>) -> GetEntityByIdResponse.Builder {
      self.entityResult = value
      return self
    }
    public func clearEntityResult() -> GetEntityByIdResponse.Builder {
      builderResult.entityResult.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetEntityByIdResponse.Builder {
      builderResult = GetEntityByIdResponse()
      return self
    }
    public override func clone() throws -> GetEntityByIdResponse.Builder {
      return try GetEntityByIdResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetEntityByIdResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetEntityByIdResponse {
      let returnMe:GetEntityByIdResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetEntityByIdResponse) throws -> GetEntityByIdResponse.Builder {
      if other == GetEntityByIdResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if !other.entity.isEmpty  {
         builderResult.entity += other.entity
      }
      if !other.entityResult.isEmpty  {
         builderResult.entityResult += other.entityResult
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetEntityByIdResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetEntityByIdResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder = Entity.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          entity += [subBuilder.buildPartial()]

        case 26:
          let subBuilder = EntityResult.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          entityResult += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetSuggestedEntitiesRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  // Max number of non-grouped entities to return.
  public private(set) var maxCount:UInt64 = UInt64(0)

  public private(set) var hasMaxCount:Bool = false
  public private(set) var favorites:SuggestedContactGroupHash!
  public private(set) var hasFavorites:Bool = false
  public private(set) var contactsYouHangoutWith:SuggestedContactGroupHash!
  public private(set) var hasContactsYouHangoutWith:Bool = false
  public private(set) var otherContactsOnHangouts:SuggestedContactGroupHash!
  public private(set) var hasOtherContactsOnHangouts:Bool = false
  public private(set) var otherContacts:SuggestedContactGroupHash!
  public private(set) var hasOtherContacts:Bool = false
  public private(set) var dismissedContacts:SuggestedContactGroupHash!
  public private(set) var hasDismissedContacts:Bool = false
  public private(set) var pinnedFavorites:SuggestedContactGroupHash!
  public private(set) var hasPinnedFavorites:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasMaxCount {
      try output.writeUInt64(4, value:maxCount)
    }
    if hasFavorites {
      try output.writeMessage(8, value:favorites)
    }
    if hasContactsYouHangoutWith {
      try output.writeMessage(9, value:contactsYouHangoutWith)
    }
    if hasOtherContactsOnHangouts {
      try output.writeMessage(10, value:otherContactsOnHangouts)
    }
    if hasOtherContacts {
      try output.writeMessage(11, value:otherContacts)
    }
    if hasDismissedContacts {
      try output.writeMessage(12, value:dismissedContacts)
    }
    if hasPinnedFavorites {
      try output.writeMessage(13, value:pinnedFavorites)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasMaxCount {
      serialize_size += maxCount.computeUInt64Size(4)
    }
    if hasFavorites {
        if let varSizefavorites = favorites?.computeMessageSize(8) {
            serialize_size += varSizefavorites
        }
    }
    if hasContactsYouHangoutWith {
        if let varSizecontactsYouHangoutWith = contactsYouHangoutWith?.computeMessageSize(9) {
            serialize_size += varSizecontactsYouHangoutWith
        }
    }
    if hasOtherContactsOnHangouts {
        if let varSizeotherContactsOnHangouts = otherContactsOnHangouts?.computeMessageSize(10) {
            serialize_size += varSizeotherContactsOnHangouts
        }
    }
    if hasOtherContacts {
        if let varSizeotherContacts = otherContacts?.computeMessageSize(11) {
            serialize_size += varSizeotherContacts
        }
    }
    if hasDismissedContacts {
        if let varSizedismissedContacts = dismissedContacts?.computeMessageSize(12) {
            serialize_size += varSizedismissedContacts
        }
    }
    if hasPinnedFavorites {
        if let varSizepinnedFavorites = pinnedFavorites?.computeMessageSize(13) {
            serialize_size += varSizepinnedFavorites
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetSuggestedEntitiesRequest> {
    var mergedArray = Array<GetSuggestedEntitiesRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetSuggestedEntitiesRequest? {
    return try GetSuggestedEntitiesRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesRequest {
    return try GetSuggestedEntitiesRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetSuggestedEntitiesRequest.Builder {
    return GetSuggestedEntitiesRequest.classBuilder() as! GetSuggestedEntitiesRequest.Builder
  }
  public func getBuilder() -> GetSuggestedEntitiesRequest.Builder {
    return classBuilder() as! GetSuggestedEntitiesRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetSuggestedEntitiesRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetSuggestedEntitiesRequest.Builder()
  }
  public func toBuilder() throws -> GetSuggestedEntitiesRequest.Builder {
    return try GetSuggestedEntitiesRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetSuggestedEntitiesRequest) throws -> GetSuggestedEntitiesRequest.Builder {
    return try GetSuggestedEntitiesRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMaxCount {
      output += "\(indent) maxCount: \(maxCount) \n"
    }
    if hasFavorites {
      output += "\(indent) favorites {\n"
      if let outDescFavorites = favorites {
        output += try outDescFavorites.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasContactsYouHangoutWith {
      output += "\(indent) contactsYouHangoutWith {\n"
      if let outDescContactsYouHangoutWith = contactsYouHangoutWith {
        output += try outDescContactsYouHangoutWith.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasOtherContactsOnHangouts {
      output += "\(indent) otherContactsOnHangouts {\n"
      if let outDescOtherContactsOnHangouts = otherContactsOnHangouts {
        output += try outDescOtherContactsOnHangouts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasOtherContacts {
      output += "\(indent) otherContacts {\n"
      if let outDescOtherContacts = otherContacts {
        output += try outDescOtherContacts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDismissedContacts {
      output += "\(indent) dismissedContacts {\n"
      if let outDescDismissedContacts = dismissedContacts {
        output += try outDescDismissedContacts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPinnedFavorites {
      output += "\(indent) pinnedFavorites {\n"
      if let outDescPinnedFavorites = pinnedFavorites {
        output += try outDescPinnedFavorites.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasMaxCount {
             hashCode = (hashCode &* 31) &+ maxCount.hashValue
          }
          if hasFavorites {
              if let hashValuefavorites = favorites?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuefavorites
              }
          }
          if hasContactsYouHangoutWith {
              if let hashValuecontactsYouHangoutWith = contactsYouHangoutWith?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecontactsYouHangoutWith
              }
          }
          if hasOtherContactsOnHangouts {
              if let hashValueotherContactsOnHangouts = otherContactsOnHangouts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueotherContactsOnHangouts
              }
          }
          if hasOtherContacts {
              if let hashValueotherContacts = otherContacts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueotherContacts
              }
          }
          if hasDismissedContacts {
              if let hashValuedismissedContacts = dismissedContacts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedismissedContacts
              }
          }
          if hasPinnedFavorites {
              if let hashValuepinnedFavorites = pinnedFavorites?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepinnedFavorites
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetSuggestedEntitiesRequest"
  }
  override public func className() -> String {
      return "GetSuggestedEntitiesRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetSuggestedEntitiesRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetSuggestedEntitiesRequest = GetSuggestedEntitiesRequest()
    public func getMessage() -> GetSuggestedEntitiesRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> GetSuggestedEntitiesRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> GetSuggestedEntitiesRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasMaxCount:Bool {
         get {
              return builderResult.hasMaxCount
         }
    }
    public var maxCount:UInt64 {
         get {
              return builderResult.maxCount
         }
         set (value) {
             builderResult.hasMaxCount = true
             builderResult.maxCount = value
         }
    }
    public func setMaxCount(_ value:UInt64) -> GetSuggestedEntitiesRequest.Builder {
      self.maxCount = value
      return self
    }
    public func clearMaxCount() -> GetSuggestedEntitiesRequest.Builder{
         builderResult.hasMaxCount = false
         builderResult.maxCount = UInt64(0)
         return self
    }
    public var hasFavorites:Bool {
         get {
             return builderResult.hasFavorites
         }
    }
    public var favorites:SuggestedContactGroupHash! {
         get {
             if favoritesBuilder_ != nil {
                builderResult.favorites = favoritesBuilder_.getMessage()
             }
             return builderResult.favorites
         }
         set (value) {
             builderResult.hasFavorites = true
             builderResult.favorites = value
         }
    }
    private var favoritesBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasFavorites = true
         }
    }
    public func getFavoritesBuilder() -> SuggestedContactGroupHash.Builder {
      if favoritesBuilder_ == nil {
         favoritesBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.favorites = favoritesBuilder_.getMessage()
         if favorites != nil {
            try! favoritesBuilder_.mergeFrom(favorites)
         }
      }
      return favoritesBuilder_
    }
    public func setFavorites(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.favorites = value
      return self
    }
    public func mergeFavorites(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasFavorites {
        builderResult.favorites = try SuggestedContactGroupHash.builderWithPrototype(builderResult.favorites).mergeFrom(value).buildPartial()
      } else {
        builderResult.favorites = value
      }
      builderResult.hasFavorites = true
      return self
    }
    public func clearFavorites() -> GetSuggestedEntitiesRequest.Builder {
      favoritesBuilder_ = nil
      builderResult.hasFavorites = false
      builderResult.favorites = nil
      return self
    }
    public var hasContactsYouHangoutWith:Bool {
         get {
             return builderResult.hasContactsYouHangoutWith
         }
    }
    public var contactsYouHangoutWith:SuggestedContactGroupHash! {
         get {
             if contactsYouHangoutWithBuilder_ != nil {
                builderResult.contactsYouHangoutWith = contactsYouHangoutWithBuilder_.getMessage()
             }
             return builderResult.contactsYouHangoutWith
         }
         set (value) {
             builderResult.hasContactsYouHangoutWith = true
             builderResult.contactsYouHangoutWith = value
         }
    }
    private var contactsYouHangoutWithBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasContactsYouHangoutWith = true
         }
    }
    public func getContactsYouHangoutWithBuilder() -> SuggestedContactGroupHash.Builder {
      if contactsYouHangoutWithBuilder_ == nil {
         contactsYouHangoutWithBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.contactsYouHangoutWith = contactsYouHangoutWithBuilder_.getMessage()
         if contactsYouHangoutWith != nil {
            try! contactsYouHangoutWithBuilder_.mergeFrom(contactsYouHangoutWith)
         }
      }
      return contactsYouHangoutWithBuilder_
    }
    public func setContactsYouHangoutWith(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.contactsYouHangoutWith = value
      return self
    }
    public func mergeContactsYouHangoutWith(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasContactsYouHangoutWith {
        builderResult.contactsYouHangoutWith = try SuggestedContactGroupHash.builderWithPrototype(builderResult.contactsYouHangoutWith).mergeFrom(value).buildPartial()
      } else {
        builderResult.contactsYouHangoutWith = value
      }
      builderResult.hasContactsYouHangoutWith = true
      return self
    }
    public func clearContactsYouHangoutWith() -> GetSuggestedEntitiesRequest.Builder {
      contactsYouHangoutWithBuilder_ = nil
      builderResult.hasContactsYouHangoutWith = false
      builderResult.contactsYouHangoutWith = nil
      return self
    }
    public var hasOtherContactsOnHangouts:Bool {
         get {
             return builderResult.hasOtherContactsOnHangouts
         }
    }
    public var otherContactsOnHangouts:SuggestedContactGroupHash! {
         get {
             if otherContactsOnHangoutsBuilder_ != nil {
                builderResult.otherContactsOnHangouts = otherContactsOnHangoutsBuilder_.getMessage()
             }
             return builderResult.otherContactsOnHangouts
         }
         set (value) {
             builderResult.hasOtherContactsOnHangouts = true
             builderResult.otherContactsOnHangouts = value
         }
    }
    private var otherContactsOnHangoutsBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasOtherContactsOnHangouts = true
         }
    }
    public func getOtherContactsOnHangoutsBuilder() -> SuggestedContactGroupHash.Builder {
      if otherContactsOnHangoutsBuilder_ == nil {
         otherContactsOnHangoutsBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.otherContactsOnHangouts = otherContactsOnHangoutsBuilder_.getMessage()
         if otherContactsOnHangouts != nil {
            try! otherContactsOnHangoutsBuilder_.mergeFrom(otherContactsOnHangouts)
         }
      }
      return otherContactsOnHangoutsBuilder_
    }
    public func setOtherContactsOnHangouts(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.otherContactsOnHangouts = value
      return self
    }
    public func mergeOtherContactsOnHangouts(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasOtherContactsOnHangouts {
        builderResult.otherContactsOnHangouts = try SuggestedContactGroupHash.builderWithPrototype(builderResult.otherContactsOnHangouts).mergeFrom(value).buildPartial()
      } else {
        builderResult.otherContactsOnHangouts = value
      }
      builderResult.hasOtherContactsOnHangouts = true
      return self
    }
    public func clearOtherContactsOnHangouts() -> GetSuggestedEntitiesRequest.Builder {
      otherContactsOnHangoutsBuilder_ = nil
      builderResult.hasOtherContactsOnHangouts = false
      builderResult.otherContactsOnHangouts = nil
      return self
    }
    public var hasOtherContacts:Bool {
         get {
             return builderResult.hasOtherContacts
         }
    }
    public var otherContacts:SuggestedContactGroupHash! {
         get {
             if otherContactsBuilder_ != nil {
                builderResult.otherContacts = otherContactsBuilder_.getMessage()
             }
             return builderResult.otherContacts
         }
         set (value) {
             builderResult.hasOtherContacts = true
             builderResult.otherContacts = value
         }
    }
    private var otherContactsBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasOtherContacts = true
         }
    }
    public func getOtherContactsBuilder() -> SuggestedContactGroupHash.Builder {
      if otherContactsBuilder_ == nil {
         otherContactsBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.otherContacts = otherContactsBuilder_.getMessage()
         if otherContacts != nil {
            try! otherContactsBuilder_.mergeFrom(otherContacts)
         }
      }
      return otherContactsBuilder_
    }
    public func setOtherContacts(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.otherContacts = value
      return self
    }
    public func mergeOtherContacts(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasOtherContacts {
        builderResult.otherContacts = try SuggestedContactGroupHash.builderWithPrototype(builderResult.otherContacts).mergeFrom(value).buildPartial()
      } else {
        builderResult.otherContacts = value
      }
      builderResult.hasOtherContacts = true
      return self
    }
    public func clearOtherContacts() -> GetSuggestedEntitiesRequest.Builder {
      otherContactsBuilder_ = nil
      builderResult.hasOtherContacts = false
      builderResult.otherContacts = nil
      return self
    }
    public var hasDismissedContacts:Bool {
         get {
             return builderResult.hasDismissedContacts
         }
    }
    public var dismissedContacts:SuggestedContactGroupHash! {
         get {
             if dismissedContactsBuilder_ != nil {
                builderResult.dismissedContacts = dismissedContactsBuilder_.getMessage()
             }
             return builderResult.dismissedContacts
         }
         set (value) {
             builderResult.hasDismissedContacts = true
             builderResult.dismissedContacts = value
         }
    }
    private var dismissedContactsBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasDismissedContacts = true
         }
    }
    public func getDismissedContactsBuilder() -> SuggestedContactGroupHash.Builder {
      if dismissedContactsBuilder_ == nil {
         dismissedContactsBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.dismissedContacts = dismissedContactsBuilder_.getMessage()
         if dismissedContacts != nil {
            try! dismissedContactsBuilder_.mergeFrom(dismissedContacts)
         }
      }
      return dismissedContactsBuilder_
    }
    public func setDismissedContacts(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.dismissedContacts = value
      return self
    }
    public func mergeDismissedContacts(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasDismissedContacts {
        builderResult.dismissedContacts = try SuggestedContactGroupHash.builderWithPrototype(builderResult.dismissedContacts).mergeFrom(value).buildPartial()
      } else {
        builderResult.dismissedContacts = value
      }
      builderResult.hasDismissedContacts = true
      return self
    }
    public func clearDismissedContacts() -> GetSuggestedEntitiesRequest.Builder {
      dismissedContactsBuilder_ = nil
      builderResult.hasDismissedContacts = false
      builderResult.dismissedContacts = nil
      return self
    }
    public var hasPinnedFavorites:Bool {
         get {
             return builderResult.hasPinnedFavorites
         }
    }
    public var pinnedFavorites:SuggestedContactGroupHash! {
         get {
             if pinnedFavoritesBuilder_ != nil {
                builderResult.pinnedFavorites = pinnedFavoritesBuilder_.getMessage()
             }
             return builderResult.pinnedFavorites
         }
         set (value) {
             builderResult.hasPinnedFavorites = true
             builderResult.pinnedFavorites = value
         }
    }
    private var pinnedFavoritesBuilder_:SuggestedContactGroupHash.Builder! {
         didSet {
            builderResult.hasPinnedFavorites = true
         }
    }
    public func getPinnedFavoritesBuilder() -> SuggestedContactGroupHash.Builder {
      if pinnedFavoritesBuilder_ == nil {
         pinnedFavoritesBuilder_ = SuggestedContactGroupHash.Builder()
         builderResult.pinnedFavorites = pinnedFavoritesBuilder_.getMessage()
         if pinnedFavorites != nil {
            try! pinnedFavoritesBuilder_.mergeFrom(pinnedFavorites)
         }
      }
      return pinnedFavoritesBuilder_
    }
    public func setPinnedFavorites(_ value:SuggestedContactGroupHash!) -> GetSuggestedEntitiesRequest.Builder {
      self.pinnedFavorites = value
      return self
    }
    public func mergePinnedFavorites(_ value:SuggestedContactGroupHash) throws -> GetSuggestedEntitiesRequest.Builder {
      if builderResult.hasPinnedFavorites {
        builderResult.pinnedFavorites = try SuggestedContactGroupHash.builderWithPrototype(builderResult.pinnedFavorites).mergeFrom(value).buildPartial()
      } else {
        builderResult.pinnedFavorites = value
      }
      builderResult.hasPinnedFavorites = true
      return self
    }
    public func clearPinnedFavorites() -> GetSuggestedEntitiesRequest.Builder {
      pinnedFavoritesBuilder_ = nil
      builderResult.hasPinnedFavorites = false
      builderResult.pinnedFavorites = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetSuggestedEntitiesRequest.Builder {
      builderResult = GetSuggestedEntitiesRequest()
      return self
    }
    public override func clone() throws -> GetSuggestedEntitiesRequest.Builder {
      return try GetSuggestedEntitiesRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetSuggestedEntitiesRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetSuggestedEntitiesRequest {
      let returnMe:GetSuggestedEntitiesRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetSuggestedEntitiesRequest) throws -> GetSuggestedEntitiesRequest.Builder {
      if other == GetSuggestedEntitiesRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasMaxCount {
           maxCount = other.maxCount
      }
      if (other.hasFavorites) {
          try mergeFavorites(other.favorites)
      }
      if (other.hasContactsYouHangoutWith) {
          try mergeContactsYouHangoutWith(other.contactsYouHangoutWith)
      }
      if (other.hasOtherContactsOnHangouts) {
          try mergeOtherContactsOnHangouts(other.otherContactsOnHangouts)
      }
      if (other.hasOtherContacts) {
          try mergeOtherContacts(other.otherContacts)
      }
      if (other.hasDismissedContacts) {
          try mergeDismissedContacts(other.dismissedContacts)
      }
      if (other.hasPinnedFavorites) {
          try mergePinnedFavorites(other.pinnedFavorites)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetSuggestedEntitiesRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 32:
          maxCount = try input.readUInt64()

        case 66:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasFavorites {
            try subBuilder.mergeFrom(favorites)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          favorites = subBuilder.buildPartial()

        case 74:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasContactsYouHangoutWith {
            try subBuilder.mergeFrom(contactsYouHangoutWith)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          contactsYouHangoutWith = subBuilder.buildPartial()

        case 82:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasOtherContactsOnHangouts {
            try subBuilder.mergeFrom(otherContactsOnHangouts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          otherContactsOnHangouts = subBuilder.buildPartial()

        case 90:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasOtherContacts {
            try subBuilder.mergeFrom(otherContacts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          otherContacts = subBuilder.buildPartial()

        case 98:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasDismissedContacts {
            try subBuilder.mergeFrom(dismissedContacts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          dismissedContacts = subBuilder.buildPartial()

        case 106:
          let subBuilder:SuggestedContactGroupHash.Builder = SuggestedContactGroupHash.Builder()
          if hasPinnedFavorites {
            try subBuilder.mergeFrom(pinnedFavorites)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          pinnedFavorites = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetSuggestedEntitiesResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var entity:Array<Entity>  = Array<Entity>()
  public private(set) var favorites:SuggestedContactGroup!
  public private(set) var hasFavorites:Bool = false
  public private(set) var contactsYouHangoutWith:SuggestedContactGroup!
  public private(set) var hasContactsYouHangoutWith:Bool = false
  public private(set) var otherContactsOnHangouts:SuggestedContactGroup!
  public private(set) var hasOtherContactsOnHangouts:Bool = false
  public private(set) var otherContacts:SuggestedContactGroup!
  public private(set) var hasOtherContacts:Bool = false
  public private(set) var dismissedContacts:SuggestedContactGroup!
  public private(set) var hasDismissedContacts:Bool = false
  public private(set) var pinnedFavorites:SuggestedContactGroup!
  public private(set) var hasPinnedFavorites:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitentity:Bool = true
    for oneElemententity in entity {
        if (!oneElemententity.isInitialized()) {
            isInitentity = false
            break 
        }
    }
    if !isInitentity {
     return isInitentity
     }
    if hasFavorites {
     if !favorites.isInitialized() {
       return false
     }
    }
    if hasContactsYouHangoutWith {
     if !contactsYouHangoutWith.isInitialized() {
       return false
     }
    }
    if hasOtherContactsOnHangouts {
     if !otherContactsOnHangouts.isInitialized() {
       return false
     }
    }
    if hasOtherContacts {
     if !otherContacts.isInitialized() {
       return false
     }
    }
    if hasDismissedContacts {
     if !dismissedContacts.isInitialized() {
       return false
     }
    }
    if hasPinnedFavorites {
     if !pinnedFavorites.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    for oneElemententity in entity {
        try output.writeMessage(2, value:oneElemententity)
    }
    if hasFavorites {
      try output.writeMessage(4, value:favorites)
    }
    if hasContactsYouHangoutWith {
      try output.writeMessage(5, value:contactsYouHangoutWith)
    }
    if hasOtherContactsOnHangouts {
      try output.writeMessage(6, value:otherContactsOnHangouts)
    }
    if hasOtherContacts {
      try output.writeMessage(7, value:otherContacts)
    }
    if hasDismissedContacts {
      try output.writeMessage(8, value:dismissedContacts)
    }
    if hasPinnedFavorites {
      try output.writeMessage(9, value:pinnedFavorites)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    for oneElemententity in entity {
        serialize_size += oneElemententity.computeMessageSize(2)
    }
    if hasFavorites {
        if let varSizefavorites = favorites?.computeMessageSize(4) {
            serialize_size += varSizefavorites
        }
    }
    if hasContactsYouHangoutWith {
        if let varSizecontactsYouHangoutWith = contactsYouHangoutWith?.computeMessageSize(5) {
            serialize_size += varSizecontactsYouHangoutWith
        }
    }
    if hasOtherContactsOnHangouts {
        if let varSizeotherContactsOnHangouts = otherContactsOnHangouts?.computeMessageSize(6) {
            serialize_size += varSizeotherContactsOnHangouts
        }
    }
    if hasOtherContacts {
        if let varSizeotherContacts = otherContacts?.computeMessageSize(7) {
            serialize_size += varSizeotherContacts
        }
    }
    if hasDismissedContacts {
        if let varSizedismissedContacts = dismissedContacts?.computeMessageSize(8) {
            serialize_size += varSizedismissedContacts
        }
    }
    if hasPinnedFavorites {
        if let varSizepinnedFavorites = pinnedFavorites?.computeMessageSize(9) {
            serialize_size += varSizepinnedFavorites
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetSuggestedEntitiesResponse> {
    var mergedArray = Array<GetSuggestedEntitiesResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetSuggestedEntitiesResponse? {
    return try GetSuggestedEntitiesResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesResponse {
    return try GetSuggestedEntitiesResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetSuggestedEntitiesResponse.Builder {
    return GetSuggestedEntitiesResponse.classBuilder() as! GetSuggestedEntitiesResponse.Builder
  }
  public func getBuilder() -> GetSuggestedEntitiesResponse.Builder {
    return classBuilder() as! GetSuggestedEntitiesResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetSuggestedEntitiesResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetSuggestedEntitiesResponse.Builder()
  }
  public func toBuilder() throws -> GetSuggestedEntitiesResponse.Builder {
    return try GetSuggestedEntitiesResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetSuggestedEntitiesResponse) throws -> GetSuggestedEntitiesResponse.Builder {
    return try GetSuggestedEntitiesResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var entityElementIndex:Int = 0
    for oneElemententity in entity {
        output += "\(indent) entity[\(entityElementIndex)] {\n"
        output += try oneElemententity.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        entityElementIndex += 1
    }
    if hasFavorites {
      output += "\(indent) favorites {\n"
      if let outDescFavorites = favorites {
        output += try outDescFavorites.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasContactsYouHangoutWith {
      output += "\(indent) contactsYouHangoutWith {\n"
      if let outDescContactsYouHangoutWith = contactsYouHangoutWith {
        output += try outDescContactsYouHangoutWith.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasOtherContactsOnHangouts {
      output += "\(indent) otherContactsOnHangouts {\n"
      if let outDescOtherContactsOnHangouts = otherContactsOnHangouts {
        output += try outDescOtherContactsOnHangouts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasOtherContacts {
      output += "\(indent) otherContacts {\n"
      if let outDescOtherContacts = otherContacts {
        output += try outDescOtherContacts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDismissedContacts {
      output += "\(indent) dismissedContacts {\n"
      if let outDescDismissedContacts = dismissedContacts {
        output += try outDescDismissedContacts.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPinnedFavorites {
      output += "\(indent) pinnedFavorites {\n"
      if let outDescPinnedFavorites = pinnedFavorites {
        output += try outDescPinnedFavorites.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          for oneElemententity in entity {
              hashCode = (hashCode &* 31) &+ oneElemententity.hashValue
          }
          if hasFavorites {
              if let hashValuefavorites = favorites?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuefavorites
              }
          }
          if hasContactsYouHangoutWith {
              if let hashValuecontactsYouHangoutWith = contactsYouHangoutWith?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecontactsYouHangoutWith
              }
          }
          if hasOtherContactsOnHangouts {
              if let hashValueotherContactsOnHangouts = otherContactsOnHangouts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueotherContactsOnHangouts
              }
          }
          if hasOtherContacts {
              if let hashValueotherContacts = otherContacts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueotherContacts
              }
          }
          if hasDismissedContacts {
              if let hashValuedismissedContacts = dismissedContacts?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedismissedContacts
              }
          }
          if hasPinnedFavorites {
              if let hashValuepinnedFavorites = pinnedFavorites?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepinnedFavorites
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetSuggestedEntitiesResponse"
  }
  override public func className() -> String {
      return "GetSuggestedEntitiesResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetSuggestedEntitiesResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetSuggestedEntitiesResponse = GetSuggestedEntitiesResponse()
    public func getMessage() -> GetSuggestedEntitiesResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> GetSuggestedEntitiesResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> GetSuggestedEntitiesResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var entity:Array<Entity> {
         get {
             return builderResult.entity
         }
         set (value) {
             builderResult.entity = value
         }
    }
    public func setEntity(_ value:Array<Entity>) -> GetSuggestedEntitiesResponse.Builder {
      self.entity = value
      return self
    }
    public func clearEntity() -> GetSuggestedEntitiesResponse.Builder {
      builderResult.entity.removeAll(keepingCapacity: false)
      return self
    }
    public var hasFavorites:Bool {
         get {
             return builderResult.hasFavorites
         }
    }
    public var favorites:SuggestedContactGroup! {
         get {
             if favoritesBuilder_ != nil {
                builderResult.favorites = favoritesBuilder_.getMessage()
             }
             return builderResult.favorites
         }
         set (value) {
             builderResult.hasFavorites = true
             builderResult.favorites = value
         }
    }
    private var favoritesBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasFavorites = true
         }
    }
    public func getFavoritesBuilder() -> SuggestedContactGroup.Builder {
      if favoritesBuilder_ == nil {
         favoritesBuilder_ = SuggestedContactGroup.Builder()
         builderResult.favorites = favoritesBuilder_.getMessage()
         if favorites != nil {
            try! favoritesBuilder_.mergeFrom(favorites)
         }
      }
      return favoritesBuilder_
    }
    public func setFavorites(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.favorites = value
      return self
    }
    public func mergeFavorites(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasFavorites {
        builderResult.favorites = try SuggestedContactGroup.builderWithPrototype(builderResult.favorites).mergeFrom(value).buildPartial()
      } else {
        builderResult.favorites = value
      }
      builderResult.hasFavorites = true
      return self
    }
    public func clearFavorites() -> GetSuggestedEntitiesResponse.Builder {
      favoritesBuilder_ = nil
      builderResult.hasFavorites = false
      builderResult.favorites = nil
      return self
    }
    public var hasContactsYouHangoutWith:Bool {
         get {
             return builderResult.hasContactsYouHangoutWith
         }
    }
    public var contactsYouHangoutWith:SuggestedContactGroup! {
         get {
             if contactsYouHangoutWithBuilder_ != nil {
                builderResult.contactsYouHangoutWith = contactsYouHangoutWithBuilder_.getMessage()
             }
             return builderResult.contactsYouHangoutWith
         }
         set (value) {
             builderResult.hasContactsYouHangoutWith = true
             builderResult.contactsYouHangoutWith = value
         }
    }
    private var contactsYouHangoutWithBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasContactsYouHangoutWith = true
         }
    }
    public func getContactsYouHangoutWithBuilder() -> SuggestedContactGroup.Builder {
      if contactsYouHangoutWithBuilder_ == nil {
         contactsYouHangoutWithBuilder_ = SuggestedContactGroup.Builder()
         builderResult.contactsYouHangoutWith = contactsYouHangoutWithBuilder_.getMessage()
         if contactsYouHangoutWith != nil {
            try! contactsYouHangoutWithBuilder_.mergeFrom(contactsYouHangoutWith)
         }
      }
      return contactsYouHangoutWithBuilder_
    }
    public func setContactsYouHangoutWith(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.contactsYouHangoutWith = value
      return self
    }
    public func mergeContactsYouHangoutWith(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasContactsYouHangoutWith {
        builderResult.contactsYouHangoutWith = try SuggestedContactGroup.builderWithPrototype(builderResult.contactsYouHangoutWith).mergeFrom(value).buildPartial()
      } else {
        builderResult.contactsYouHangoutWith = value
      }
      builderResult.hasContactsYouHangoutWith = true
      return self
    }
    public func clearContactsYouHangoutWith() -> GetSuggestedEntitiesResponse.Builder {
      contactsYouHangoutWithBuilder_ = nil
      builderResult.hasContactsYouHangoutWith = false
      builderResult.contactsYouHangoutWith = nil
      return self
    }
    public var hasOtherContactsOnHangouts:Bool {
         get {
             return builderResult.hasOtherContactsOnHangouts
         }
    }
    public var otherContactsOnHangouts:SuggestedContactGroup! {
         get {
             if otherContactsOnHangoutsBuilder_ != nil {
                builderResult.otherContactsOnHangouts = otherContactsOnHangoutsBuilder_.getMessage()
             }
             return builderResult.otherContactsOnHangouts
         }
         set (value) {
             builderResult.hasOtherContactsOnHangouts = true
             builderResult.otherContactsOnHangouts = value
         }
    }
    private var otherContactsOnHangoutsBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasOtherContactsOnHangouts = true
         }
    }
    public func getOtherContactsOnHangoutsBuilder() -> SuggestedContactGroup.Builder {
      if otherContactsOnHangoutsBuilder_ == nil {
         otherContactsOnHangoutsBuilder_ = SuggestedContactGroup.Builder()
         builderResult.otherContactsOnHangouts = otherContactsOnHangoutsBuilder_.getMessage()
         if otherContactsOnHangouts != nil {
            try! otherContactsOnHangoutsBuilder_.mergeFrom(otherContactsOnHangouts)
         }
      }
      return otherContactsOnHangoutsBuilder_
    }
    public func setOtherContactsOnHangouts(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.otherContactsOnHangouts = value
      return self
    }
    public func mergeOtherContactsOnHangouts(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasOtherContactsOnHangouts {
        builderResult.otherContactsOnHangouts = try SuggestedContactGroup.builderWithPrototype(builderResult.otherContactsOnHangouts).mergeFrom(value).buildPartial()
      } else {
        builderResult.otherContactsOnHangouts = value
      }
      builderResult.hasOtherContactsOnHangouts = true
      return self
    }
    public func clearOtherContactsOnHangouts() -> GetSuggestedEntitiesResponse.Builder {
      otherContactsOnHangoutsBuilder_ = nil
      builderResult.hasOtherContactsOnHangouts = false
      builderResult.otherContactsOnHangouts = nil
      return self
    }
    public var hasOtherContacts:Bool {
         get {
             return builderResult.hasOtherContacts
         }
    }
    public var otherContacts:SuggestedContactGroup! {
         get {
             if otherContactsBuilder_ != nil {
                builderResult.otherContacts = otherContactsBuilder_.getMessage()
             }
             return builderResult.otherContacts
         }
         set (value) {
             builderResult.hasOtherContacts = true
             builderResult.otherContacts = value
         }
    }
    private var otherContactsBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasOtherContacts = true
         }
    }
    public func getOtherContactsBuilder() -> SuggestedContactGroup.Builder {
      if otherContactsBuilder_ == nil {
         otherContactsBuilder_ = SuggestedContactGroup.Builder()
         builderResult.otherContacts = otherContactsBuilder_.getMessage()
         if otherContacts != nil {
            try! otherContactsBuilder_.mergeFrom(otherContacts)
         }
      }
      return otherContactsBuilder_
    }
    public func setOtherContacts(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.otherContacts = value
      return self
    }
    public func mergeOtherContacts(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasOtherContacts {
        builderResult.otherContacts = try SuggestedContactGroup.builderWithPrototype(builderResult.otherContacts).mergeFrom(value).buildPartial()
      } else {
        builderResult.otherContacts = value
      }
      builderResult.hasOtherContacts = true
      return self
    }
    public func clearOtherContacts() -> GetSuggestedEntitiesResponse.Builder {
      otherContactsBuilder_ = nil
      builderResult.hasOtherContacts = false
      builderResult.otherContacts = nil
      return self
    }
    public var hasDismissedContacts:Bool {
         get {
             return builderResult.hasDismissedContacts
         }
    }
    public var dismissedContacts:SuggestedContactGroup! {
         get {
             if dismissedContactsBuilder_ != nil {
                builderResult.dismissedContacts = dismissedContactsBuilder_.getMessage()
             }
             return builderResult.dismissedContacts
         }
         set (value) {
             builderResult.hasDismissedContacts = true
             builderResult.dismissedContacts = value
         }
    }
    private var dismissedContactsBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasDismissedContacts = true
         }
    }
    public func getDismissedContactsBuilder() -> SuggestedContactGroup.Builder {
      if dismissedContactsBuilder_ == nil {
         dismissedContactsBuilder_ = SuggestedContactGroup.Builder()
         builderResult.dismissedContacts = dismissedContactsBuilder_.getMessage()
         if dismissedContacts != nil {
            try! dismissedContactsBuilder_.mergeFrom(dismissedContacts)
         }
      }
      return dismissedContactsBuilder_
    }
    public func setDismissedContacts(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.dismissedContacts = value
      return self
    }
    public func mergeDismissedContacts(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasDismissedContacts {
        builderResult.dismissedContacts = try SuggestedContactGroup.builderWithPrototype(builderResult.dismissedContacts).mergeFrom(value).buildPartial()
      } else {
        builderResult.dismissedContacts = value
      }
      builderResult.hasDismissedContacts = true
      return self
    }
    public func clearDismissedContacts() -> GetSuggestedEntitiesResponse.Builder {
      dismissedContactsBuilder_ = nil
      builderResult.hasDismissedContacts = false
      builderResult.dismissedContacts = nil
      return self
    }
    public var hasPinnedFavorites:Bool {
         get {
             return builderResult.hasPinnedFavorites
         }
    }
    public var pinnedFavorites:SuggestedContactGroup! {
         get {
             if pinnedFavoritesBuilder_ != nil {
                builderResult.pinnedFavorites = pinnedFavoritesBuilder_.getMessage()
             }
             return builderResult.pinnedFavorites
         }
         set (value) {
             builderResult.hasPinnedFavorites = true
             builderResult.pinnedFavorites = value
         }
    }
    private var pinnedFavoritesBuilder_:SuggestedContactGroup.Builder! {
         didSet {
            builderResult.hasPinnedFavorites = true
         }
    }
    public func getPinnedFavoritesBuilder() -> SuggestedContactGroup.Builder {
      if pinnedFavoritesBuilder_ == nil {
         pinnedFavoritesBuilder_ = SuggestedContactGroup.Builder()
         builderResult.pinnedFavorites = pinnedFavoritesBuilder_.getMessage()
         if pinnedFavorites != nil {
            try! pinnedFavoritesBuilder_.mergeFrom(pinnedFavorites)
         }
      }
      return pinnedFavoritesBuilder_
    }
    public func setPinnedFavorites(_ value:SuggestedContactGroup!) -> GetSuggestedEntitiesResponse.Builder {
      self.pinnedFavorites = value
      return self
    }
    public func mergePinnedFavorites(_ value:SuggestedContactGroup) throws -> GetSuggestedEntitiesResponse.Builder {
      if builderResult.hasPinnedFavorites {
        builderResult.pinnedFavorites = try SuggestedContactGroup.builderWithPrototype(builderResult.pinnedFavorites).mergeFrom(value).buildPartial()
      } else {
        builderResult.pinnedFavorites = value
      }
      builderResult.hasPinnedFavorites = true
      return self
    }
    public func clearPinnedFavorites() -> GetSuggestedEntitiesResponse.Builder {
      pinnedFavoritesBuilder_ = nil
      builderResult.hasPinnedFavorites = false
      builderResult.pinnedFavorites = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetSuggestedEntitiesResponse.Builder {
      builderResult = GetSuggestedEntitiesResponse()
      return self
    }
    public override func clone() throws -> GetSuggestedEntitiesResponse.Builder {
      return try GetSuggestedEntitiesResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetSuggestedEntitiesResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetSuggestedEntitiesResponse {
      let returnMe:GetSuggestedEntitiesResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetSuggestedEntitiesResponse) throws -> GetSuggestedEntitiesResponse.Builder {
      if other == GetSuggestedEntitiesResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if !other.entity.isEmpty  {
         builderResult.entity += other.entity
      }
      if (other.hasFavorites) {
          try mergeFavorites(other.favorites)
      }
      if (other.hasContactsYouHangoutWith) {
          try mergeContactsYouHangoutWith(other.contactsYouHangoutWith)
      }
      if (other.hasOtherContactsOnHangouts) {
          try mergeOtherContactsOnHangouts(other.otherContactsOnHangouts)
      }
      if (other.hasOtherContacts) {
          try mergeOtherContacts(other.otherContacts)
      }
      if (other.hasDismissedContacts) {
          try mergeDismissedContacts(other.dismissedContacts)
      }
      if (other.hasPinnedFavorites) {
          try mergePinnedFavorites(other.pinnedFavorites)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetSuggestedEntitiesResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSuggestedEntitiesResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder = Entity.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          entity += [subBuilder.buildPartial()]

        case 34:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasFavorites {
            try subBuilder.mergeFrom(favorites)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          favorites = subBuilder.buildPartial()

        case 42:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasContactsYouHangoutWith {
            try subBuilder.mergeFrom(contactsYouHangoutWith)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          contactsYouHangoutWith = subBuilder.buildPartial()

        case 50:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasOtherContactsOnHangouts {
            try subBuilder.mergeFrom(otherContactsOnHangouts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          otherContactsOnHangouts = subBuilder.buildPartial()

        case 58:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasOtherContacts {
            try subBuilder.mergeFrom(otherContacts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          otherContacts = subBuilder.buildPartial()

        case 66:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasDismissedContacts {
            try subBuilder.mergeFrom(dismissedContacts)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          dismissedContacts = subBuilder.buildPartial()

        case 74:
          let subBuilder:SuggestedContactGroup.Builder = SuggestedContactGroup.Builder()
          if hasPinnedFavorites {
            try subBuilder.mergeFrom(pinnedFavorites)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          pinnedFavorites = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetSelfInfoRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetSelfInfoRequest> {
    var mergedArray = Array<GetSelfInfoRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetSelfInfoRequest? {
    return try GetSelfInfoRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoRequest {
    return try GetSelfInfoRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetSelfInfoRequest.Builder {
    return GetSelfInfoRequest.classBuilder() as! GetSelfInfoRequest.Builder
  }
  public func getBuilder() -> GetSelfInfoRequest.Builder {
    return classBuilder() as! GetSelfInfoRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetSelfInfoRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetSelfInfoRequest.Builder()
  }
  public func toBuilder() throws -> GetSelfInfoRequest.Builder {
    return try GetSelfInfoRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetSelfInfoRequest) throws -> GetSelfInfoRequest.Builder {
    return try GetSelfInfoRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetSelfInfoRequest"
  }
  override public func className() -> String {
      return "GetSelfInfoRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetSelfInfoRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetSelfInfoRequest = GetSelfInfoRequest()
    public func getMessage() -> GetSelfInfoRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> GetSelfInfoRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> GetSelfInfoRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> GetSelfInfoRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetSelfInfoRequest.Builder {
      builderResult = GetSelfInfoRequest()
      return self
    }
    public override func clone() throws -> GetSelfInfoRequest.Builder {
      return try GetSelfInfoRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetSelfInfoRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetSelfInfoRequest {
      let returnMe:GetSelfInfoRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetSelfInfoRequest) throws -> GetSelfInfoRequest.Builder {
      if other == GetSelfInfoRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetSelfInfoRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GetSelfInfoResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var selfEntity:Entity!
  public private(set) var hasSelfEntity:Bool = false
  public private(set) var isKnownMinor:Bool = false

  public private(set) var hasIsKnownMinor:Bool = false
  public private(set) var dndState:DoNotDisturbSetting!
  public private(set) var hasDndState:Bool = false
  public private(set) var desktopOffSetting:DesktopOffSetting!
  public private(set) var hasDesktopOffSetting:Bool = false
  public private(set) var phoneData:PhoneData!
  public private(set) var hasPhoneData:Bool = false
  public private(set) var configurationBit:Array<ConfigurationBit>  = Array<ConfigurationBit>()
  public private(set) var desktopOffState:DesktopOffState!
  public private(set) var hasDesktopOffState:Bool = false
  public private(set) var googlePlusUser:Bool = false

  public private(set) var hasGooglePlusUser:Bool = false
  public private(set) var desktopSoundSetting:DesktopSoundSetting!
  public private(set) var hasDesktopSoundSetting:Bool = false
  public private(set) var richPresenceState:RichPresenceState!
  public private(set) var hasRichPresenceState:Bool = false
  public private(set) var defaultCountry:Country!
  public private(set) var hasDefaultCountry:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasSelfEntity {
     if !selfEntity.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasSelfEntity {
      try output.writeMessage(2, value:selfEntity)
    }
    if hasIsKnownMinor {
      try output.writeBool(3, value:isKnownMinor)
    }
    if hasDndState {
      try output.writeMessage(5, value:dndState)
    }
    if hasDesktopOffSetting {
      try output.writeMessage(6, value:desktopOffSetting)
    }
    if hasPhoneData {
      try output.writeMessage(7, value:phoneData)
    }
    for oneElementconfigurationBit in configurationBit {
        try output.writeMessage(8, value:oneElementconfigurationBit)
    }
    if hasDesktopOffState {
      try output.writeMessage(9, value:desktopOffState)
    }
    if hasGooglePlusUser {
      try output.writeBool(10, value:googlePlusUser)
    }
    if hasDesktopSoundSetting {
      try output.writeMessage(11, value:desktopSoundSetting)
    }
    if hasRichPresenceState {
      try output.writeMessage(12, value:richPresenceState)
    }
    if hasDefaultCountry {
      try output.writeMessage(19, value:defaultCountry)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasSelfEntity {
        if let varSizeselfEntity = selfEntity?.computeMessageSize(2) {
            serialize_size += varSizeselfEntity
        }
    }
    if hasIsKnownMinor {
      serialize_size += isKnownMinor.computeBoolSize(3)
    }
    if hasDndState {
        if let varSizedndState = dndState?.computeMessageSize(5) {
            serialize_size += varSizedndState
        }
    }
    if hasDesktopOffSetting {
        if let varSizedesktopOffSetting = desktopOffSetting?.computeMessageSize(6) {
            serialize_size += varSizedesktopOffSetting
        }
    }
    if hasPhoneData {
        if let varSizephoneData = phoneData?.computeMessageSize(7) {
            serialize_size += varSizephoneData
        }
    }
    for oneElementconfigurationBit in configurationBit {
        serialize_size += oneElementconfigurationBit.computeMessageSize(8)
    }
    if hasDesktopOffState {
        if let varSizedesktopOffState = desktopOffState?.computeMessageSize(9) {
            serialize_size += varSizedesktopOffState
        }
    }
    if hasGooglePlusUser {
      serialize_size += googlePlusUser.computeBoolSize(10)
    }
    if hasDesktopSoundSetting {
        if let varSizedesktopSoundSetting = desktopSoundSetting?.computeMessageSize(11) {
            serialize_size += varSizedesktopSoundSetting
        }
    }
    if hasRichPresenceState {
        if let varSizerichPresenceState = richPresenceState?.computeMessageSize(12) {
            serialize_size += varSizerichPresenceState
        }
    }
    if hasDefaultCountry {
        if let varSizedefaultCountry = defaultCountry?.computeMessageSize(19) {
            serialize_size += varSizedefaultCountry
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<GetSelfInfoResponse> {
    var mergedArray = Array<GetSelfInfoResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> GetSelfInfoResponse? {
    return try GetSelfInfoResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoResponse {
    return try GetSelfInfoResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GetSelfInfoResponse.Builder {
    return GetSelfInfoResponse.classBuilder() as! GetSelfInfoResponse.Builder
  }
  public func getBuilder() -> GetSelfInfoResponse.Builder {
    return classBuilder() as! GetSelfInfoResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GetSelfInfoResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GetSelfInfoResponse.Builder()
  }
  public func toBuilder() throws -> GetSelfInfoResponse.Builder {
    return try GetSelfInfoResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:GetSelfInfoResponse) throws -> GetSelfInfoResponse.Builder {
    return try GetSelfInfoResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSelfEntity {
      output += "\(indent) selfEntity {\n"
      if let outDescSelfEntity = selfEntity {
        output += try outDescSelfEntity.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasIsKnownMinor {
      output += "\(indent) isKnownMinor: \(isKnownMinor) \n"
    }
    if hasDndState {
      output += "\(indent) dndState {\n"
      if let outDescDndState = dndState {
        output += try outDescDndState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDesktopOffSetting {
      output += "\(indent) desktopOffSetting {\n"
      if let outDescDesktopOffSetting = desktopOffSetting {
        output += try outDescDesktopOffSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPhoneData {
      output += "\(indent) phoneData {\n"
      if let outDescPhoneData = phoneData {
        output += try outDescPhoneData.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var configurationBitElementIndex:Int = 0
    for oneElementconfigurationBit in configurationBit {
        output += "\(indent) configurationBit[\(configurationBitElementIndex)] {\n"
        output += try oneElementconfigurationBit.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        configurationBitElementIndex += 1
    }
    if hasDesktopOffState {
      output += "\(indent) desktopOffState {\n"
      if let outDescDesktopOffState = desktopOffState {
        output += try outDescDesktopOffState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasGooglePlusUser {
      output += "\(indent) googlePlusUser: \(googlePlusUser) \n"
    }
    if hasDesktopSoundSetting {
      output += "\(indent) desktopSoundSetting {\n"
      if let outDescDesktopSoundSetting = desktopSoundSetting {
        output += try outDescDesktopSoundSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasRichPresenceState {
      output += "\(indent) richPresenceState {\n"
      if let outDescRichPresenceState = richPresenceState {
        output += try outDescRichPresenceState.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDefaultCountry {
      output += "\(indent) defaultCountry {\n"
      if let outDescDefaultCountry = defaultCountry {
        output += try outDescDefaultCountry.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasSelfEntity {
              if let hashValueselfEntity = selfEntity?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueselfEntity
              }
          }
          if hasIsKnownMinor {
             hashCode = (hashCode &* 31) &+ isKnownMinor.hashValue
          }
          if hasDndState {
              if let hashValuedndState = dndState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedndState
              }
          }
          if hasDesktopOffSetting {
              if let hashValuedesktopOffSetting = desktopOffSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopOffSetting
              }
          }
          if hasPhoneData {
              if let hashValuephoneData = phoneData?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuephoneData
              }
          }
          for oneElementconfigurationBit in configurationBit {
              hashCode = (hashCode &* 31) &+ oneElementconfigurationBit.hashValue
          }
          if hasDesktopOffState {
              if let hashValuedesktopOffState = desktopOffState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopOffState
              }
          }
          if hasGooglePlusUser {
             hashCode = (hashCode &* 31) &+ googlePlusUser.hashValue
          }
          if hasDesktopSoundSetting {
              if let hashValuedesktopSoundSetting = desktopSoundSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopSoundSetting
              }
          }
          if hasRichPresenceState {
              if let hashValuerichPresenceState = richPresenceState?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerichPresenceState
              }
          }
          if hasDefaultCountry {
              if let hashValuedefaultCountry = defaultCountry?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedefaultCountry
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GetSelfInfoResponse"
  }
  override public func className() -> String {
      return "GetSelfInfoResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GetSelfInfoResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GetSelfInfoResponse = GetSelfInfoResponse()
    public func getMessage() -> GetSelfInfoResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> GetSelfInfoResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> GetSelfInfoResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasSelfEntity:Bool {
         get {
             return builderResult.hasSelfEntity
         }
    }
    public var selfEntity:Entity! {
         get {
             if selfEntityBuilder_ != nil {
                builderResult.selfEntity = selfEntityBuilder_.getMessage()
             }
             return builderResult.selfEntity
         }
         set (value) {
             builderResult.hasSelfEntity = true
             builderResult.selfEntity = value
         }
    }
    private var selfEntityBuilder_:Entity.Builder! {
         didSet {
            builderResult.hasSelfEntity = true
         }
    }
    public func getSelfEntityBuilder() -> Entity.Builder {
      if selfEntityBuilder_ == nil {
         selfEntityBuilder_ = Entity.Builder()
         builderResult.selfEntity = selfEntityBuilder_.getMessage()
         if selfEntity != nil {
            try! selfEntityBuilder_.mergeFrom(selfEntity)
         }
      }
      return selfEntityBuilder_
    }
    public func setSelfEntity(_ value:Entity!) -> GetSelfInfoResponse.Builder {
      self.selfEntity = value
      return self
    }
    public func mergeSelfEntity(_ value:Entity) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasSelfEntity {
        builderResult.selfEntity = try Entity.builderWithPrototype(builderResult.selfEntity).mergeFrom(value).buildPartial()
      } else {
        builderResult.selfEntity = value
      }
      builderResult.hasSelfEntity = true
      return self
    }
    public func clearSelfEntity() -> GetSelfInfoResponse.Builder {
      selfEntityBuilder_ = nil
      builderResult.hasSelfEntity = false
      builderResult.selfEntity = nil
      return self
    }
    public var hasIsKnownMinor:Bool {
         get {
              return builderResult.hasIsKnownMinor
         }
    }
    public var isKnownMinor:Bool {
         get {
              return builderResult.isKnownMinor
         }
         set (value) {
             builderResult.hasIsKnownMinor = true
             builderResult.isKnownMinor = value
         }
    }
    public func setIsKnownMinor(_ value:Bool) -> GetSelfInfoResponse.Builder {
      self.isKnownMinor = value
      return self
    }
    public func clearIsKnownMinor() -> GetSelfInfoResponse.Builder{
         builderResult.hasIsKnownMinor = false
         builderResult.isKnownMinor = false
         return self
    }
    public var hasDndState:Bool {
         get {
             return builderResult.hasDndState
         }
    }
    public var dndState:DoNotDisturbSetting! {
         get {
             if dndStateBuilder_ != nil {
                builderResult.dndState = dndStateBuilder_.getMessage()
             }
             return builderResult.dndState
         }
         set (value) {
             builderResult.hasDndState = true
             builderResult.dndState = value
         }
    }
    private var dndStateBuilder_:DoNotDisturbSetting.Builder! {
         didSet {
            builderResult.hasDndState = true
         }
    }
    public func getDndStateBuilder() -> DoNotDisturbSetting.Builder {
      if dndStateBuilder_ == nil {
         dndStateBuilder_ = DoNotDisturbSetting.Builder()
         builderResult.dndState = dndStateBuilder_.getMessage()
         if dndState != nil {
            try! dndStateBuilder_.mergeFrom(dndState)
         }
      }
      return dndStateBuilder_
    }
    public func setDndState(_ value:DoNotDisturbSetting!) -> GetSelfInfoResponse.Builder {
      self.dndState = value
      return self
    }
    public func mergeDndState(_ value:DoNotDisturbSetting) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasDndState {
        builderResult.dndState = try DoNotDisturbSetting.builderWithPrototype(builderResult.dndState).mergeFrom(value).buildPartial()
      } else {
        builderResult.dndState = value
      }
      builderResult.hasDndState = true
      return self
    }
    public func clearDndState() -> GetSelfInfoResponse.Builder {
      dndStateBuilder_ = nil
      builderResult.hasDndState = false
      builderResult.dndState = nil
      return self
    }
    public var hasDesktopOffSetting:Bool {
         get {
             return builderResult.hasDesktopOffSetting
         }
    }
    public var desktopOffSetting:DesktopOffSetting! {
         get {
             if desktopOffSettingBuilder_ != nil {
                builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
             }
             return builderResult.desktopOffSetting
         }
         set (value) {
             builderResult.hasDesktopOffSetting = true
             builderResult.desktopOffSetting = value
         }
    }
    private var desktopOffSettingBuilder_:DesktopOffSetting.Builder! {
         didSet {
            builderResult.hasDesktopOffSetting = true
         }
    }
    public func getDesktopOffSettingBuilder() -> DesktopOffSetting.Builder {
      if desktopOffSettingBuilder_ == nil {
         desktopOffSettingBuilder_ = DesktopOffSetting.Builder()
         builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
         if desktopOffSetting != nil {
            try! desktopOffSettingBuilder_.mergeFrom(desktopOffSetting)
         }
      }
      return desktopOffSettingBuilder_
    }
    public func setDesktopOffSetting(_ value:DesktopOffSetting!) -> GetSelfInfoResponse.Builder {
      self.desktopOffSetting = value
      return self
    }
    public func mergeDesktopOffSetting(_ value:DesktopOffSetting) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasDesktopOffSetting {
        builderResult.desktopOffSetting = try DesktopOffSetting.builderWithPrototype(builderResult.desktopOffSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopOffSetting = value
      }
      builderResult.hasDesktopOffSetting = true
      return self
    }
    public func clearDesktopOffSetting() -> GetSelfInfoResponse.Builder {
      desktopOffSettingBuilder_ = nil
      builderResult.hasDesktopOffSetting = false
      builderResult.desktopOffSetting = nil
      return self
    }
    public var hasPhoneData:Bool {
         get {
             return builderResult.hasPhoneData
         }
    }
    public var phoneData:PhoneData! {
         get {
             if phoneDataBuilder_ != nil {
                builderResult.phoneData = phoneDataBuilder_.getMessage()
             }
             return builderResult.phoneData
         }
         set (value) {
             builderResult.hasPhoneData = true
             builderResult.phoneData = value
         }
    }
    private var phoneDataBuilder_:PhoneData.Builder! {
         didSet {
            builderResult.hasPhoneData = true
         }
    }
    public func getPhoneDataBuilder() -> PhoneData.Builder {
      if phoneDataBuilder_ == nil {
         phoneDataBuilder_ = PhoneData.Builder()
         builderResult.phoneData = phoneDataBuilder_.getMessage()
         if phoneData != nil {
            try! phoneDataBuilder_.mergeFrom(phoneData)
         }
      }
      return phoneDataBuilder_
    }
    public func setPhoneData(_ value:PhoneData!) -> GetSelfInfoResponse.Builder {
      self.phoneData = value
      return self
    }
    public func mergePhoneData(_ value:PhoneData) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasPhoneData {
        builderResult.phoneData = try PhoneData.builderWithPrototype(builderResult.phoneData).mergeFrom(value).buildPartial()
      } else {
        builderResult.phoneData = value
      }
      builderResult.hasPhoneData = true
      return self
    }
    public func clearPhoneData() -> GetSelfInfoResponse.Builder {
      phoneDataBuilder_ = nil
      builderResult.hasPhoneData = false
      builderResult.phoneData = nil
      return self
    }
    public var configurationBit:Array<ConfigurationBit> {
         get {
             return builderResult.configurationBit
         }
         set (value) {
             builderResult.configurationBit = value
         }
    }
    public func setConfigurationBit(_ value:Array<ConfigurationBit>) -> GetSelfInfoResponse.Builder {
      self.configurationBit = value
      return self
    }
    public func clearConfigurationBit() -> GetSelfInfoResponse.Builder {
      builderResult.configurationBit.removeAll(keepingCapacity: false)
      return self
    }
    public var hasDesktopOffState:Bool {
         get {
             return builderResult.hasDesktopOffState
         }
    }
    public var desktopOffState:DesktopOffState! {
         get {
             if desktopOffStateBuilder_ != nil {
                builderResult.desktopOffState = desktopOffStateBuilder_.getMessage()
             }
             return builderResult.desktopOffState
         }
         set (value) {
             builderResult.hasDesktopOffState = true
             builderResult.desktopOffState = value
         }
    }
    private var desktopOffStateBuilder_:DesktopOffState.Builder! {
         didSet {
            builderResult.hasDesktopOffState = true
         }
    }
    public func getDesktopOffStateBuilder() -> DesktopOffState.Builder {
      if desktopOffStateBuilder_ == nil {
         desktopOffStateBuilder_ = DesktopOffState.Builder()
         builderResult.desktopOffState = desktopOffStateBuilder_.getMessage()
         if desktopOffState != nil {
            try! desktopOffStateBuilder_.mergeFrom(desktopOffState)
         }
      }
      return desktopOffStateBuilder_
    }
    public func setDesktopOffState(_ value:DesktopOffState!) -> GetSelfInfoResponse.Builder {
      self.desktopOffState = value
      return self
    }
    public func mergeDesktopOffState(_ value:DesktopOffState) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasDesktopOffState {
        builderResult.desktopOffState = try DesktopOffState.builderWithPrototype(builderResult.desktopOffState).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopOffState = value
      }
      builderResult.hasDesktopOffState = true
      return self
    }
    public func clearDesktopOffState() -> GetSelfInfoResponse.Builder {
      desktopOffStateBuilder_ = nil
      builderResult.hasDesktopOffState = false
      builderResult.desktopOffState = nil
      return self
    }
    public var hasGooglePlusUser:Bool {
         get {
              return builderResult.hasGooglePlusUser
         }
    }
    public var googlePlusUser:Bool {
         get {
              return builderResult.googlePlusUser
         }
         set (value) {
             builderResult.hasGooglePlusUser = true
             builderResult.googlePlusUser = value
         }
    }
    public func setGooglePlusUser(_ value:Bool) -> GetSelfInfoResponse.Builder {
      self.googlePlusUser = value
      return self
    }
    public func clearGooglePlusUser() -> GetSelfInfoResponse.Builder{
         builderResult.hasGooglePlusUser = false
         builderResult.googlePlusUser = false
         return self
    }
    public var hasDesktopSoundSetting:Bool {
         get {
             return builderResult.hasDesktopSoundSetting
         }
    }
    public var desktopSoundSetting:DesktopSoundSetting! {
         get {
             if desktopSoundSettingBuilder_ != nil {
                builderResult.desktopSoundSetting = desktopSoundSettingBuilder_.getMessage()
             }
             return builderResult.desktopSoundSetting
         }
         set (value) {
             builderResult.hasDesktopSoundSetting = true
             builderResult.desktopSoundSetting = value
         }
    }
    private var desktopSoundSettingBuilder_:DesktopSoundSetting.Builder! {
         didSet {
            builderResult.hasDesktopSoundSetting = true
         }
    }
    public func getDesktopSoundSettingBuilder() -> DesktopSoundSetting.Builder {
      if desktopSoundSettingBuilder_ == nil {
         desktopSoundSettingBuilder_ = DesktopSoundSetting.Builder()
         builderResult.desktopSoundSetting = desktopSoundSettingBuilder_.getMessage()
         if desktopSoundSetting != nil {
            try! desktopSoundSettingBuilder_.mergeFrom(desktopSoundSetting)
         }
      }
      return desktopSoundSettingBuilder_
    }
    public func setDesktopSoundSetting(_ value:DesktopSoundSetting!) -> GetSelfInfoResponse.Builder {
      self.desktopSoundSetting = value
      return self
    }
    public func mergeDesktopSoundSetting(_ value:DesktopSoundSetting) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasDesktopSoundSetting {
        builderResult.desktopSoundSetting = try DesktopSoundSetting.builderWithPrototype(builderResult.desktopSoundSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopSoundSetting = value
      }
      builderResult.hasDesktopSoundSetting = true
      return self
    }
    public func clearDesktopSoundSetting() -> GetSelfInfoResponse.Builder {
      desktopSoundSettingBuilder_ = nil
      builderResult.hasDesktopSoundSetting = false
      builderResult.desktopSoundSetting = nil
      return self
    }
    public var hasRichPresenceState:Bool {
         get {
             return builderResult.hasRichPresenceState
         }
    }
    public var richPresenceState:RichPresenceState! {
         get {
             if richPresenceStateBuilder_ != nil {
                builderResult.richPresenceState = richPresenceStateBuilder_.getMessage()
             }
             return builderResult.richPresenceState
         }
         set (value) {
             builderResult.hasRichPresenceState = true
             builderResult.richPresenceState = value
         }
    }
    private var richPresenceStateBuilder_:RichPresenceState.Builder! {
         didSet {
            builderResult.hasRichPresenceState = true
         }
    }
    public func getRichPresenceStateBuilder() -> RichPresenceState.Builder {
      if richPresenceStateBuilder_ == nil {
         richPresenceStateBuilder_ = RichPresenceState.Builder()
         builderResult.richPresenceState = richPresenceStateBuilder_.getMessage()
         if richPresenceState != nil {
            try! richPresenceStateBuilder_.mergeFrom(richPresenceState)
         }
      }
      return richPresenceStateBuilder_
    }
    public func setRichPresenceState(_ value:RichPresenceState!) -> GetSelfInfoResponse.Builder {
      self.richPresenceState = value
      return self
    }
    public func mergeRichPresenceState(_ value:RichPresenceState) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasRichPresenceState {
        builderResult.richPresenceState = try RichPresenceState.builderWithPrototype(builderResult.richPresenceState).mergeFrom(value).buildPartial()
      } else {
        builderResult.richPresenceState = value
      }
      builderResult.hasRichPresenceState = true
      return self
    }
    public func clearRichPresenceState() -> GetSelfInfoResponse.Builder {
      richPresenceStateBuilder_ = nil
      builderResult.hasRichPresenceState = false
      builderResult.richPresenceState = nil
      return self
    }
    public var hasDefaultCountry:Bool {
         get {
             return builderResult.hasDefaultCountry
         }
    }
    public var defaultCountry:Country! {
         get {
             if defaultCountryBuilder_ != nil {
                builderResult.defaultCountry = defaultCountryBuilder_.getMessage()
             }
             return builderResult.defaultCountry
         }
         set (value) {
             builderResult.hasDefaultCountry = true
             builderResult.defaultCountry = value
         }
    }
    private var defaultCountryBuilder_:Country.Builder! {
         didSet {
            builderResult.hasDefaultCountry = true
         }
    }
    public func getDefaultCountryBuilder() -> Country.Builder {
      if defaultCountryBuilder_ == nil {
         defaultCountryBuilder_ = Country.Builder()
         builderResult.defaultCountry = defaultCountryBuilder_.getMessage()
         if defaultCountry != nil {
            try! defaultCountryBuilder_.mergeFrom(defaultCountry)
         }
      }
      return defaultCountryBuilder_
    }
    public func setDefaultCountry(_ value:Country!) -> GetSelfInfoResponse.Builder {
      self.defaultCountry = value
      return self
    }
    public func mergeDefaultCountry(_ value:Country) throws -> GetSelfInfoResponse.Builder {
      if builderResult.hasDefaultCountry {
        builderResult.defaultCountry = try Country.builderWithPrototype(builderResult.defaultCountry).mergeFrom(value).buildPartial()
      } else {
        builderResult.defaultCountry = value
      }
      builderResult.hasDefaultCountry = true
      return self
    }
    public func clearDefaultCountry() -> GetSelfInfoResponse.Builder {
      defaultCountryBuilder_ = nil
      builderResult.hasDefaultCountry = false
      builderResult.defaultCountry = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GetSelfInfoResponse.Builder {
      builderResult = GetSelfInfoResponse()
      return self
    }
    public override func clone() throws -> GetSelfInfoResponse.Builder {
      return try GetSelfInfoResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GetSelfInfoResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GetSelfInfoResponse {
      let returnMe:GetSelfInfoResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:GetSelfInfoResponse) throws -> GetSelfInfoResponse.Builder {
      if other == GetSelfInfoResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasSelfEntity) {
          try mergeSelfEntity(other.selfEntity)
      }
      if other.hasIsKnownMinor {
           isKnownMinor = other.isKnownMinor
      }
      if (other.hasDndState) {
          try mergeDndState(other.dndState)
      }
      if (other.hasDesktopOffSetting) {
          try mergeDesktopOffSetting(other.desktopOffSetting)
      }
      if (other.hasPhoneData) {
          try mergePhoneData(other.phoneData)
      }
      if !other.configurationBit.isEmpty  {
         builderResult.configurationBit += other.configurationBit
      }
      if (other.hasDesktopOffState) {
          try mergeDesktopOffState(other.desktopOffState)
      }
      if other.hasGooglePlusUser {
           googlePlusUser = other.googlePlusUser
      }
      if (other.hasDesktopSoundSetting) {
          try mergeDesktopSoundSetting(other.desktopSoundSetting)
      }
      if (other.hasRichPresenceState) {
          try mergeRichPresenceState(other.richPresenceState)
      }
      if (other.hasDefaultCountry) {
          try mergeDefaultCountry(other.defaultCountry)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> GetSelfInfoResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetSelfInfoResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:Entity.Builder = Entity.Builder()
          if hasSelfEntity {
            try subBuilder.mergeFrom(selfEntity)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          selfEntity = subBuilder.buildPartial()

        case 24:
          isKnownMinor = try input.readBool()

        case 42:
          let subBuilder:DoNotDisturbSetting.Builder = DoNotDisturbSetting.Builder()
          if hasDndState {
            try subBuilder.mergeFrom(dndState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          dndState = subBuilder.buildPartial()

        case 50:
          let subBuilder:DesktopOffSetting.Builder = DesktopOffSetting.Builder()
          if hasDesktopOffSetting {
            try subBuilder.mergeFrom(desktopOffSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopOffSetting = subBuilder.buildPartial()

        case 58:
          let subBuilder:PhoneData.Builder = PhoneData.Builder()
          if hasPhoneData {
            try subBuilder.mergeFrom(phoneData)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          phoneData = subBuilder.buildPartial()

        case 66:
          let subBuilder = ConfigurationBit.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          configurationBit += [subBuilder.buildPartial()]

        case 74:
          let subBuilder:DesktopOffState.Builder = DesktopOffState.Builder()
          if hasDesktopOffState {
            try subBuilder.mergeFrom(desktopOffState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopOffState = subBuilder.buildPartial()

        case 80:
          googlePlusUser = try input.readBool()

        case 90:
          let subBuilder:DesktopSoundSetting.Builder = DesktopSoundSetting.Builder()
          if hasDesktopSoundSetting {
            try subBuilder.mergeFrom(desktopSoundSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopSoundSetting = subBuilder.buildPartial()

        case 98:
          let subBuilder:RichPresenceState.Builder = RichPresenceState.Builder()
          if hasRichPresenceState {
            try subBuilder.mergeFrom(richPresenceState)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          richPresenceState = subBuilder.buildPartial()

        case 154:
          let subBuilder:Country.Builder = Country.Builder()
          if hasDefaultCountry {
            try subBuilder.mergeFrom(defaultCountry)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          defaultCountry = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class QueryPresenceRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var participantId:Array<ParticipantId>  = Array<ParticipantId>()
  private var fieldMaskMemoizedSerializedSize:Int32 = 0
  public private(set) var fieldMask:Array<FieldMask> = Array<FieldMask>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    for oneElementparticipantId in participantId {
        try output.writeMessage(2, value:oneElementparticipantId)
    }
    for oneValueOffieldMask in fieldMask {
        try output.writeEnum(3, value:oneValueOffieldMask.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    for oneElementparticipantId in participantId {
        serialize_size += oneElementparticipantId.computeMessageSize(2)
    }
    var dataSizefieldMask:Int32 = 0
    for oneValueOffieldMask in fieldMask {
        dataSizefieldMask += oneValueOffieldMask.rawValue.computeEnumSizeNoTag()
    }
    serialize_size += dataSizefieldMask
    serialize_size += (1 * Int32(fieldMask.count))
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<QueryPresenceRequest> {
    var mergedArray = Array<QueryPresenceRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> QueryPresenceRequest? {
    return try QueryPresenceRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceRequest {
    return try QueryPresenceRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> QueryPresenceRequest.Builder {
    return QueryPresenceRequest.classBuilder() as! QueryPresenceRequest.Builder
  }
  public func getBuilder() -> QueryPresenceRequest.Builder {
    return classBuilder() as! QueryPresenceRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return QueryPresenceRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return QueryPresenceRequest.Builder()
  }
  public func toBuilder() throws -> QueryPresenceRequest.Builder {
    return try QueryPresenceRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:QueryPresenceRequest) throws -> QueryPresenceRequest.Builder {
    return try QueryPresenceRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var participantIdElementIndex:Int = 0
    for oneElementparticipantId in participantId {
        output += "\(indent) participantId[\(participantIdElementIndex)] {\n"
        output += try oneElementparticipantId.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        participantIdElementIndex += 1
    }
    var fieldMaskElementIndex:Int = 0
    for oneValueOffieldMask in fieldMask {
        output += "\(indent) fieldMask[\(fieldMaskElementIndex)]: \(oneValueOffieldMask.description)\n"
        fieldMaskElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          for oneElementparticipantId in participantId {
              hashCode = (hashCode &* 31) &+ oneElementparticipantId.hashValue
          }
          for oneValueOffieldMask in fieldMask {
              hashCode = (hashCode &* 31) &+ Int(oneValueOffieldMask.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "QueryPresenceRequest"
  }
  override public func className() -> String {
      return "QueryPresenceRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return QueryPresenceRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:QueryPresenceRequest = QueryPresenceRequest()
    public func getMessage() -> QueryPresenceRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> QueryPresenceRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> QueryPresenceRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> QueryPresenceRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var participantId:Array<ParticipantId> {
         get {
             return builderResult.participantId
         }
         set (value) {
             builderResult.participantId = value
         }
    }
    public func setParticipantId(_ value:Array<ParticipantId>) -> QueryPresenceRequest.Builder {
      self.participantId = value
      return self
    }
    public func clearParticipantId() -> QueryPresenceRequest.Builder {
      builderResult.participantId.removeAll(keepingCapacity: false)
      return self
    }
    public var fieldMask:Array<FieldMask> {
        get {
            return builderResult.fieldMask
        }
        set (value) {
            builderResult.fieldMask = value
        }
    }
    public func setFieldMask(_ value:Array<FieldMask>) -> QueryPresenceRequest.Builder {
      self.fieldMask = value
      return self
    }
    public func clearFieldMask() -> QueryPresenceRequest.Builder {
      builderResult.fieldMask.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> QueryPresenceRequest.Builder {
      builderResult = QueryPresenceRequest()
      return self
    }
    public override func clone() throws -> QueryPresenceRequest.Builder {
      return try QueryPresenceRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> QueryPresenceRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> QueryPresenceRequest {
      let returnMe:QueryPresenceRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:QueryPresenceRequest) throws -> QueryPresenceRequest.Builder {
      if other == QueryPresenceRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if !other.participantId.isEmpty  {
         builderResult.participantId += other.participantId
      }
      if !other.fieldMask.isEmpty {
         builderResult.fieldMask += other.fieldMask
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> QueryPresenceRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder = ParticipantId.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          participantId += [subBuilder.buildPartial()]

        case 24:
          let valueIntfieldMask = try input.readEnum()
          if let enumsfieldMask = FieldMask(rawValue:valueIntfieldMask) {
               builderResult.fieldMask += [enumsfieldMask]
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntfieldMask))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class QueryPresenceResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var presenceResult:Array<PresenceResult>  = Array<PresenceResult>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitpresenceResult:Bool = true
    for oneElementpresenceResult in presenceResult {
        if (!oneElementpresenceResult.isInitialized()) {
            isInitpresenceResult = false
            break 
        }
    }
    if !isInitpresenceResult {
     return isInitpresenceResult
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    for oneElementpresenceResult in presenceResult {
        try output.writeMessage(2, value:oneElementpresenceResult)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    for oneElementpresenceResult in presenceResult {
        serialize_size += oneElementpresenceResult.computeMessageSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<QueryPresenceResponse> {
    var mergedArray = Array<QueryPresenceResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> QueryPresenceResponse? {
    return try QueryPresenceResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceResponse {
    return try QueryPresenceResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> QueryPresenceResponse.Builder {
    return QueryPresenceResponse.classBuilder() as! QueryPresenceResponse.Builder
  }
  public func getBuilder() -> QueryPresenceResponse.Builder {
    return classBuilder() as! QueryPresenceResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return QueryPresenceResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return QueryPresenceResponse.Builder()
  }
  public func toBuilder() throws -> QueryPresenceResponse.Builder {
    return try QueryPresenceResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:QueryPresenceResponse) throws -> QueryPresenceResponse.Builder {
    return try QueryPresenceResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var presenceResultElementIndex:Int = 0
    for oneElementpresenceResult in presenceResult {
        output += "\(indent) presenceResult[\(presenceResultElementIndex)] {\n"
        output += try oneElementpresenceResult.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        presenceResultElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          for oneElementpresenceResult in presenceResult {
              hashCode = (hashCode &* 31) &+ oneElementpresenceResult.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "QueryPresenceResponse"
  }
  override public func className() -> String {
      return "QueryPresenceResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return QueryPresenceResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:QueryPresenceResponse = QueryPresenceResponse()
    public func getMessage() -> QueryPresenceResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> QueryPresenceResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> QueryPresenceResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> QueryPresenceResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var presenceResult:Array<PresenceResult> {
         get {
             return builderResult.presenceResult
         }
         set (value) {
             builderResult.presenceResult = value
         }
    }
    public func setPresenceResult(_ value:Array<PresenceResult>) -> QueryPresenceResponse.Builder {
      self.presenceResult = value
      return self
    }
    public func clearPresenceResult() -> QueryPresenceResponse.Builder {
      builderResult.presenceResult.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> QueryPresenceResponse.Builder {
      builderResult = QueryPresenceResponse()
      return self
    }
    public override func clone() throws -> QueryPresenceResponse.Builder {
      return try QueryPresenceResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> QueryPresenceResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> QueryPresenceResponse {
      let returnMe:QueryPresenceResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:QueryPresenceResponse) throws -> QueryPresenceResponse.Builder {
      if other == QueryPresenceResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if !other.presenceResult.isEmpty  {
         builderResult.presenceResult += other.presenceResult
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> QueryPresenceResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> QueryPresenceResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder = PresenceResult.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          presenceResult += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RemoveUserRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var eventRequestHeader:EventRequestHeader!
  public private(set) var hasEventRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasEventRequestHeader {
      try output.writeMessage(5, value:eventRequestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasEventRequestHeader {
        if let varSizeeventRequestHeader = eventRequestHeader?.computeMessageSize(5) {
            serialize_size += varSizeeventRequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RemoveUserRequest> {
    var mergedArray = Array<RemoveUserRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RemoveUserRequest? {
    return try RemoveUserRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserRequest {
    return try RemoveUserRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RemoveUserRequest.Builder {
    return RemoveUserRequest.classBuilder() as! RemoveUserRequest.Builder
  }
  public func getBuilder() -> RemoveUserRequest.Builder {
    return classBuilder() as! RemoveUserRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RemoveUserRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RemoveUserRequest.Builder()
  }
  public func toBuilder() throws -> RemoveUserRequest.Builder {
    return try RemoveUserRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RemoveUserRequest) throws -> RemoveUserRequest.Builder {
    return try RemoveUserRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEventRequestHeader {
      output += "\(indent) eventRequestHeader {\n"
      if let outDescEventRequestHeader = eventRequestHeader {
        output += try outDescEventRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasEventRequestHeader {
              if let hashValueeventRequestHeader = eventRequestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventRequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RemoveUserRequest"
  }
  override public func className() -> String {
      return "RemoveUserRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RemoveUserRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RemoveUserRequest = RemoveUserRequest()
    public func getMessage() -> RemoveUserRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> RemoveUserRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> RemoveUserRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> RemoveUserRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasEventRequestHeader:Bool {
         get {
             return builderResult.hasEventRequestHeader
         }
    }
    public var eventRequestHeader:EventRequestHeader! {
         get {
             if eventRequestHeaderBuilder_ != nil {
                builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
             }
             return builderResult.eventRequestHeader
         }
         set (value) {
             builderResult.hasEventRequestHeader = true
             builderResult.eventRequestHeader = value
         }
    }
    private var eventRequestHeaderBuilder_:EventRequestHeader.Builder! {
         didSet {
            builderResult.hasEventRequestHeader = true
         }
    }
    public func getEventRequestHeaderBuilder() -> EventRequestHeader.Builder {
      if eventRequestHeaderBuilder_ == nil {
         eventRequestHeaderBuilder_ = EventRequestHeader.Builder()
         builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
         if eventRequestHeader != nil {
            try! eventRequestHeaderBuilder_.mergeFrom(eventRequestHeader)
         }
      }
      return eventRequestHeaderBuilder_
    }
    public func setEventRequestHeader(_ value:EventRequestHeader!) -> RemoveUserRequest.Builder {
      self.eventRequestHeader = value
      return self
    }
    public func mergeEventRequestHeader(_ value:EventRequestHeader) throws -> RemoveUserRequest.Builder {
      if builderResult.hasEventRequestHeader {
        builderResult.eventRequestHeader = try EventRequestHeader.builderWithPrototype(builderResult.eventRequestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventRequestHeader = value
      }
      builderResult.hasEventRequestHeader = true
      return self
    }
    public func clearEventRequestHeader() -> RemoveUserRequest.Builder {
      eventRequestHeaderBuilder_ = nil
      builderResult.hasEventRequestHeader = false
      builderResult.eventRequestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RemoveUserRequest.Builder {
      builderResult = RemoveUserRequest()
      return self
    }
    public override func clone() throws -> RemoveUserRequest.Builder {
      return try RemoveUserRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RemoveUserRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RemoveUserRequest {
      let returnMe:RemoveUserRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RemoveUserRequest) throws -> RemoveUserRequest.Builder {
      if other == RemoveUserRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasEventRequestHeader) {
          try mergeEventRequestHeader(other.eventRequestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RemoveUserRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 42:
          let subBuilder:EventRequestHeader.Builder = EventRequestHeader.Builder()
          if hasEventRequestHeader {
            try subBuilder.mergeFrom(eventRequestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventRequestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RemoveUserResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var createdEvent:Event!
  public private(set) var hasCreatedEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasCreatedEvent {
     if !createdEvent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasCreatedEvent {
      try output.writeMessage(4, value:createdEvent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasCreatedEvent {
        if let varSizecreatedEvent = createdEvent?.computeMessageSize(4) {
            serialize_size += varSizecreatedEvent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RemoveUserResponse> {
    var mergedArray = Array<RemoveUserResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RemoveUserResponse? {
    return try RemoveUserResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserResponse {
    return try RemoveUserResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RemoveUserResponse.Builder {
    return RemoveUserResponse.classBuilder() as! RemoveUserResponse.Builder
  }
  public func getBuilder() -> RemoveUserResponse.Builder {
    return classBuilder() as! RemoveUserResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RemoveUserResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RemoveUserResponse.Builder()
  }
  public func toBuilder() throws -> RemoveUserResponse.Builder {
    return try RemoveUserResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RemoveUserResponse) throws -> RemoveUserResponse.Builder {
    return try RemoveUserResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCreatedEvent {
      output += "\(indent) createdEvent {\n"
      if let outDescCreatedEvent = createdEvent {
        output += try outDescCreatedEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasCreatedEvent {
              if let hashValuecreatedEvent = createdEvent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecreatedEvent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RemoveUserResponse"
  }
  override public func className() -> String {
      return "RemoveUserResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RemoveUserResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RemoveUserResponse = RemoveUserResponse()
    public func getMessage() -> RemoveUserResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> RemoveUserResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> RemoveUserResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> RemoveUserResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasCreatedEvent:Bool {
         get {
             return builderResult.hasCreatedEvent
         }
    }
    public var createdEvent:Event! {
         get {
             if createdEventBuilder_ != nil {
                builderResult.createdEvent = createdEventBuilder_.getMessage()
             }
             return builderResult.createdEvent
         }
         set (value) {
             builderResult.hasCreatedEvent = true
             builderResult.createdEvent = value
         }
    }
    private var createdEventBuilder_:Event.Builder! {
         didSet {
            builderResult.hasCreatedEvent = true
         }
    }
    public func getCreatedEventBuilder() -> Event.Builder {
      if createdEventBuilder_ == nil {
         createdEventBuilder_ = Event.Builder()
         builderResult.createdEvent = createdEventBuilder_.getMessage()
         if createdEvent != nil {
            try! createdEventBuilder_.mergeFrom(createdEvent)
         }
      }
      return createdEventBuilder_
    }
    public func setCreatedEvent(_ value:Event!) -> RemoveUserResponse.Builder {
      self.createdEvent = value
      return self
    }
    public func mergeCreatedEvent(_ value:Event) throws -> RemoveUserResponse.Builder {
      if builderResult.hasCreatedEvent {
        builderResult.createdEvent = try Event.builderWithPrototype(builderResult.createdEvent).mergeFrom(value).buildPartial()
      } else {
        builderResult.createdEvent = value
      }
      builderResult.hasCreatedEvent = true
      return self
    }
    public func clearCreatedEvent() -> RemoveUserResponse.Builder {
      createdEventBuilder_ = nil
      builderResult.hasCreatedEvent = false
      builderResult.createdEvent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RemoveUserResponse.Builder {
      builderResult = RemoveUserResponse()
      return self
    }
    public override func clone() throws -> RemoveUserResponse.Builder {
      return try RemoveUserResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RemoveUserResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RemoveUserResponse {
      let returnMe:RemoveUserResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RemoveUserResponse) throws -> RemoveUserResponse.Builder {
      if other == RemoveUserResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasCreatedEvent) {
          try mergeCreatedEvent(other.createdEvent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RemoveUserResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RemoveUserResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 34:
          let subBuilder:Event.Builder = Event.Builder()
          if hasCreatedEvent {
            try subBuilder.mergeFrom(createdEvent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          createdEvent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RenameConversationRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var newName:String = ""

  public private(set) var hasNewName:Bool = false
  public private(set) var eventRequestHeader:EventRequestHeader!
  public private(set) var hasEventRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasNewName {
      try output.writeString(3, value:newName)
    }
    if hasEventRequestHeader {
      try output.writeMessage(5, value:eventRequestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasNewName {
      serialize_size += newName.computeStringSize(3)
    }
    if hasEventRequestHeader {
        if let varSizeeventRequestHeader = eventRequestHeader?.computeMessageSize(5) {
            serialize_size += varSizeeventRequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RenameConversationRequest> {
    var mergedArray = Array<RenameConversationRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RenameConversationRequest? {
    return try RenameConversationRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationRequest {
    return try RenameConversationRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RenameConversationRequest.Builder {
    return RenameConversationRequest.classBuilder() as! RenameConversationRequest.Builder
  }
  public func getBuilder() -> RenameConversationRequest.Builder {
    return classBuilder() as! RenameConversationRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RenameConversationRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RenameConversationRequest.Builder()
  }
  public func toBuilder() throws -> RenameConversationRequest.Builder {
    return try RenameConversationRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RenameConversationRequest) throws -> RenameConversationRequest.Builder {
    return try RenameConversationRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNewName {
      output += "\(indent) newName: \(newName) \n"
    }
    if hasEventRequestHeader {
      output += "\(indent) eventRequestHeader {\n"
      if let outDescEventRequestHeader = eventRequestHeader {
        output += try outDescEventRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasNewName {
             hashCode = (hashCode &* 31) &+ newName.hashValue
          }
          if hasEventRequestHeader {
              if let hashValueeventRequestHeader = eventRequestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventRequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RenameConversationRequest"
  }
  override public func className() -> String {
      return "RenameConversationRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RenameConversationRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RenameConversationRequest = RenameConversationRequest()
    public func getMessage() -> RenameConversationRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> RenameConversationRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> RenameConversationRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> RenameConversationRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasNewName:Bool {
         get {
              return builderResult.hasNewName
         }
    }
    public var newName:String {
         get {
              return builderResult.newName
         }
         set (value) {
             builderResult.hasNewName = true
             builderResult.newName = value
         }
    }
    public func setNewName(_ value:String) -> RenameConversationRequest.Builder {
      self.newName = value
      return self
    }
    public func clearNewName() -> RenameConversationRequest.Builder{
         builderResult.hasNewName = false
         builderResult.newName = ""
         return self
    }
    public var hasEventRequestHeader:Bool {
         get {
             return builderResult.hasEventRequestHeader
         }
    }
    public var eventRequestHeader:EventRequestHeader! {
         get {
             if eventRequestHeaderBuilder_ != nil {
                builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
             }
             return builderResult.eventRequestHeader
         }
         set (value) {
             builderResult.hasEventRequestHeader = true
             builderResult.eventRequestHeader = value
         }
    }
    private var eventRequestHeaderBuilder_:EventRequestHeader.Builder! {
         didSet {
            builderResult.hasEventRequestHeader = true
         }
    }
    public func getEventRequestHeaderBuilder() -> EventRequestHeader.Builder {
      if eventRequestHeaderBuilder_ == nil {
         eventRequestHeaderBuilder_ = EventRequestHeader.Builder()
         builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
         if eventRequestHeader != nil {
            try! eventRequestHeaderBuilder_.mergeFrom(eventRequestHeader)
         }
      }
      return eventRequestHeaderBuilder_
    }
    public func setEventRequestHeader(_ value:EventRequestHeader!) -> RenameConversationRequest.Builder {
      self.eventRequestHeader = value
      return self
    }
    public func mergeEventRequestHeader(_ value:EventRequestHeader) throws -> RenameConversationRequest.Builder {
      if builderResult.hasEventRequestHeader {
        builderResult.eventRequestHeader = try EventRequestHeader.builderWithPrototype(builderResult.eventRequestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventRequestHeader = value
      }
      builderResult.hasEventRequestHeader = true
      return self
    }
    public func clearEventRequestHeader() -> RenameConversationRequest.Builder {
      eventRequestHeaderBuilder_ = nil
      builderResult.hasEventRequestHeader = false
      builderResult.eventRequestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RenameConversationRequest.Builder {
      builderResult = RenameConversationRequest()
      return self
    }
    public override func clone() throws -> RenameConversationRequest.Builder {
      return try RenameConversationRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RenameConversationRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RenameConversationRequest {
      let returnMe:RenameConversationRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RenameConversationRequest) throws -> RenameConversationRequest.Builder {
      if other == RenameConversationRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasNewName {
           newName = other.newName
      }
      if (other.hasEventRequestHeader) {
          try mergeEventRequestHeader(other.eventRequestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RenameConversationRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 26:
          newName = try input.readString()

        case 42:
          let subBuilder:EventRequestHeader.Builder = EventRequestHeader.Builder()
          if hasEventRequestHeader {
            try subBuilder.mergeFrom(eventRequestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventRequestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RenameConversationResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var createdEvent:Event!
  public private(set) var hasCreatedEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasCreatedEvent {
     if !createdEvent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasCreatedEvent {
      try output.writeMessage(4, value:createdEvent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasCreatedEvent {
        if let varSizecreatedEvent = createdEvent?.computeMessageSize(4) {
            serialize_size += varSizecreatedEvent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<RenameConversationResponse> {
    var mergedArray = Array<RenameConversationResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> RenameConversationResponse? {
    return try RenameConversationResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationResponse {
    return try RenameConversationResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RenameConversationResponse.Builder {
    return RenameConversationResponse.classBuilder() as! RenameConversationResponse.Builder
  }
  public func getBuilder() -> RenameConversationResponse.Builder {
    return classBuilder() as! RenameConversationResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RenameConversationResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RenameConversationResponse.Builder()
  }
  public func toBuilder() throws -> RenameConversationResponse.Builder {
    return try RenameConversationResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RenameConversationResponse) throws -> RenameConversationResponse.Builder {
    return try RenameConversationResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCreatedEvent {
      output += "\(indent) createdEvent {\n"
      if let outDescCreatedEvent = createdEvent {
        output += try outDescCreatedEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasCreatedEvent {
              if let hashValuecreatedEvent = createdEvent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecreatedEvent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RenameConversationResponse"
  }
  override public func className() -> String {
      return "RenameConversationResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RenameConversationResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RenameConversationResponse = RenameConversationResponse()
    public func getMessage() -> RenameConversationResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> RenameConversationResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> RenameConversationResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> RenameConversationResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasCreatedEvent:Bool {
         get {
             return builderResult.hasCreatedEvent
         }
    }
    public var createdEvent:Event! {
         get {
             if createdEventBuilder_ != nil {
                builderResult.createdEvent = createdEventBuilder_.getMessage()
             }
             return builderResult.createdEvent
         }
         set (value) {
             builderResult.hasCreatedEvent = true
             builderResult.createdEvent = value
         }
    }
    private var createdEventBuilder_:Event.Builder! {
         didSet {
            builderResult.hasCreatedEvent = true
         }
    }
    public func getCreatedEventBuilder() -> Event.Builder {
      if createdEventBuilder_ == nil {
         createdEventBuilder_ = Event.Builder()
         builderResult.createdEvent = createdEventBuilder_.getMessage()
         if createdEvent != nil {
            try! createdEventBuilder_.mergeFrom(createdEvent)
         }
      }
      return createdEventBuilder_
    }
    public func setCreatedEvent(_ value:Event!) -> RenameConversationResponse.Builder {
      self.createdEvent = value
      return self
    }
    public func mergeCreatedEvent(_ value:Event) throws -> RenameConversationResponse.Builder {
      if builderResult.hasCreatedEvent {
        builderResult.createdEvent = try Event.builderWithPrototype(builderResult.createdEvent).mergeFrom(value).buildPartial()
      } else {
        builderResult.createdEvent = value
      }
      builderResult.hasCreatedEvent = true
      return self
    }
    public func clearCreatedEvent() -> RenameConversationResponse.Builder {
      createdEventBuilder_ = nil
      builderResult.hasCreatedEvent = false
      builderResult.createdEvent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RenameConversationResponse.Builder {
      builderResult = RenameConversationResponse()
      return self
    }
    public override func clone() throws -> RenameConversationResponse.Builder {
      return try RenameConversationResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RenameConversationResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RenameConversationResponse {
      let returnMe:RenameConversationResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RenameConversationResponse) throws -> RenameConversationResponse.Builder {
      if other == RenameConversationResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasCreatedEvent) {
          try mergeCreatedEvent(other.createdEvent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RenameConversationResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RenameConversationResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 34:
          let subBuilder:Event.Builder = Event.Builder()
          if hasCreatedEvent {
            try subBuilder.mergeFrom(createdEvent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          createdEvent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SearchEntitiesRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var query:String = ""

  public private(set) var hasQuery:Bool = false
  public private(set) var maxCount:UInt64 = UInt64(0)

  public private(set) var hasMaxCount:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasQuery {
      try output.writeString(3, value:query)
    }
    if hasMaxCount {
      try output.writeUInt64(4, value:maxCount)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasQuery {
      serialize_size += query.computeStringSize(3)
    }
    if hasMaxCount {
      serialize_size += maxCount.computeUInt64Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SearchEntitiesRequest> {
    var mergedArray = Array<SearchEntitiesRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SearchEntitiesRequest? {
    return try SearchEntitiesRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesRequest {
    return try SearchEntitiesRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SearchEntitiesRequest.Builder {
    return SearchEntitiesRequest.classBuilder() as! SearchEntitiesRequest.Builder
  }
  public func getBuilder() -> SearchEntitiesRequest.Builder {
    return classBuilder() as! SearchEntitiesRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SearchEntitiesRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SearchEntitiesRequest.Builder()
  }
  public func toBuilder() throws -> SearchEntitiesRequest.Builder {
    return try SearchEntitiesRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SearchEntitiesRequest) throws -> SearchEntitiesRequest.Builder {
    return try SearchEntitiesRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasQuery {
      output += "\(indent) query: \(query) \n"
    }
    if hasMaxCount {
      output += "\(indent) maxCount: \(maxCount) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasQuery {
             hashCode = (hashCode &* 31) &+ query.hashValue
          }
          if hasMaxCount {
             hashCode = (hashCode &* 31) &+ maxCount.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SearchEntitiesRequest"
  }
  override public func className() -> String {
      return "SearchEntitiesRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SearchEntitiesRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SearchEntitiesRequest = SearchEntitiesRequest()
    public func getMessage() -> SearchEntitiesRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SearchEntitiesRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SearchEntitiesRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SearchEntitiesRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasQuery:Bool {
         get {
              return builderResult.hasQuery
         }
    }
    public var query:String {
         get {
              return builderResult.query
         }
         set (value) {
             builderResult.hasQuery = true
             builderResult.query = value
         }
    }
    public func setQuery(_ value:String) -> SearchEntitiesRequest.Builder {
      self.query = value
      return self
    }
    public func clearQuery() -> SearchEntitiesRequest.Builder{
         builderResult.hasQuery = false
         builderResult.query = ""
         return self
    }
    public var hasMaxCount:Bool {
         get {
              return builderResult.hasMaxCount
         }
    }
    public var maxCount:UInt64 {
         get {
              return builderResult.maxCount
         }
         set (value) {
             builderResult.hasMaxCount = true
             builderResult.maxCount = value
         }
    }
    public func setMaxCount(_ value:UInt64) -> SearchEntitiesRequest.Builder {
      self.maxCount = value
      return self
    }
    public func clearMaxCount() -> SearchEntitiesRequest.Builder{
         builderResult.hasMaxCount = false
         builderResult.maxCount = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SearchEntitiesRequest.Builder {
      builderResult = SearchEntitiesRequest()
      return self
    }
    public override func clone() throws -> SearchEntitiesRequest.Builder {
      return try SearchEntitiesRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SearchEntitiesRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SearchEntitiesRequest {
      let returnMe:SearchEntitiesRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SearchEntitiesRequest) throws -> SearchEntitiesRequest.Builder {
      if other == SearchEntitiesRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasQuery {
           query = other.query
      }
      if other.hasMaxCount {
           maxCount = other.maxCount
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SearchEntitiesRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 26:
          query = try input.readString()

        case 32:
          maxCount = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SearchEntitiesResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var entity:Array<Entity>  = Array<Entity>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitentity:Bool = true
    for oneElemententity in entity {
        if (!oneElemententity.isInitialized()) {
            isInitentity = false
            break 
        }
    }
    if !isInitentity {
     return isInitentity
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    for oneElemententity in entity {
        try output.writeMessage(2, value:oneElemententity)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    for oneElemententity in entity {
        serialize_size += oneElemententity.computeMessageSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SearchEntitiesResponse> {
    var mergedArray = Array<SearchEntitiesResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SearchEntitiesResponse? {
    return try SearchEntitiesResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesResponse {
    return try SearchEntitiesResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SearchEntitiesResponse.Builder {
    return SearchEntitiesResponse.classBuilder() as! SearchEntitiesResponse.Builder
  }
  public func getBuilder() -> SearchEntitiesResponse.Builder {
    return classBuilder() as! SearchEntitiesResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SearchEntitiesResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SearchEntitiesResponse.Builder()
  }
  public func toBuilder() throws -> SearchEntitiesResponse.Builder {
    return try SearchEntitiesResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SearchEntitiesResponse) throws -> SearchEntitiesResponse.Builder {
    return try SearchEntitiesResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var entityElementIndex:Int = 0
    for oneElemententity in entity {
        output += "\(indent) entity[\(entityElementIndex)] {\n"
        output += try oneElemententity.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        entityElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          for oneElemententity in entity {
              hashCode = (hashCode &* 31) &+ oneElemententity.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SearchEntitiesResponse"
  }
  override public func className() -> String {
      return "SearchEntitiesResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SearchEntitiesResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SearchEntitiesResponse = SearchEntitiesResponse()
    public func getMessage() -> SearchEntitiesResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SearchEntitiesResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SearchEntitiesResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SearchEntitiesResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var entity:Array<Entity> {
         get {
             return builderResult.entity
         }
         set (value) {
             builderResult.entity = value
         }
    }
    public func setEntity(_ value:Array<Entity>) -> SearchEntitiesResponse.Builder {
      self.entity = value
      return self
    }
    public func clearEntity() -> SearchEntitiesResponse.Builder {
      builderResult.entity.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SearchEntitiesResponse.Builder {
      builderResult = SearchEntitiesResponse()
      return self
    }
    public override func clone() throws -> SearchEntitiesResponse.Builder {
      return try SearchEntitiesResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SearchEntitiesResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SearchEntitiesResponse {
      let returnMe:SearchEntitiesResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SearchEntitiesResponse) throws -> SearchEntitiesResponse.Builder {
      if other == SearchEntitiesResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if !other.entity.isEmpty  {
         builderResult.entity += other.entity
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SearchEntitiesResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchEntitiesResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder = Entity.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          entity += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SendChatMessageRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var annotation:Array<EventAnnotation>  = Array<EventAnnotation>()
  public private(set) var messageContent:MessageContent!
  public private(set) var hasMessageContent:Bool = false
  public private(set) var existingMedia:ExistingMedia!
  public private(set) var hasExistingMedia:Bool = false
  public private(set) var eventRequestHeader:EventRequestHeader!
  public private(set) var hasEventRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMessageContent {
     if !messageContent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    for oneElementannotation in annotation {
        try output.writeMessage(5, value:oneElementannotation)
    }
    if hasMessageContent {
      try output.writeMessage(6, value:messageContent)
    }
    if hasExistingMedia {
      try output.writeMessage(7, value:existingMedia)
    }
    if hasEventRequestHeader {
      try output.writeMessage(8, value:eventRequestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    for oneElementannotation in annotation {
        serialize_size += oneElementannotation.computeMessageSize(5)
    }
    if hasMessageContent {
        if let varSizemessageContent = messageContent?.computeMessageSize(6) {
            serialize_size += varSizemessageContent
        }
    }
    if hasExistingMedia {
        if let varSizeexistingMedia = existingMedia?.computeMessageSize(7) {
            serialize_size += varSizeexistingMedia
        }
    }
    if hasEventRequestHeader {
        if let varSizeeventRequestHeader = eventRequestHeader?.computeMessageSize(8) {
            serialize_size += varSizeeventRequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SendChatMessageRequest> {
    var mergedArray = Array<SendChatMessageRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SendChatMessageRequest? {
    return try SendChatMessageRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageRequest {
    return try SendChatMessageRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SendChatMessageRequest.Builder {
    return SendChatMessageRequest.classBuilder() as! SendChatMessageRequest.Builder
  }
  public func getBuilder() -> SendChatMessageRequest.Builder {
    return classBuilder() as! SendChatMessageRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SendChatMessageRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SendChatMessageRequest.Builder()
  }
  public func toBuilder() throws -> SendChatMessageRequest.Builder {
    return try SendChatMessageRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SendChatMessageRequest) throws -> SendChatMessageRequest.Builder {
    return try SendChatMessageRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var annotationElementIndex:Int = 0
    for oneElementannotation in annotation {
        output += "\(indent) annotation[\(annotationElementIndex)] {\n"
        output += try oneElementannotation.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        annotationElementIndex += 1
    }
    if hasMessageContent {
      output += "\(indent) messageContent {\n"
      if let outDescMessageContent = messageContent {
        output += try outDescMessageContent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasExistingMedia {
      output += "\(indent) existingMedia {\n"
      if let outDescExistingMedia = existingMedia {
        output += try outDescExistingMedia.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEventRequestHeader {
      output += "\(indent) eventRequestHeader {\n"
      if let outDescEventRequestHeader = eventRequestHeader {
        output += try outDescEventRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          for oneElementannotation in annotation {
              hashCode = (hashCode &* 31) &+ oneElementannotation.hashValue
          }
          if hasMessageContent {
              if let hashValuemessageContent = messageContent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemessageContent
              }
          }
          if hasExistingMedia {
              if let hashValueexistingMedia = existingMedia?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueexistingMedia
              }
          }
          if hasEventRequestHeader {
              if let hashValueeventRequestHeader = eventRequestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueeventRequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SendChatMessageRequest"
  }
  override public func className() -> String {
      return "SendChatMessageRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SendChatMessageRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SendChatMessageRequest = SendChatMessageRequest()
    public func getMessage() -> SendChatMessageRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SendChatMessageRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SendChatMessageRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SendChatMessageRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var annotation:Array<EventAnnotation> {
         get {
             return builderResult.annotation
         }
         set (value) {
             builderResult.annotation = value
         }
    }
    public func setAnnotation(_ value:Array<EventAnnotation>) -> SendChatMessageRequest.Builder {
      self.annotation = value
      return self
    }
    public func clearAnnotation() -> SendChatMessageRequest.Builder {
      builderResult.annotation.removeAll(keepingCapacity: false)
      return self
    }
    public var hasMessageContent:Bool {
         get {
             return builderResult.hasMessageContent
         }
    }
    public var messageContent:MessageContent! {
         get {
             if messageContentBuilder_ != nil {
                builderResult.messageContent = messageContentBuilder_.getMessage()
             }
             return builderResult.messageContent
         }
         set (value) {
             builderResult.hasMessageContent = true
             builderResult.messageContent = value
         }
    }
    private var messageContentBuilder_:MessageContent.Builder! {
         didSet {
            builderResult.hasMessageContent = true
         }
    }
    public func getMessageContentBuilder() -> MessageContent.Builder {
      if messageContentBuilder_ == nil {
         messageContentBuilder_ = MessageContent.Builder()
         builderResult.messageContent = messageContentBuilder_.getMessage()
         if messageContent != nil {
            try! messageContentBuilder_.mergeFrom(messageContent)
         }
      }
      return messageContentBuilder_
    }
    public func setMessageContent(_ value:MessageContent!) -> SendChatMessageRequest.Builder {
      self.messageContent = value
      return self
    }
    public func mergeMessageContent(_ value:MessageContent) throws -> SendChatMessageRequest.Builder {
      if builderResult.hasMessageContent {
        builderResult.messageContent = try MessageContent.builderWithPrototype(builderResult.messageContent).mergeFrom(value).buildPartial()
      } else {
        builderResult.messageContent = value
      }
      builderResult.hasMessageContent = true
      return self
    }
    public func clearMessageContent() -> SendChatMessageRequest.Builder {
      messageContentBuilder_ = nil
      builderResult.hasMessageContent = false
      builderResult.messageContent = nil
      return self
    }
    public var hasExistingMedia:Bool {
         get {
             return builderResult.hasExistingMedia
         }
    }
    public var existingMedia:ExistingMedia! {
         get {
             if existingMediaBuilder_ != nil {
                builderResult.existingMedia = existingMediaBuilder_.getMessage()
             }
             return builderResult.existingMedia
         }
         set (value) {
             builderResult.hasExistingMedia = true
             builderResult.existingMedia = value
         }
    }
    private var existingMediaBuilder_:ExistingMedia.Builder! {
         didSet {
            builderResult.hasExistingMedia = true
         }
    }
    public func getExistingMediaBuilder() -> ExistingMedia.Builder {
      if existingMediaBuilder_ == nil {
         existingMediaBuilder_ = ExistingMedia.Builder()
         builderResult.existingMedia = existingMediaBuilder_.getMessage()
         if existingMedia != nil {
            try! existingMediaBuilder_.mergeFrom(existingMedia)
         }
      }
      return existingMediaBuilder_
    }
    public func setExistingMedia(_ value:ExistingMedia!) -> SendChatMessageRequest.Builder {
      self.existingMedia = value
      return self
    }
    public func mergeExistingMedia(_ value:ExistingMedia) throws -> SendChatMessageRequest.Builder {
      if builderResult.hasExistingMedia {
        builderResult.existingMedia = try ExistingMedia.builderWithPrototype(builderResult.existingMedia).mergeFrom(value).buildPartial()
      } else {
        builderResult.existingMedia = value
      }
      builderResult.hasExistingMedia = true
      return self
    }
    public func clearExistingMedia() -> SendChatMessageRequest.Builder {
      existingMediaBuilder_ = nil
      builderResult.hasExistingMedia = false
      builderResult.existingMedia = nil
      return self
    }
    public var hasEventRequestHeader:Bool {
         get {
             return builderResult.hasEventRequestHeader
         }
    }
    public var eventRequestHeader:EventRequestHeader! {
         get {
             if eventRequestHeaderBuilder_ != nil {
                builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
             }
             return builderResult.eventRequestHeader
         }
         set (value) {
             builderResult.hasEventRequestHeader = true
             builderResult.eventRequestHeader = value
         }
    }
    private var eventRequestHeaderBuilder_:EventRequestHeader.Builder! {
         didSet {
            builderResult.hasEventRequestHeader = true
         }
    }
    public func getEventRequestHeaderBuilder() -> EventRequestHeader.Builder {
      if eventRequestHeaderBuilder_ == nil {
         eventRequestHeaderBuilder_ = EventRequestHeader.Builder()
         builderResult.eventRequestHeader = eventRequestHeaderBuilder_.getMessage()
         if eventRequestHeader != nil {
            try! eventRequestHeaderBuilder_.mergeFrom(eventRequestHeader)
         }
      }
      return eventRequestHeaderBuilder_
    }
    public func setEventRequestHeader(_ value:EventRequestHeader!) -> SendChatMessageRequest.Builder {
      self.eventRequestHeader = value
      return self
    }
    public func mergeEventRequestHeader(_ value:EventRequestHeader) throws -> SendChatMessageRequest.Builder {
      if builderResult.hasEventRequestHeader {
        builderResult.eventRequestHeader = try EventRequestHeader.builderWithPrototype(builderResult.eventRequestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.eventRequestHeader = value
      }
      builderResult.hasEventRequestHeader = true
      return self
    }
    public func clearEventRequestHeader() -> SendChatMessageRequest.Builder {
      eventRequestHeaderBuilder_ = nil
      builderResult.hasEventRequestHeader = false
      builderResult.eventRequestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SendChatMessageRequest.Builder {
      builderResult = SendChatMessageRequest()
      return self
    }
    public override func clone() throws -> SendChatMessageRequest.Builder {
      return try SendChatMessageRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SendChatMessageRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SendChatMessageRequest {
      let returnMe:SendChatMessageRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SendChatMessageRequest) throws -> SendChatMessageRequest.Builder {
      if other == SendChatMessageRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if !other.annotation.isEmpty  {
         builderResult.annotation += other.annotation
      }
      if (other.hasMessageContent) {
          try mergeMessageContent(other.messageContent)
      }
      if (other.hasExistingMedia) {
          try mergeExistingMedia(other.existingMedia)
      }
      if (other.hasEventRequestHeader) {
          try mergeEventRequestHeader(other.eventRequestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SendChatMessageRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 42:
          let subBuilder = EventAnnotation.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          annotation += [subBuilder.buildPartial()]

        case 50:
          let subBuilder:MessageContent.Builder = MessageContent.Builder()
          if hasMessageContent {
            try subBuilder.mergeFrom(messageContent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          messageContent = subBuilder.buildPartial()

        case 58:
          let subBuilder:ExistingMedia.Builder = ExistingMedia.Builder()
          if hasExistingMedia {
            try subBuilder.mergeFrom(existingMedia)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          existingMedia = subBuilder.buildPartial()

        case 66:
          let subBuilder:EventRequestHeader.Builder = EventRequestHeader.Builder()
          if hasEventRequestHeader {
            try subBuilder.mergeFrom(eventRequestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          eventRequestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SendChatMessageResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var createdEvent:Event!
  public private(set) var hasCreatedEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasCreatedEvent {
     if !createdEvent.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasCreatedEvent {
      try output.writeMessage(6, value:createdEvent)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasCreatedEvent {
        if let varSizecreatedEvent = createdEvent?.computeMessageSize(6) {
            serialize_size += varSizecreatedEvent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SendChatMessageResponse> {
    var mergedArray = Array<SendChatMessageResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SendChatMessageResponse? {
    return try SendChatMessageResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageResponse {
    return try SendChatMessageResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SendChatMessageResponse.Builder {
    return SendChatMessageResponse.classBuilder() as! SendChatMessageResponse.Builder
  }
  public func getBuilder() -> SendChatMessageResponse.Builder {
    return classBuilder() as! SendChatMessageResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SendChatMessageResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SendChatMessageResponse.Builder()
  }
  public func toBuilder() throws -> SendChatMessageResponse.Builder {
    return try SendChatMessageResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SendChatMessageResponse) throws -> SendChatMessageResponse.Builder {
    return try SendChatMessageResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCreatedEvent {
      output += "\(indent) createdEvent {\n"
      if let outDescCreatedEvent = createdEvent {
        output += try outDescCreatedEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasCreatedEvent {
              if let hashValuecreatedEvent = createdEvent?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecreatedEvent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SendChatMessageResponse"
  }
  override public func className() -> String {
      return "SendChatMessageResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SendChatMessageResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SendChatMessageResponse = SendChatMessageResponse()
    public func getMessage() -> SendChatMessageResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SendChatMessageResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SendChatMessageResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SendChatMessageResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasCreatedEvent:Bool {
         get {
             return builderResult.hasCreatedEvent
         }
    }
    public var createdEvent:Event! {
         get {
             if createdEventBuilder_ != nil {
                builderResult.createdEvent = createdEventBuilder_.getMessage()
             }
             return builderResult.createdEvent
         }
         set (value) {
             builderResult.hasCreatedEvent = true
             builderResult.createdEvent = value
         }
    }
    private var createdEventBuilder_:Event.Builder! {
         didSet {
            builderResult.hasCreatedEvent = true
         }
    }
    public func getCreatedEventBuilder() -> Event.Builder {
      if createdEventBuilder_ == nil {
         createdEventBuilder_ = Event.Builder()
         builderResult.createdEvent = createdEventBuilder_.getMessage()
         if createdEvent != nil {
            try! createdEventBuilder_.mergeFrom(createdEvent)
         }
      }
      return createdEventBuilder_
    }
    public func setCreatedEvent(_ value:Event!) -> SendChatMessageResponse.Builder {
      self.createdEvent = value
      return self
    }
    public func mergeCreatedEvent(_ value:Event) throws -> SendChatMessageResponse.Builder {
      if builderResult.hasCreatedEvent {
        builderResult.createdEvent = try Event.builderWithPrototype(builderResult.createdEvent).mergeFrom(value).buildPartial()
      } else {
        builderResult.createdEvent = value
      }
      builderResult.hasCreatedEvent = true
      return self
    }
    public func clearCreatedEvent() -> SendChatMessageResponse.Builder {
      createdEventBuilder_ = nil
      builderResult.hasCreatedEvent = false
      builderResult.createdEvent = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SendChatMessageResponse.Builder {
      builderResult = SendChatMessageResponse()
      return self
    }
    public override func clone() throws -> SendChatMessageResponse.Builder {
      return try SendChatMessageResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SendChatMessageResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SendChatMessageResponse {
      let returnMe:SendChatMessageResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SendChatMessageResponse) throws -> SendChatMessageResponse.Builder {
      if other == SendChatMessageResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if (other.hasCreatedEvent) {
          try mergeCreatedEvent(other.createdEvent)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SendChatMessageResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendChatMessageResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 50:
          let subBuilder:Event.Builder = Event.Builder()
          if hasCreatedEvent {
            try subBuilder.mergeFrom(createdEvent)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          createdEvent = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SendOffnetworkInvitationRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var inviteeAddress:OffnetworkAddress!
  public private(set) var hasInviteeAddress:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasInviteeAddress {
      try output.writeMessage(2, value:inviteeAddress)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasInviteeAddress {
        if let varSizeinviteeAddress = inviteeAddress?.computeMessageSize(2) {
            serialize_size += varSizeinviteeAddress
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SendOffnetworkInvitationRequest> {
    var mergedArray = Array<SendOffnetworkInvitationRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SendOffnetworkInvitationRequest? {
    return try SendOffnetworkInvitationRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationRequest {
    return try SendOffnetworkInvitationRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SendOffnetworkInvitationRequest.Builder {
    return SendOffnetworkInvitationRequest.classBuilder() as! SendOffnetworkInvitationRequest.Builder
  }
  public func getBuilder() -> SendOffnetworkInvitationRequest.Builder {
    return classBuilder() as! SendOffnetworkInvitationRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SendOffnetworkInvitationRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SendOffnetworkInvitationRequest.Builder()
  }
  public func toBuilder() throws -> SendOffnetworkInvitationRequest.Builder {
    return try SendOffnetworkInvitationRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SendOffnetworkInvitationRequest) throws -> SendOffnetworkInvitationRequest.Builder {
    return try SendOffnetworkInvitationRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasInviteeAddress {
      output += "\(indent) inviteeAddress {\n"
      if let outDescInviteeAddress = inviteeAddress {
        output += try outDescInviteeAddress.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasInviteeAddress {
              if let hashValueinviteeAddress = inviteeAddress?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueinviteeAddress
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SendOffnetworkInvitationRequest"
  }
  override public func className() -> String {
      return "SendOffnetworkInvitationRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SendOffnetworkInvitationRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SendOffnetworkInvitationRequest = SendOffnetworkInvitationRequest()
    public func getMessage() -> SendOffnetworkInvitationRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SendOffnetworkInvitationRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SendOffnetworkInvitationRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SendOffnetworkInvitationRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasInviteeAddress:Bool {
         get {
             return builderResult.hasInviteeAddress
         }
    }
    public var inviteeAddress:OffnetworkAddress! {
         get {
             if inviteeAddressBuilder_ != nil {
                builderResult.inviteeAddress = inviteeAddressBuilder_.getMessage()
             }
             return builderResult.inviteeAddress
         }
         set (value) {
             builderResult.hasInviteeAddress = true
             builderResult.inviteeAddress = value
         }
    }
    private var inviteeAddressBuilder_:OffnetworkAddress.Builder! {
         didSet {
            builderResult.hasInviteeAddress = true
         }
    }
    public func getInviteeAddressBuilder() -> OffnetworkAddress.Builder {
      if inviteeAddressBuilder_ == nil {
         inviteeAddressBuilder_ = OffnetworkAddress.Builder()
         builderResult.inviteeAddress = inviteeAddressBuilder_.getMessage()
         if inviteeAddress != nil {
            try! inviteeAddressBuilder_.mergeFrom(inviteeAddress)
         }
      }
      return inviteeAddressBuilder_
    }
    public func setInviteeAddress(_ value:OffnetworkAddress!) -> SendOffnetworkInvitationRequest.Builder {
      self.inviteeAddress = value
      return self
    }
    public func mergeInviteeAddress(_ value:OffnetworkAddress) throws -> SendOffnetworkInvitationRequest.Builder {
      if builderResult.hasInviteeAddress {
        builderResult.inviteeAddress = try OffnetworkAddress.builderWithPrototype(builderResult.inviteeAddress).mergeFrom(value).buildPartial()
      } else {
        builderResult.inviteeAddress = value
      }
      builderResult.hasInviteeAddress = true
      return self
    }
    public func clearInviteeAddress() -> SendOffnetworkInvitationRequest.Builder {
      inviteeAddressBuilder_ = nil
      builderResult.hasInviteeAddress = false
      builderResult.inviteeAddress = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SendOffnetworkInvitationRequest.Builder {
      builderResult = SendOffnetworkInvitationRequest()
      return self
    }
    public override func clone() throws -> SendOffnetworkInvitationRequest.Builder {
      return try SendOffnetworkInvitationRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SendOffnetworkInvitationRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SendOffnetworkInvitationRequest {
      let returnMe:SendOffnetworkInvitationRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SendOffnetworkInvitationRequest) throws -> SendOffnetworkInvitationRequest.Builder {
      if other == SendOffnetworkInvitationRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasInviteeAddress) {
          try mergeInviteeAddress(other.inviteeAddress)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SendOffnetworkInvitationRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:OffnetworkAddress.Builder = OffnetworkAddress.Builder()
          if hasInviteeAddress {
            try subBuilder.mergeFrom(inviteeAddress)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          inviteeAddress = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SendOffnetworkInvitationResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SendOffnetworkInvitationResponse> {
    var mergedArray = Array<SendOffnetworkInvitationResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SendOffnetworkInvitationResponse? {
    return try SendOffnetworkInvitationResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationResponse {
    return try SendOffnetworkInvitationResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SendOffnetworkInvitationResponse.Builder {
    return SendOffnetworkInvitationResponse.classBuilder() as! SendOffnetworkInvitationResponse.Builder
  }
  public func getBuilder() -> SendOffnetworkInvitationResponse.Builder {
    return classBuilder() as! SendOffnetworkInvitationResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SendOffnetworkInvitationResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SendOffnetworkInvitationResponse.Builder()
  }
  public func toBuilder() throws -> SendOffnetworkInvitationResponse.Builder {
    return try SendOffnetworkInvitationResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SendOffnetworkInvitationResponse) throws -> SendOffnetworkInvitationResponse.Builder {
    return try SendOffnetworkInvitationResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SendOffnetworkInvitationResponse"
  }
  override public func className() -> String {
      return "SendOffnetworkInvitationResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SendOffnetworkInvitationResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SendOffnetworkInvitationResponse = SendOffnetworkInvitationResponse()
    public func getMessage() -> SendOffnetworkInvitationResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SendOffnetworkInvitationResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SendOffnetworkInvitationResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SendOffnetworkInvitationResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SendOffnetworkInvitationResponse.Builder {
      builderResult = SendOffnetworkInvitationResponse()
      return self
    }
    public override func clone() throws -> SendOffnetworkInvitationResponse.Builder {
      return try SendOffnetworkInvitationResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SendOffnetworkInvitationResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SendOffnetworkInvitationResponse {
      let returnMe:SendOffnetworkInvitationResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SendOffnetworkInvitationResponse) throws -> SendOffnetworkInvitationResponse.Builder {
      if other == SendOffnetworkInvitationResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SendOffnetworkInvitationResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendOffnetworkInvitationResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetActiveClientRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  // Whether to set the client as active or inactive.
  public private(set) var isActive:Bool = false

  public private(set) var hasIsActive:Bool = false
  // 'email/resource'.
  public private(set) var fullJid:String = ""

  public private(set) var hasFullJid:Bool = false
  // Timeout in seconds for client to remain active.
  public private(set) var timeoutSecs:UInt64 = UInt64(0)

  public private(set) var hasTimeoutSecs:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasIsActive {
      try output.writeBool(2, value:isActive)
    }
    if hasFullJid {
      try output.writeString(3, value:fullJid)
    }
    if hasTimeoutSecs {
      try output.writeUInt64(4, value:timeoutSecs)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasIsActive {
      serialize_size += isActive.computeBoolSize(2)
    }
    if hasFullJid {
      serialize_size += fullJid.computeStringSize(3)
    }
    if hasTimeoutSecs {
      serialize_size += timeoutSecs.computeUInt64Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetActiveClientRequest> {
    var mergedArray = Array<SetActiveClientRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetActiveClientRequest? {
    return try SetActiveClientRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientRequest {
    return try SetActiveClientRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetActiveClientRequest.Builder {
    return SetActiveClientRequest.classBuilder() as! SetActiveClientRequest.Builder
  }
  public func getBuilder() -> SetActiveClientRequest.Builder {
    return classBuilder() as! SetActiveClientRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetActiveClientRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetActiveClientRequest.Builder()
  }
  public func toBuilder() throws -> SetActiveClientRequest.Builder {
    return try SetActiveClientRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetActiveClientRequest) throws -> SetActiveClientRequest.Builder {
    return try SetActiveClientRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasIsActive {
      output += "\(indent) isActive: \(isActive) \n"
    }
    if hasFullJid {
      output += "\(indent) fullJid: \(fullJid) \n"
    }
    if hasTimeoutSecs {
      output += "\(indent) timeoutSecs: \(timeoutSecs) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasIsActive {
             hashCode = (hashCode &* 31) &+ isActive.hashValue
          }
          if hasFullJid {
             hashCode = (hashCode &* 31) &+ fullJid.hashValue
          }
          if hasTimeoutSecs {
             hashCode = (hashCode &* 31) &+ timeoutSecs.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetActiveClientRequest"
  }
  override public func className() -> String {
      return "SetActiveClientRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetActiveClientRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetActiveClientRequest = SetActiveClientRequest()
    public func getMessage() -> SetActiveClientRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetActiveClientRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetActiveClientRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetActiveClientRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasIsActive:Bool {
         get {
              return builderResult.hasIsActive
         }
    }
    public var isActive:Bool {
         get {
              return builderResult.isActive
         }
         set (value) {
             builderResult.hasIsActive = true
             builderResult.isActive = value
         }
    }
    public func setIsActive(_ value:Bool) -> SetActiveClientRequest.Builder {
      self.isActive = value
      return self
    }
    public func clearIsActive() -> SetActiveClientRequest.Builder{
         builderResult.hasIsActive = false
         builderResult.isActive = false
         return self
    }
    public var hasFullJid:Bool {
         get {
              return builderResult.hasFullJid
         }
    }
    public var fullJid:String {
         get {
              return builderResult.fullJid
         }
         set (value) {
             builderResult.hasFullJid = true
             builderResult.fullJid = value
         }
    }
    public func setFullJid(_ value:String) -> SetActiveClientRequest.Builder {
      self.fullJid = value
      return self
    }
    public func clearFullJid() -> SetActiveClientRequest.Builder{
         builderResult.hasFullJid = false
         builderResult.fullJid = ""
         return self
    }
    public var hasTimeoutSecs:Bool {
         get {
              return builderResult.hasTimeoutSecs
         }
    }
    public var timeoutSecs:UInt64 {
         get {
              return builderResult.timeoutSecs
         }
         set (value) {
             builderResult.hasTimeoutSecs = true
             builderResult.timeoutSecs = value
         }
    }
    public func setTimeoutSecs(_ value:UInt64) -> SetActiveClientRequest.Builder {
      self.timeoutSecs = value
      return self
    }
    public func clearTimeoutSecs() -> SetActiveClientRequest.Builder{
         builderResult.hasTimeoutSecs = false
         builderResult.timeoutSecs = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetActiveClientRequest.Builder {
      builderResult = SetActiveClientRequest()
      return self
    }
    public override func clone() throws -> SetActiveClientRequest.Builder {
      return try SetActiveClientRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetActiveClientRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetActiveClientRequest {
      let returnMe:SetActiveClientRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetActiveClientRequest) throws -> SetActiveClientRequest.Builder {
      if other == SetActiveClientRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasIsActive {
           isActive = other.isActive
      }
      if other.hasFullJid {
           fullJid = other.fullJid
      }
      if other.hasTimeoutSecs {
           timeoutSecs = other.timeoutSecs
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetActiveClientRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 16:
          isActive = try input.readBool()

        case 26:
          fullJid = try input.readString()

        case 32:
          timeoutSecs = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetActiveClientResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetActiveClientResponse> {
    var mergedArray = Array<SetActiveClientResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetActiveClientResponse? {
    return try SetActiveClientResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientResponse {
    return try SetActiveClientResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetActiveClientResponse.Builder {
    return SetActiveClientResponse.classBuilder() as! SetActiveClientResponse.Builder
  }
  public func getBuilder() -> SetActiveClientResponse.Builder {
    return classBuilder() as! SetActiveClientResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetActiveClientResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetActiveClientResponse.Builder()
  }
  public func toBuilder() throws -> SetActiveClientResponse.Builder {
    return try SetActiveClientResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetActiveClientResponse) throws -> SetActiveClientResponse.Builder {
    return try SetActiveClientResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetActiveClientResponse"
  }
  override public func className() -> String {
      return "SetActiveClientResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetActiveClientResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetActiveClientResponse = SetActiveClientResponse()
    public func getMessage() -> SetActiveClientResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetActiveClientResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetActiveClientResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetActiveClientResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetActiveClientResponse.Builder {
      builderResult = SetActiveClientResponse()
      return self
    }
    public override func clone() throws -> SetActiveClientResponse.Builder {
      return try SetActiveClientResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetActiveClientResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetActiveClientResponse {
      let returnMe:SetActiveClientResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetActiveClientResponse) throws -> SetActiveClientResponse.Builder {
      if other == SetActiveClientResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetActiveClientResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetActiveClientResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetConversationLevelRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetConversationLevelRequest> {
    var mergedArray = Array<SetConversationLevelRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetConversationLevelRequest? {
    return try SetConversationLevelRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelRequest {
    return try SetConversationLevelRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetConversationLevelRequest.Builder {
    return SetConversationLevelRequest.classBuilder() as! SetConversationLevelRequest.Builder
  }
  public func getBuilder() -> SetConversationLevelRequest.Builder {
    return classBuilder() as! SetConversationLevelRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetConversationLevelRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetConversationLevelRequest.Builder()
  }
  public func toBuilder() throws -> SetConversationLevelRequest.Builder {
    return try SetConversationLevelRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetConversationLevelRequest) throws -> SetConversationLevelRequest.Builder {
    return try SetConversationLevelRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetConversationLevelRequest"
  }
  override public func className() -> String {
      return "SetConversationLevelRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetConversationLevelRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetConversationLevelRequest = SetConversationLevelRequest()
    public func getMessage() -> SetConversationLevelRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetConversationLevelRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetConversationLevelRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetConversationLevelRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetConversationLevelRequest.Builder {
      builderResult = SetConversationLevelRequest()
      return self
    }
    public override func clone() throws -> SetConversationLevelRequest.Builder {
      return try SetConversationLevelRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetConversationLevelRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetConversationLevelRequest {
      let returnMe:SetConversationLevelRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetConversationLevelRequest) throws -> SetConversationLevelRequest.Builder {
      if other == SetConversationLevelRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationLevelRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetConversationLevelResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetConversationLevelResponse> {
    var mergedArray = Array<SetConversationLevelResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetConversationLevelResponse? {
    return try SetConversationLevelResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelResponse {
    return try SetConversationLevelResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetConversationLevelResponse.Builder {
    return SetConversationLevelResponse.classBuilder() as! SetConversationLevelResponse.Builder
  }
  public func getBuilder() -> SetConversationLevelResponse.Builder {
    return classBuilder() as! SetConversationLevelResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetConversationLevelResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetConversationLevelResponse.Builder()
  }
  public func toBuilder() throws -> SetConversationLevelResponse.Builder {
    return try SetConversationLevelResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetConversationLevelResponse) throws -> SetConversationLevelResponse.Builder {
    return try SetConversationLevelResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetConversationLevelResponse"
  }
  override public func className() -> String {
      return "SetConversationLevelResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetConversationLevelResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetConversationLevelResponse = SetConversationLevelResponse()
    public func getMessage() -> SetConversationLevelResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetConversationLevelResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetConversationLevelResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetConversationLevelResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetConversationLevelResponse.Builder {
      builderResult = SetConversationLevelResponse()
      return self
    }
    public override func clone() throws -> SetConversationLevelResponse.Builder {
      return try SetConversationLevelResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetConversationLevelResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetConversationLevelResponse {
      let returnMe:SetConversationLevelResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetConversationLevelResponse) throws -> SetConversationLevelResponse.Builder {
      if other == SetConversationLevelResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationLevelResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationLevelResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetConversationNotificationLevelRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var level:NotificationLevel = NotificationLevel.NotificationLevelUnknown
  public private(set) var hasLevel:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasLevel {
      try output.writeEnum(3, value:level.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasLevel) {
      serialize_size += level.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetConversationNotificationLevelRequest> {
    var mergedArray = Array<SetConversationNotificationLevelRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelRequest? {
    return try SetConversationNotificationLevelRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelRequest {
    return try SetConversationNotificationLevelRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetConversationNotificationLevelRequest.Builder {
    return SetConversationNotificationLevelRequest.classBuilder() as! SetConversationNotificationLevelRequest.Builder
  }
  public func getBuilder() -> SetConversationNotificationLevelRequest.Builder {
    return classBuilder() as! SetConversationNotificationLevelRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelRequest.Builder()
  }
  public func toBuilder() throws -> SetConversationNotificationLevelRequest.Builder {
    return try SetConversationNotificationLevelRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetConversationNotificationLevelRequest) throws -> SetConversationNotificationLevelRequest.Builder {
    return try SetConversationNotificationLevelRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasLevel) {
      output += "\(indent) level: \(level.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasLevel {
             hashCode = (hashCode &* 31) &+ Int(level.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetConversationNotificationLevelRequest"
  }
  override public func className() -> String {
      return "SetConversationNotificationLevelRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetConversationNotificationLevelRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetConversationNotificationLevelRequest = SetConversationNotificationLevelRequest()
    public func getMessage() -> SetConversationNotificationLevelRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetConversationNotificationLevelRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetConversationNotificationLevelRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetConversationNotificationLevelRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetConversationNotificationLevelRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetConversationNotificationLevelRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetConversationNotificationLevelRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasLevel:Bool{
          get {
              return builderResult.hasLevel
          }
      }
      public var level:NotificationLevel {
          get {
              return builderResult.level
          }
          set (value) {
              builderResult.hasLevel = true
              builderResult.level = value
          }
      }
      public func setLevel(_ value:NotificationLevel) -> SetConversationNotificationLevelRequest.Builder {
        self.level = value
        return self
      }
      public func clearLevel() -> SetConversationNotificationLevelRequest.Builder {
         builderResult.hasLevel = false
         builderResult.level = .NotificationLevelUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetConversationNotificationLevelRequest.Builder {
      builderResult = SetConversationNotificationLevelRequest()
      return self
    }
    public override func clone() throws -> SetConversationNotificationLevelRequest.Builder {
      return try SetConversationNotificationLevelRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetConversationNotificationLevelRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetConversationNotificationLevelRequest {
      let returnMe:SetConversationNotificationLevelRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetConversationNotificationLevelRequest) throws -> SetConversationNotificationLevelRequest.Builder {
      if other == SetConversationNotificationLevelRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasLevel {
           level = other.level
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          let valueIntlevel = try input.readEnum()
          if let enumslevel = NotificationLevel(rawValue:valueIntlevel){
               level = enumslevel
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntlevel))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetConversationNotificationLevelResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasTimestamp {
      try output.writeUInt64(2, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetConversationNotificationLevelResponse> {
    var mergedArray = Array<SetConversationNotificationLevelResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelResponse? {
    return try SetConversationNotificationLevelResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelResponse {
    return try SetConversationNotificationLevelResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetConversationNotificationLevelResponse.Builder {
    return SetConversationNotificationLevelResponse.classBuilder() as! SetConversationNotificationLevelResponse.Builder
  }
  public func getBuilder() -> SetConversationNotificationLevelResponse.Builder {
    return classBuilder() as! SetConversationNotificationLevelResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetConversationNotificationLevelResponse.Builder()
  }
  public func toBuilder() throws -> SetConversationNotificationLevelResponse.Builder {
    return try SetConversationNotificationLevelResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetConversationNotificationLevelResponse) throws -> SetConversationNotificationLevelResponse.Builder {
    return try SetConversationNotificationLevelResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetConversationNotificationLevelResponse"
  }
  override public func className() -> String {
      return "SetConversationNotificationLevelResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetConversationNotificationLevelResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetConversationNotificationLevelResponse = SetConversationNotificationLevelResponse()
    public func getMessage() -> SetConversationNotificationLevelResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetConversationNotificationLevelResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetConversationNotificationLevelResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetConversationNotificationLevelResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetConversationNotificationLevelResponse.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetConversationNotificationLevelResponse.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetConversationNotificationLevelResponse.Builder {
      builderResult = SetConversationNotificationLevelResponse()
      return self
    }
    public override func clone() throws -> SetConversationNotificationLevelResponse.Builder {
      return try SetConversationNotificationLevelResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetConversationNotificationLevelResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetConversationNotificationLevelResponse {
      let returnMe:SetConversationNotificationLevelResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetConversationNotificationLevelResponse) throws -> SetConversationNotificationLevelResponse.Builder {
      if other == SetConversationNotificationLevelResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetConversationNotificationLevelResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetConversationNotificationLevelResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          timestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetFocusRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var types:FocusType = FocusType.FocusTypeUnknown
  public private(set) var hasTypes:Bool = false
  public private(set) var timeoutSecs:UInt32 = UInt32(0)

  public private(set) var hasTimeoutSecs:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasTypes {
      try output.writeEnum(3, value:types.rawValue)
    }
    if hasTimeoutSecs {
      try output.writeUInt32(4, value:timeoutSecs)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(3)
    }
    if hasTimeoutSecs {
      serialize_size += timeoutSecs.computeUInt32Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetFocusRequest> {
    var mergedArray = Array<SetFocusRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetFocusRequest? {
    return try SetFocusRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusRequest {
    return try SetFocusRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetFocusRequest.Builder {
    return SetFocusRequest.classBuilder() as! SetFocusRequest.Builder
  }
  public func getBuilder() -> SetFocusRequest.Builder {
    return classBuilder() as! SetFocusRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetFocusRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetFocusRequest.Builder()
  }
  public func toBuilder() throws -> SetFocusRequest.Builder {
    return try SetFocusRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetFocusRequest) throws -> SetFocusRequest.Builder {
    return try SetFocusRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasTimeoutSecs {
      output += "\(indent) timeoutSecs: \(timeoutSecs) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasTimeoutSecs {
             hashCode = (hashCode &* 31) &+ timeoutSecs.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetFocusRequest"
  }
  override public func className() -> String {
      return "SetFocusRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetFocusRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetFocusRequest = SetFocusRequest()
    public func getMessage() -> SetFocusRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetFocusRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetFocusRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetFocusRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetFocusRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetFocusRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetFocusRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:FocusType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:FocusType) -> SetFocusRequest.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> SetFocusRequest.Builder {
         builderResult.hasTypes = false
         builderResult.types = .FocusTypeUnknown
         return self
      }
    public var hasTimeoutSecs:Bool {
         get {
              return builderResult.hasTimeoutSecs
         }
    }
    public var timeoutSecs:UInt32 {
         get {
              return builderResult.timeoutSecs
         }
         set (value) {
             builderResult.hasTimeoutSecs = true
             builderResult.timeoutSecs = value
         }
    }
    public func setTimeoutSecs(_ value:UInt32) -> SetFocusRequest.Builder {
      self.timeoutSecs = value
      return self
    }
    public func clearTimeoutSecs() -> SetFocusRequest.Builder{
         builderResult.hasTimeoutSecs = false
         builderResult.timeoutSecs = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetFocusRequest.Builder {
      builderResult = SetFocusRequest()
      return self
    }
    public override func clone() throws -> SetFocusRequest.Builder {
      return try SetFocusRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetFocusRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetFocusRequest {
      let returnMe:SetFocusRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetFocusRequest) throws -> SetFocusRequest.Builder {
      if other == SetFocusRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasTimeoutSecs {
           timeoutSecs = other.timeoutSecs
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          let valueInttypes = try input.readEnum()
          if let enumstypes = FocusType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueInttypes))
          }

        case 32:
          timeoutSecs = try input.readUInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetFocusResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasTimestamp {
      try output.writeUInt64(2, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetFocusResponse> {
    var mergedArray = Array<SetFocusResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetFocusResponse? {
    return try SetFocusResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusResponse {
    return try SetFocusResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetFocusResponse.Builder {
    return SetFocusResponse.classBuilder() as! SetFocusResponse.Builder
  }
  public func getBuilder() -> SetFocusResponse.Builder {
    return classBuilder() as! SetFocusResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetFocusResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetFocusResponse.Builder()
  }
  public func toBuilder() throws -> SetFocusResponse.Builder {
    return try SetFocusResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetFocusResponse) throws -> SetFocusResponse.Builder {
    return try SetFocusResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetFocusResponse"
  }
  override public func className() -> String {
      return "SetFocusResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetFocusResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetFocusResponse = SetFocusResponse()
    public func getMessage() -> SetFocusResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetFocusResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetFocusResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetFocusResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetFocusResponse.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetFocusResponse.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetFocusResponse.Builder {
      builderResult = SetFocusResponse()
      return self
    }
    public override func clone() throws -> SetFocusResponse.Builder {
      return try SetFocusResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetFocusResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetFocusResponse {
      let returnMe:SetFocusResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetFocusResponse) throws -> SetFocusResponse.Builder {
      if other == SetFocusResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetFocusResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetFocusResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          timestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// Allows setting one or more of the included presence-related settings.
final public class SetPresenceRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var presenceStateSetting:PresenceStateSetting!
  public private(set) var hasPresenceStateSetting:Bool = false
  public private(set) var dndSetting:DndSetting!
  public private(set) var hasDndSetting:Bool = false
  public private(set) var desktopOffSetting:DesktopOffSetting!
  public private(set) var hasDesktopOffSetting:Bool = false
  public private(set) var moodSetting:MoodSetting!
  public private(set) var hasMoodSetting:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasMoodSetting {
     if !moodSetting.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasPresenceStateSetting {
      try output.writeMessage(2, value:presenceStateSetting)
    }
    if hasDndSetting {
      try output.writeMessage(3, value:dndSetting)
    }
    if hasDesktopOffSetting {
      try output.writeMessage(5, value:desktopOffSetting)
    }
    if hasMoodSetting {
      try output.writeMessage(8, value:moodSetting)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasPresenceStateSetting {
        if let varSizepresenceStateSetting = presenceStateSetting?.computeMessageSize(2) {
            serialize_size += varSizepresenceStateSetting
        }
    }
    if hasDndSetting {
        if let varSizedndSetting = dndSetting?.computeMessageSize(3) {
            serialize_size += varSizedndSetting
        }
    }
    if hasDesktopOffSetting {
        if let varSizedesktopOffSetting = desktopOffSetting?.computeMessageSize(5) {
            serialize_size += varSizedesktopOffSetting
        }
    }
    if hasMoodSetting {
        if let varSizemoodSetting = moodSetting?.computeMessageSize(8) {
            serialize_size += varSizemoodSetting
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetPresenceRequest> {
    var mergedArray = Array<SetPresenceRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetPresenceRequest? {
    return try SetPresenceRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceRequest {
    return try SetPresenceRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetPresenceRequest.Builder {
    return SetPresenceRequest.classBuilder() as! SetPresenceRequest.Builder
  }
  public func getBuilder() -> SetPresenceRequest.Builder {
    return classBuilder() as! SetPresenceRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetPresenceRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetPresenceRequest.Builder()
  }
  public func toBuilder() throws -> SetPresenceRequest.Builder {
    return try SetPresenceRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetPresenceRequest) throws -> SetPresenceRequest.Builder {
    return try SetPresenceRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPresenceStateSetting {
      output += "\(indent) presenceStateSetting {\n"
      if let outDescPresenceStateSetting = presenceStateSetting {
        output += try outDescPresenceStateSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDndSetting {
      output += "\(indent) dndSetting {\n"
      if let outDescDndSetting = dndSetting {
        output += try outDescDndSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDesktopOffSetting {
      output += "\(indent) desktopOffSetting {\n"
      if let outDescDesktopOffSetting = desktopOffSetting {
        output += try outDescDesktopOffSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMoodSetting {
      output += "\(indent) moodSetting {\n"
      if let outDescMoodSetting = moodSetting {
        output += try outDescMoodSetting.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasPresenceStateSetting {
              if let hashValuepresenceStateSetting = presenceStateSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepresenceStateSetting
              }
          }
          if hasDndSetting {
              if let hashValuedndSetting = dndSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedndSetting
              }
          }
          if hasDesktopOffSetting {
              if let hashValuedesktopOffSetting = desktopOffSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedesktopOffSetting
              }
          }
          if hasMoodSetting {
              if let hashValuemoodSetting = moodSetting?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemoodSetting
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetPresenceRequest"
  }
  override public func className() -> String {
      return "SetPresenceRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetPresenceRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetPresenceRequest = SetPresenceRequest()
    public func getMessage() -> SetPresenceRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetPresenceRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetPresenceRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetPresenceRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasPresenceStateSetting:Bool {
         get {
             return builderResult.hasPresenceStateSetting
         }
    }
    public var presenceStateSetting:PresenceStateSetting! {
         get {
             if presenceStateSettingBuilder_ != nil {
                builderResult.presenceStateSetting = presenceStateSettingBuilder_.getMessage()
             }
             return builderResult.presenceStateSetting
         }
         set (value) {
             builderResult.hasPresenceStateSetting = true
             builderResult.presenceStateSetting = value
         }
    }
    private var presenceStateSettingBuilder_:PresenceStateSetting.Builder! {
         didSet {
            builderResult.hasPresenceStateSetting = true
         }
    }
    public func getPresenceStateSettingBuilder() -> PresenceStateSetting.Builder {
      if presenceStateSettingBuilder_ == nil {
         presenceStateSettingBuilder_ = PresenceStateSetting.Builder()
         builderResult.presenceStateSetting = presenceStateSettingBuilder_.getMessage()
         if presenceStateSetting != nil {
            try! presenceStateSettingBuilder_.mergeFrom(presenceStateSetting)
         }
      }
      return presenceStateSettingBuilder_
    }
    public func setPresenceStateSetting(_ value:PresenceStateSetting!) -> SetPresenceRequest.Builder {
      self.presenceStateSetting = value
      return self
    }
    public func mergePresenceStateSetting(_ value:PresenceStateSetting) throws -> SetPresenceRequest.Builder {
      if builderResult.hasPresenceStateSetting {
        builderResult.presenceStateSetting = try PresenceStateSetting.builderWithPrototype(builderResult.presenceStateSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.presenceStateSetting = value
      }
      builderResult.hasPresenceStateSetting = true
      return self
    }
    public func clearPresenceStateSetting() -> SetPresenceRequest.Builder {
      presenceStateSettingBuilder_ = nil
      builderResult.hasPresenceStateSetting = false
      builderResult.presenceStateSetting = nil
      return self
    }
    public var hasDndSetting:Bool {
         get {
             return builderResult.hasDndSetting
         }
    }
    public var dndSetting:DndSetting! {
         get {
             if dndSettingBuilder_ != nil {
                builderResult.dndSetting = dndSettingBuilder_.getMessage()
             }
             return builderResult.dndSetting
         }
         set (value) {
             builderResult.hasDndSetting = true
             builderResult.dndSetting = value
         }
    }
    private var dndSettingBuilder_:DndSetting.Builder! {
         didSet {
            builderResult.hasDndSetting = true
         }
    }
    public func getDndSettingBuilder() -> DndSetting.Builder {
      if dndSettingBuilder_ == nil {
         dndSettingBuilder_ = DndSetting.Builder()
         builderResult.dndSetting = dndSettingBuilder_.getMessage()
         if dndSetting != nil {
            try! dndSettingBuilder_.mergeFrom(dndSetting)
         }
      }
      return dndSettingBuilder_
    }
    public func setDndSetting(_ value:DndSetting!) -> SetPresenceRequest.Builder {
      self.dndSetting = value
      return self
    }
    public func mergeDndSetting(_ value:DndSetting) throws -> SetPresenceRequest.Builder {
      if builderResult.hasDndSetting {
        builderResult.dndSetting = try DndSetting.builderWithPrototype(builderResult.dndSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.dndSetting = value
      }
      builderResult.hasDndSetting = true
      return self
    }
    public func clearDndSetting() -> SetPresenceRequest.Builder {
      dndSettingBuilder_ = nil
      builderResult.hasDndSetting = false
      builderResult.dndSetting = nil
      return self
    }
    public var hasDesktopOffSetting:Bool {
         get {
             return builderResult.hasDesktopOffSetting
         }
    }
    public var desktopOffSetting:DesktopOffSetting! {
         get {
             if desktopOffSettingBuilder_ != nil {
                builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
             }
             return builderResult.desktopOffSetting
         }
         set (value) {
             builderResult.hasDesktopOffSetting = true
             builderResult.desktopOffSetting = value
         }
    }
    private var desktopOffSettingBuilder_:DesktopOffSetting.Builder! {
         didSet {
            builderResult.hasDesktopOffSetting = true
         }
    }
    public func getDesktopOffSettingBuilder() -> DesktopOffSetting.Builder {
      if desktopOffSettingBuilder_ == nil {
         desktopOffSettingBuilder_ = DesktopOffSetting.Builder()
         builderResult.desktopOffSetting = desktopOffSettingBuilder_.getMessage()
         if desktopOffSetting != nil {
            try! desktopOffSettingBuilder_.mergeFrom(desktopOffSetting)
         }
      }
      return desktopOffSettingBuilder_
    }
    public func setDesktopOffSetting(_ value:DesktopOffSetting!) -> SetPresenceRequest.Builder {
      self.desktopOffSetting = value
      return self
    }
    public func mergeDesktopOffSetting(_ value:DesktopOffSetting) throws -> SetPresenceRequest.Builder {
      if builderResult.hasDesktopOffSetting {
        builderResult.desktopOffSetting = try DesktopOffSetting.builderWithPrototype(builderResult.desktopOffSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.desktopOffSetting = value
      }
      builderResult.hasDesktopOffSetting = true
      return self
    }
    public func clearDesktopOffSetting() -> SetPresenceRequest.Builder {
      desktopOffSettingBuilder_ = nil
      builderResult.hasDesktopOffSetting = false
      builderResult.desktopOffSetting = nil
      return self
    }
    public var hasMoodSetting:Bool {
         get {
             return builderResult.hasMoodSetting
         }
    }
    public var moodSetting:MoodSetting! {
         get {
             if moodSettingBuilder_ != nil {
                builderResult.moodSetting = moodSettingBuilder_.getMessage()
             }
             return builderResult.moodSetting
         }
         set (value) {
             builderResult.hasMoodSetting = true
             builderResult.moodSetting = value
         }
    }
    private var moodSettingBuilder_:MoodSetting.Builder! {
         didSet {
            builderResult.hasMoodSetting = true
         }
    }
    public func getMoodSettingBuilder() -> MoodSetting.Builder {
      if moodSettingBuilder_ == nil {
         moodSettingBuilder_ = MoodSetting.Builder()
         builderResult.moodSetting = moodSettingBuilder_.getMessage()
         if moodSetting != nil {
            try! moodSettingBuilder_.mergeFrom(moodSetting)
         }
      }
      return moodSettingBuilder_
    }
    public func setMoodSetting(_ value:MoodSetting!) -> SetPresenceRequest.Builder {
      self.moodSetting = value
      return self
    }
    public func mergeMoodSetting(_ value:MoodSetting) throws -> SetPresenceRequest.Builder {
      if builderResult.hasMoodSetting {
        builderResult.moodSetting = try MoodSetting.builderWithPrototype(builderResult.moodSetting).mergeFrom(value).buildPartial()
      } else {
        builderResult.moodSetting = value
      }
      builderResult.hasMoodSetting = true
      return self
    }
    public func clearMoodSetting() -> SetPresenceRequest.Builder {
      moodSettingBuilder_ = nil
      builderResult.hasMoodSetting = false
      builderResult.moodSetting = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetPresenceRequest.Builder {
      builderResult = SetPresenceRequest()
      return self
    }
    public override func clone() throws -> SetPresenceRequest.Builder {
      return try SetPresenceRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetPresenceRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetPresenceRequest {
      let returnMe:SetPresenceRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetPresenceRequest) throws -> SetPresenceRequest.Builder {
      if other == SetPresenceRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasPresenceStateSetting) {
          try mergePresenceStateSetting(other.presenceStateSetting)
      }
      if (other.hasDndSetting) {
          try mergeDndSetting(other.dndSetting)
      }
      if (other.hasDesktopOffSetting) {
          try mergeDesktopOffSetting(other.desktopOffSetting)
      }
      if (other.hasMoodSetting) {
          try mergeMoodSetting(other.moodSetting)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetPresenceRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:PresenceStateSetting.Builder = PresenceStateSetting.Builder()
          if hasPresenceStateSetting {
            try subBuilder.mergeFrom(presenceStateSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          presenceStateSetting = subBuilder.buildPartial()

        case 26:
          let subBuilder:DndSetting.Builder = DndSetting.Builder()
          if hasDndSetting {
            try subBuilder.mergeFrom(dndSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          dndSetting = subBuilder.buildPartial()

        case 42:
          let subBuilder:DesktopOffSetting.Builder = DesktopOffSetting.Builder()
          if hasDesktopOffSetting {
            try subBuilder.mergeFrom(desktopOffSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          desktopOffSetting = subBuilder.buildPartial()

        case 66:
          let subBuilder:MoodSetting.Builder = MoodSetting.Builder()
          if hasMoodSetting {
            try subBuilder.mergeFrom(moodSetting)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          moodSetting = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetPresenceResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetPresenceResponse> {
    var mergedArray = Array<SetPresenceResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetPresenceResponse? {
    return try SetPresenceResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceResponse {
    return try SetPresenceResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetPresenceResponse.Builder {
    return SetPresenceResponse.classBuilder() as! SetPresenceResponse.Builder
  }
  public func getBuilder() -> SetPresenceResponse.Builder {
    return classBuilder() as! SetPresenceResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetPresenceResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetPresenceResponse.Builder()
  }
  public func toBuilder() throws -> SetPresenceResponse.Builder {
    return try SetPresenceResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetPresenceResponse) throws -> SetPresenceResponse.Builder {
    return try SetPresenceResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetPresenceResponse"
  }
  override public func className() -> String {
      return "SetPresenceResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetPresenceResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetPresenceResponse = SetPresenceResponse()
    public func getMessage() -> SetPresenceResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetPresenceResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetPresenceResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetPresenceResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetPresenceResponse.Builder {
      builderResult = SetPresenceResponse()
      return self
    }
    public override func clone() throws -> SetPresenceResponse.Builder {
      return try SetPresenceResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetPresenceResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetPresenceResponse {
      let returnMe:SetPresenceResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetPresenceResponse) throws -> SetPresenceResponse.Builder {
      if other == SetPresenceResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetPresenceResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetPresenceResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetTypingRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var types:TypingType = TypingType.TypingTypeUnknown
  public private(set) var hasTypes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasTypes {
      try output.writeEnum(3, value:types.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetTypingRequest> {
    var mergedArray = Array<SetTypingRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetTypingRequest? {
    return try SetTypingRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingRequest {
    return try SetTypingRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetTypingRequest.Builder {
    return SetTypingRequest.classBuilder() as! SetTypingRequest.Builder
  }
  public func getBuilder() -> SetTypingRequest.Builder {
    return classBuilder() as! SetTypingRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetTypingRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetTypingRequest.Builder()
  }
  public func toBuilder() throws -> SetTypingRequest.Builder {
    return try SetTypingRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetTypingRequest) throws -> SetTypingRequest.Builder {
    return try SetTypingRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetTypingRequest"
  }
  override public func className() -> String {
      return "SetTypingRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetTypingRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetTypingRequest = SetTypingRequest()
    public func getMessage() -> SetTypingRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SetTypingRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SetTypingRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SetTypingRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> SetTypingRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> SetTypingRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> SetTypingRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:TypingType {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:TypingType) -> SetTypingRequest.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> SetTypingRequest.Builder {
         builderResult.hasTypes = false
         builderResult.types = .TypingTypeUnknown
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetTypingRequest.Builder {
      builderResult = SetTypingRequest()
      return self
    }
    public override func clone() throws -> SetTypingRequest.Builder {
      return try SetTypingRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetTypingRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetTypingRequest {
      let returnMe:SetTypingRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetTypingRequest) throws -> SetTypingRequest.Builder {
      if other == SetTypingRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasTypes {
           types = other.types
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          let valueInttypes = try input.readEnum()
          if let enumstypes = TypingType(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueInttypes))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SetTypingResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var timestamp:UInt64 = UInt64(0)

  public private(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasTimestamp {
      try output.writeUInt64(2, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SetTypingResponse> {
    var mergedArray = Array<SetTypingResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SetTypingResponse? {
    return try SetTypingResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingResponse {
    return try SetTypingResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SetTypingResponse.Builder {
    return SetTypingResponse.classBuilder() as! SetTypingResponse.Builder
  }
  public func getBuilder() -> SetTypingResponse.Builder {
    return classBuilder() as! SetTypingResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SetTypingResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SetTypingResponse.Builder()
  }
  public func toBuilder() throws -> SetTypingResponse.Builder {
    return try SetTypingResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SetTypingResponse) throws -> SetTypingResponse.Builder {
    return try SetTypingResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SetTypingResponse"
  }
  override public func className() -> String {
      return "SetTypingResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SetTypingResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SetTypingResponse = SetTypingResponse()
    public func getMessage() -> SetTypingResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SetTypingResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SetTypingResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SetTypingResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> SetTypingResponse.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> SetTypingResponse.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SetTypingResponse.Builder {
      builderResult = SetTypingResponse()
      return self
    }
    public override func clone() throws -> SetTypingResponse.Builder {
      return try SetTypingResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SetTypingResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SetTypingResponse {
      let returnMe:SetTypingResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SetTypingResponse) throws -> SetTypingResponse.Builder {
      if other == SetTypingResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SetTypingResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SetTypingResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          timestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SyncAllNewEventsRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  // Timestamp after which to return all new events.
  public private(set) var lastSyncTimestamp:UInt64 = UInt64(0)

  public private(set) var hasLastSyncTimestamp:Bool = false
  public private(set) var maxResponseSizeBytes:UInt64 = UInt64(0)

  public private(set) var hasMaxResponseSizeBytes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasLastSyncTimestamp {
      try output.writeUInt64(2, value:lastSyncTimestamp)
    }
    if hasMaxResponseSizeBytes {
      try output.writeUInt64(8, value:maxResponseSizeBytes)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasLastSyncTimestamp {
      serialize_size += lastSyncTimestamp.computeUInt64Size(2)
    }
    if hasMaxResponseSizeBytes {
      serialize_size += maxResponseSizeBytes.computeUInt64Size(8)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SyncAllNewEventsRequest> {
    var mergedArray = Array<SyncAllNewEventsRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SyncAllNewEventsRequest? {
    return try SyncAllNewEventsRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsRequest {
    return try SyncAllNewEventsRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SyncAllNewEventsRequest.Builder {
    return SyncAllNewEventsRequest.classBuilder() as! SyncAllNewEventsRequest.Builder
  }
  public func getBuilder() -> SyncAllNewEventsRequest.Builder {
    return classBuilder() as! SyncAllNewEventsRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SyncAllNewEventsRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SyncAllNewEventsRequest.Builder()
  }
  public func toBuilder() throws -> SyncAllNewEventsRequest.Builder {
    return try SyncAllNewEventsRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SyncAllNewEventsRequest) throws -> SyncAllNewEventsRequest.Builder {
    return try SyncAllNewEventsRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLastSyncTimestamp {
      output += "\(indent) lastSyncTimestamp: \(lastSyncTimestamp) \n"
    }
    if hasMaxResponseSizeBytes {
      output += "\(indent) maxResponseSizeBytes: \(maxResponseSizeBytes) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasLastSyncTimestamp {
             hashCode = (hashCode &* 31) &+ lastSyncTimestamp.hashValue
          }
          if hasMaxResponseSizeBytes {
             hashCode = (hashCode &* 31) &+ maxResponseSizeBytes.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SyncAllNewEventsRequest"
  }
  override public func className() -> String {
      return "SyncAllNewEventsRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SyncAllNewEventsRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SyncAllNewEventsRequest = SyncAllNewEventsRequest()
    public func getMessage() -> SyncAllNewEventsRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SyncAllNewEventsRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SyncAllNewEventsRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SyncAllNewEventsRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasLastSyncTimestamp:Bool {
         get {
              return builderResult.hasLastSyncTimestamp
         }
    }
    public var lastSyncTimestamp:UInt64 {
         get {
              return builderResult.lastSyncTimestamp
         }
         set (value) {
             builderResult.hasLastSyncTimestamp = true
             builderResult.lastSyncTimestamp = value
         }
    }
    public func setLastSyncTimestamp(_ value:UInt64) -> SyncAllNewEventsRequest.Builder {
      self.lastSyncTimestamp = value
      return self
    }
    public func clearLastSyncTimestamp() -> SyncAllNewEventsRequest.Builder{
         builderResult.hasLastSyncTimestamp = false
         builderResult.lastSyncTimestamp = UInt64(0)
         return self
    }
    public var hasMaxResponseSizeBytes:Bool {
         get {
              return builderResult.hasMaxResponseSizeBytes
         }
    }
    public var maxResponseSizeBytes:UInt64 {
         get {
              return builderResult.maxResponseSizeBytes
         }
         set (value) {
             builderResult.hasMaxResponseSizeBytes = true
             builderResult.maxResponseSizeBytes = value
         }
    }
    public func setMaxResponseSizeBytes(_ value:UInt64) -> SyncAllNewEventsRequest.Builder {
      self.maxResponseSizeBytes = value
      return self
    }
    public func clearMaxResponseSizeBytes() -> SyncAllNewEventsRequest.Builder{
         builderResult.hasMaxResponseSizeBytes = false
         builderResult.maxResponseSizeBytes = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SyncAllNewEventsRequest.Builder {
      builderResult = SyncAllNewEventsRequest()
      return self
    }
    public override func clone() throws -> SyncAllNewEventsRequest.Builder {
      return try SyncAllNewEventsRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SyncAllNewEventsRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SyncAllNewEventsRequest {
      let returnMe:SyncAllNewEventsRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SyncAllNewEventsRequest) throws -> SyncAllNewEventsRequest.Builder {
      if other == SyncAllNewEventsRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasLastSyncTimestamp {
           lastSyncTimestamp = other.lastSyncTimestamp
      }
      if other.hasMaxResponseSizeBytes {
           maxResponseSizeBytes = other.maxResponseSizeBytes
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SyncAllNewEventsRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 16:
          lastSyncTimestamp = try input.readUInt64()

        case 64:
          maxResponseSizeBytes = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SyncAllNewEventsResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var syncTimestamp:UInt64 = UInt64(0)

  public private(set) var hasSyncTimestamp:Bool = false
  public private(set) var conversationState:Array<ConversationState>  = Array<ConversationState>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitconversationState:Bool = true
    for oneElementconversationState in conversationState {
        if (!oneElementconversationState.isInitialized()) {
            isInitconversationState = false
            break 
        }
    }
    if !isInitconversationState {
     return isInitconversationState
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasSyncTimestamp {
      try output.writeUInt64(2, value:syncTimestamp)
    }
    for oneElementconversationState in conversationState {
        try output.writeMessage(3, value:oneElementconversationState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasSyncTimestamp {
      serialize_size += syncTimestamp.computeUInt64Size(2)
    }
    for oneElementconversationState in conversationState {
        serialize_size += oneElementconversationState.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SyncAllNewEventsResponse> {
    var mergedArray = Array<SyncAllNewEventsResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SyncAllNewEventsResponse? {
    return try SyncAllNewEventsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsResponse {
    return try SyncAllNewEventsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SyncAllNewEventsResponse.Builder {
    return SyncAllNewEventsResponse.classBuilder() as! SyncAllNewEventsResponse.Builder
  }
  public func getBuilder() -> SyncAllNewEventsResponse.Builder {
    return classBuilder() as! SyncAllNewEventsResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SyncAllNewEventsResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SyncAllNewEventsResponse.Builder()
  }
  public func toBuilder() throws -> SyncAllNewEventsResponse.Builder {
    return try SyncAllNewEventsResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SyncAllNewEventsResponse) throws -> SyncAllNewEventsResponse.Builder {
    return try SyncAllNewEventsResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSyncTimestamp {
      output += "\(indent) syncTimestamp: \(syncTimestamp) \n"
    }
    var conversationStateElementIndex:Int = 0
    for oneElementconversationState in conversationState {
        output += "\(indent) conversationState[\(conversationStateElementIndex)] {\n"
        output += try oneElementconversationState.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        conversationStateElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasSyncTimestamp {
             hashCode = (hashCode &* 31) &+ syncTimestamp.hashValue
          }
          for oneElementconversationState in conversationState {
              hashCode = (hashCode &* 31) &+ oneElementconversationState.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SyncAllNewEventsResponse"
  }
  override public func className() -> String {
      return "SyncAllNewEventsResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SyncAllNewEventsResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SyncAllNewEventsResponse = SyncAllNewEventsResponse()
    public func getMessage() -> SyncAllNewEventsResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SyncAllNewEventsResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SyncAllNewEventsResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SyncAllNewEventsResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasSyncTimestamp:Bool {
         get {
              return builderResult.hasSyncTimestamp
         }
    }
    public var syncTimestamp:UInt64 {
         get {
              return builderResult.syncTimestamp
         }
         set (value) {
             builderResult.hasSyncTimestamp = true
             builderResult.syncTimestamp = value
         }
    }
    public func setSyncTimestamp(_ value:UInt64) -> SyncAllNewEventsResponse.Builder {
      self.syncTimestamp = value
      return self
    }
    public func clearSyncTimestamp() -> SyncAllNewEventsResponse.Builder{
         builderResult.hasSyncTimestamp = false
         builderResult.syncTimestamp = UInt64(0)
         return self
    }
    public var conversationState:Array<ConversationState> {
         get {
             return builderResult.conversationState
         }
         set (value) {
             builderResult.conversationState = value
         }
    }
    public func setConversationState(_ value:Array<ConversationState>) -> SyncAllNewEventsResponse.Builder {
      self.conversationState = value
      return self
    }
    public func clearConversationState() -> SyncAllNewEventsResponse.Builder {
      builderResult.conversationState.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SyncAllNewEventsResponse.Builder {
      builderResult = SyncAllNewEventsResponse()
      return self
    }
    public override func clone() throws -> SyncAllNewEventsResponse.Builder {
      return try SyncAllNewEventsResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SyncAllNewEventsResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SyncAllNewEventsResponse {
      let returnMe:SyncAllNewEventsResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SyncAllNewEventsResponse) throws -> SyncAllNewEventsResponse.Builder {
      if other == SyncAllNewEventsResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasSyncTimestamp {
           syncTimestamp = other.syncTimestamp
      }
      if !other.conversationState.isEmpty  {
         builderResult.conversationState += other.conversationState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SyncAllNewEventsResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncAllNewEventsResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          syncTimestamp = try input.readUInt64()

        case 26:
          let subBuilder = ConversationState.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          conversationState += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SyncRecentConversationsRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var maxConversations:UInt64 = UInt64(0)

  public private(set) var hasMaxConversations:Bool = false
  public private(set) var maxEventsPerConversation:UInt64 = UInt64(0)

  public private(set) var hasMaxEventsPerConversation:Bool = false
  private var syncFilterMemoizedSerializedSize:Int32 = 0
  public private(set) var syncFilter:Array<SyncFilter> = Array<SyncFilter>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasMaxConversations {
      try output.writeUInt64(3, value:maxConversations)
    }
    if hasMaxEventsPerConversation {
      try output.writeUInt64(4, value:maxEventsPerConversation)
    }
    for oneValueOfsyncFilter in syncFilter {
        try output.writeEnum(5, value:oneValueOfsyncFilter.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasMaxConversations {
      serialize_size += maxConversations.computeUInt64Size(3)
    }
    if hasMaxEventsPerConversation {
      serialize_size += maxEventsPerConversation.computeUInt64Size(4)
    }
    var dataSizesyncFilter:Int32 = 0
    for oneValueOfsyncFilter in syncFilter {
        dataSizesyncFilter += oneValueOfsyncFilter.rawValue.computeEnumSizeNoTag()
    }
    serialize_size += dataSizesyncFilter
    serialize_size += (1 * Int32(syncFilter.count))
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SyncRecentConversationsRequest> {
    var mergedArray = Array<SyncRecentConversationsRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SyncRecentConversationsRequest? {
    return try SyncRecentConversationsRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsRequest {
    return try SyncRecentConversationsRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SyncRecentConversationsRequest.Builder {
    return SyncRecentConversationsRequest.classBuilder() as! SyncRecentConversationsRequest.Builder
  }
  public func getBuilder() -> SyncRecentConversationsRequest.Builder {
    return classBuilder() as! SyncRecentConversationsRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SyncRecentConversationsRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SyncRecentConversationsRequest.Builder()
  }
  public func toBuilder() throws -> SyncRecentConversationsRequest.Builder {
    return try SyncRecentConversationsRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SyncRecentConversationsRequest) throws -> SyncRecentConversationsRequest.Builder {
    return try SyncRecentConversationsRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMaxConversations {
      output += "\(indent) maxConversations: \(maxConversations) \n"
    }
    if hasMaxEventsPerConversation {
      output += "\(indent) maxEventsPerConversation: \(maxEventsPerConversation) \n"
    }
    var syncFilterElementIndex:Int = 0
    for oneValueOfsyncFilter in syncFilter {
        output += "\(indent) syncFilter[\(syncFilterElementIndex)]: \(oneValueOfsyncFilter.description)\n"
        syncFilterElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasMaxConversations {
             hashCode = (hashCode &* 31) &+ maxConversations.hashValue
          }
          if hasMaxEventsPerConversation {
             hashCode = (hashCode &* 31) &+ maxEventsPerConversation.hashValue
          }
          for oneValueOfsyncFilter in syncFilter {
              hashCode = (hashCode &* 31) &+ Int(oneValueOfsyncFilter.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SyncRecentConversationsRequest"
  }
  override public func className() -> String {
      return "SyncRecentConversationsRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SyncRecentConversationsRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SyncRecentConversationsRequest = SyncRecentConversationsRequest()
    public func getMessage() -> SyncRecentConversationsRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> SyncRecentConversationsRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> SyncRecentConversationsRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> SyncRecentConversationsRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasMaxConversations:Bool {
         get {
              return builderResult.hasMaxConversations
         }
    }
    public var maxConversations:UInt64 {
         get {
              return builderResult.maxConversations
         }
         set (value) {
             builderResult.hasMaxConversations = true
             builderResult.maxConversations = value
         }
    }
    public func setMaxConversations(_ value:UInt64) -> SyncRecentConversationsRequest.Builder {
      self.maxConversations = value
      return self
    }
    public func clearMaxConversations() -> SyncRecentConversationsRequest.Builder{
         builderResult.hasMaxConversations = false
         builderResult.maxConversations = UInt64(0)
         return self
    }
    public var hasMaxEventsPerConversation:Bool {
         get {
              return builderResult.hasMaxEventsPerConversation
         }
    }
    public var maxEventsPerConversation:UInt64 {
         get {
              return builderResult.maxEventsPerConversation
         }
         set (value) {
             builderResult.hasMaxEventsPerConversation = true
             builderResult.maxEventsPerConversation = value
         }
    }
    public func setMaxEventsPerConversation(_ value:UInt64) -> SyncRecentConversationsRequest.Builder {
      self.maxEventsPerConversation = value
      return self
    }
    public func clearMaxEventsPerConversation() -> SyncRecentConversationsRequest.Builder{
         builderResult.hasMaxEventsPerConversation = false
         builderResult.maxEventsPerConversation = UInt64(0)
         return self
    }
    public var syncFilter:Array<SyncFilter> {
        get {
            return builderResult.syncFilter
        }
        set (value) {
            builderResult.syncFilter = value
        }
    }
    public func setSyncFilter(_ value:Array<SyncFilter>) -> SyncRecentConversationsRequest.Builder {
      self.syncFilter = value
      return self
    }
    public func clearSyncFilter() -> SyncRecentConversationsRequest.Builder {
      builderResult.syncFilter.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SyncRecentConversationsRequest.Builder {
      builderResult = SyncRecentConversationsRequest()
      return self
    }
    public override func clone() throws -> SyncRecentConversationsRequest.Builder {
      return try SyncRecentConversationsRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SyncRecentConversationsRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SyncRecentConversationsRequest {
      let returnMe:SyncRecentConversationsRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SyncRecentConversationsRequest) throws -> SyncRecentConversationsRequest.Builder {
      if other == SyncRecentConversationsRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if other.hasMaxConversations {
           maxConversations = other.maxConversations
      }
      if other.hasMaxEventsPerConversation {
           maxEventsPerConversation = other.maxEventsPerConversation
      }
      if !other.syncFilter.isEmpty {
         builderResult.syncFilter += other.syncFilter
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SyncRecentConversationsRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 24:
          maxConversations = try input.readUInt64()

        case 32:
          maxEventsPerConversation = try input.readUInt64()

        case 40:
          let valueIntsyncFilter = try input.readEnum()
          if let enumssyncFilter = SyncFilter(rawValue:valueIntsyncFilter) {
               builderResult.syncFilter += [enumssyncFilter]
          } else {
               try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntsyncFilter))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SyncRecentConversationsResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  public private(set) var syncTimestamp:UInt64 = UInt64(0)

  public private(set) var hasSyncTimestamp:Bool = false
  public private(set) var conversationState:Array<ConversationState>  = Array<ConversationState>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitconversationState:Bool = true
    for oneElementconversationState in conversationState {
        if (!oneElementconversationState.isInitialized()) {
            isInitconversationState = false
            break 
        }
    }
    if !isInitconversationState {
     return isInitconversationState
     }
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    if hasSyncTimestamp {
      try output.writeUInt64(2, value:syncTimestamp)
    }
    for oneElementconversationState in conversationState {
        try output.writeMessage(3, value:oneElementconversationState)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    if hasSyncTimestamp {
      serialize_size += syncTimestamp.computeUInt64Size(2)
    }
    for oneElementconversationState in conversationState {
        serialize_size += oneElementconversationState.computeMessageSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<SyncRecentConversationsResponse> {
    var mergedArray = Array<SyncRecentConversationsResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> SyncRecentConversationsResponse? {
    return try SyncRecentConversationsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsResponse {
    return try SyncRecentConversationsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SyncRecentConversationsResponse.Builder {
    return SyncRecentConversationsResponse.classBuilder() as! SyncRecentConversationsResponse.Builder
  }
  public func getBuilder() -> SyncRecentConversationsResponse.Builder {
    return classBuilder() as! SyncRecentConversationsResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SyncRecentConversationsResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SyncRecentConversationsResponse.Builder()
  }
  public func toBuilder() throws -> SyncRecentConversationsResponse.Builder {
    return try SyncRecentConversationsResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SyncRecentConversationsResponse) throws -> SyncRecentConversationsResponse.Builder {
    return try SyncRecentConversationsResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSyncTimestamp {
      output += "\(indent) syncTimestamp: \(syncTimestamp) \n"
    }
    var conversationStateElementIndex:Int = 0
    for oneElementconversationState in conversationState {
        output += "\(indent) conversationState[\(conversationStateElementIndex)] {\n"
        output += try oneElementconversationState.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        conversationStateElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          if hasSyncTimestamp {
             hashCode = (hashCode &* 31) &+ syncTimestamp.hashValue
          }
          for oneElementconversationState in conversationState {
              hashCode = (hashCode &* 31) &+ oneElementconversationState.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SyncRecentConversationsResponse"
  }
  override public func className() -> String {
      return "SyncRecentConversationsResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SyncRecentConversationsResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SyncRecentConversationsResponse = SyncRecentConversationsResponse()
    public func getMessage() -> SyncRecentConversationsResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> SyncRecentConversationsResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> SyncRecentConversationsResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> SyncRecentConversationsResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    public var hasSyncTimestamp:Bool {
         get {
              return builderResult.hasSyncTimestamp
         }
    }
    public var syncTimestamp:UInt64 {
         get {
              return builderResult.syncTimestamp
         }
         set (value) {
             builderResult.hasSyncTimestamp = true
             builderResult.syncTimestamp = value
         }
    }
    public func setSyncTimestamp(_ value:UInt64) -> SyncRecentConversationsResponse.Builder {
      self.syncTimestamp = value
      return self
    }
    public func clearSyncTimestamp() -> SyncRecentConversationsResponse.Builder{
         builderResult.hasSyncTimestamp = false
         builderResult.syncTimestamp = UInt64(0)
         return self
    }
    public var conversationState:Array<ConversationState> {
         get {
             return builderResult.conversationState
         }
         set (value) {
             builderResult.conversationState = value
         }
    }
    public func setConversationState(_ value:Array<ConversationState>) -> SyncRecentConversationsResponse.Builder {
      self.conversationState = value
      return self
    }
    public func clearConversationState() -> SyncRecentConversationsResponse.Builder {
      builderResult.conversationState.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SyncRecentConversationsResponse.Builder {
      builderResult = SyncRecentConversationsResponse()
      return self
    }
    public override func clone() throws -> SyncRecentConversationsResponse.Builder {
      return try SyncRecentConversationsResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SyncRecentConversationsResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SyncRecentConversationsResponse {
      let returnMe:SyncRecentConversationsResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SyncRecentConversationsResponse) throws -> SyncRecentConversationsResponse.Builder {
      if other == SyncRecentConversationsResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      if other.hasSyncTimestamp {
           syncTimestamp = other.syncTimestamp
      }
      if !other.conversationState.isEmpty  {
         builderResult.conversationState += other.conversationState
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SyncRecentConversationsResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SyncRecentConversationsResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        case 16:
          syncTimestamp = try input.readUInt64()

        case 26:
          let subBuilder = ConversationState.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          conversationState += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UpdateWatermarkRequest : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var requestHeader:RequestHeader!
  public private(set) var hasRequestHeader:Bool = false
  public private(set) var conversationId:ConversationId!
  public private(set) var hasConversationId:Bool = false
  public private(set) var lastReadTimestamp:UInt64 = UInt64(0)

  public private(set) var hasLastReadTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequestHeader {
      try output.writeMessage(1, value:requestHeader)
    }
    if hasConversationId {
      try output.writeMessage(2, value:conversationId)
    }
    if hasLastReadTimestamp {
      try output.writeUInt64(3, value:lastReadTimestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequestHeader {
        if let varSizerequestHeader = requestHeader?.computeMessageSize(1) {
            serialize_size += varSizerequestHeader
        }
    }
    if hasConversationId {
        if let varSizeconversationId = conversationId?.computeMessageSize(2) {
            serialize_size += varSizeconversationId
        }
    }
    if hasLastReadTimestamp {
      serialize_size += lastReadTimestamp.computeUInt64Size(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<UpdateWatermarkRequest> {
    var mergedArray = Array<UpdateWatermarkRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> UpdateWatermarkRequest? {
    return try UpdateWatermarkRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkRequest {
    return try UpdateWatermarkRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UpdateWatermarkRequest.Builder {
    return UpdateWatermarkRequest.classBuilder() as! UpdateWatermarkRequest.Builder
  }
  public func getBuilder() -> UpdateWatermarkRequest.Builder {
    return classBuilder() as! UpdateWatermarkRequest.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UpdateWatermarkRequest.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UpdateWatermarkRequest.Builder()
  }
  public func toBuilder() throws -> UpdateWatermarkRequest.Builder {
    return try UpdateWatermarkRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:UpdateWatermarkRequest) throws -> UpdateWatermarkRequest.Builder {
    return try UpdateWatermarkRequest.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasRequestHeader {
      output += "\(indent) requestHeader {\n"
      if let outDescRequestHeader = requestHeader {
        output += try outDescRequestHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasConversationId {
      output += "\(indent) conversationId {\n"
      if let outDescConversationId = conversationId {
        output += try outDescConversationId.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLastReadTimestamp {
      output += "\(indent) lastReadTimestamp: \(lastReadTimestamp) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequestHeader {
              if let hashValuerequestHeader = requestHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequestHeader
              }
          }
          if hasConversationId {
              if let hashValueconversationId = conversationId?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueconversationId
              }
          }
          if hasLastReadTimestamp {
             hashCode = (hashCode &* 31) &+ lastReadTimestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UpdateWatermarkRequest"
  }
  override public func className() -> String {
      return "UpdateWatermarkRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UpdateWatermarkRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UpdateWatermarkRequest = UpdateWatermarkRequest()
    public func getMessage() -> UpdateWatermarkRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequestHeader:Bool {
         get {
             return builderResult.hasRequestHeader
         }
    }
    public var requestHeader:RequestHeader! {
         get {
             if requestHeaderBuilder_ != nil {
                builderResult.requestHeader = requestHeaderBuilder_.getMessage()
             }
             return builderResult.requestHeader
         }
         set (value) {
             builderResult.hasRequestHeader = true
             builderResult.requestHeader = value
         }
    }
    private var requestHeaderBuilder_:RequestHeader.Builder! {
         didSet {
            builderResult.hasRequestHeader = true
         }
    }
    public func getRequestHeaderBuilder() -> RequestHeader.Builder {
      if requestHeaderBuilder_ == nil {
         requestHeaderBuilder_ = RequestHeader.Builder()
         builderResult.requestHeader = requestHeaderBuilder_.getMessage()
         if requestHeader != nil {
            try! requestHeaderBuilder_.mergeFrom(requestHeader)
         }
      }
      return requestHeaderBuilder_
    }
    public func setRequestHeader(_ value:RequestHeader!) -> UpdateWatermarkRequest.Builder {
      self.requestHeader = value
      return self
    }
    public func mergeRequestHeader(_ value:RequestHeader) throws -> UpdateWatermarkRequest.Builder {
      if builderResult.hasRequestHeader {
        builderResult.requestHeader = try RequestHeader.builderWithPrototype(builderResult.requestHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.requestHeader = value
      }
      builderResult.hasRequestHeader = true
      return self
    }
    public func clearRequestHeader() -> UpdateWatermarkRequest.Builder {
      requestHeaderBuilder_ = nil
      builderResult.hasRequestHeader = false
      builderResult.requestHeader = nil
      return self
    }
    public var hasConversationId:Bool {
         get {
             return builderResult.hasConversationId
         }
    }
    public var conversationId:ConversationId! {
         get {
             if conversationIdBuilder_ != nil {
                builderResult.conversationId = conversationIdBuilder_.getMessage()
             }
             return builderResult.conversationId
         }
         set (value) {
             builderResult.hasConversationId = true
             builderResult.conversationId = value
         }
    }
    private var conversationIdBuilder_:ConversationId.Builder! {
         didSet {
            builderResult.hasConversationId = true
         }
    }
    public func getConversationIdBuilder() -> ConversationId.Builder {
      if conversationIdBuilder_ == nil {
         conversationIdBuilder_ = ConversationId.Builder()
         builderResult.conversationId = conversationIdBuilder_.getMessage()
         if conversationId != nil {
            try! conversationIdBuilder_.mergeFrom(conversationId)
         }
      }
      return conversationIdBuilder_
    }
    public func setConversationId(_ value:ConversationId!) -> UpdateWatermarkRequest.Builder {
      self.conversationId = value
      return self
    }
    public func mergeConversationId(_ value:ConversationId) throws -> UpdateWatermarkRequest.Builder {
      if builderResult.hasConversationId {
        builderResult.conversationId = try ConversationId.builderWithPrototype(builderResult.conversationId).mergeFrom(value).buildPartial()
      } else {
        builderResult.conversationId = value
      }
      builderResult.hasConversationId = true
      return self
    }
    public func clearConversationId() -> UpdateWatermarkRequest.Builder {
      conversationIdBuilder_ = nil
      builderResult.hasConversationId = false
      builderResult.conversationId = nil
      return self
    }
    public var hasLastReadTimestamp:Bool {
         get {
              return builderResult.hasLastReadTimestamp
         }
    }
    public var lastReadTimestamp:UInt64 {
         get {
              return builderResult.lastReadTimestamp
         }
         set (value) {
             builderResult.hasLastReadTimestamp = true
             builderResult.lastReadTimestamp = value
         }
    }
    public func setLastReadTimestamp(_ value:UInt64) -> UpdateWatermarkRequest.Builder {
      self.lastReadTimestamp = value
      return self
    }
    public func clearLastReadTimestamp() -> UpdateWatermarkRequest.Builder{
         builderResult.hasLastReadTimestamp = false
         builderResult.lastReadTimestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UpdateWatermarkRequest.Builder {
      builderResult = UpdateWatermarkRequest()
      return self
    }
    public override func clone() throws -> UpdateWatermarkRequest.Builder {
      return try UpdateWatermarkRequest.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UpdateWatermarkRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UpdateWatermarkRequest {
      let returnMe:UpdateWatermarkRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:UpdateWatermarkRequest) throws -> UpdateWatermarkRequest.Builder {
      if other == UpdateWatermarkRequest() {
       return self
      }
      if (other.hasRequestHeader) {
          try mergeRequestHeader(other.requestHeader)
      }
      if (other.hasConversationId) {
          try mergeConversationId(other.conversationId)
      }
      if other.hasLastReadTimestamp {
           lastReadTimestamp = other.lastReadTimestamp
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> UpdateWatermarkRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:RequestHeader.Builder = RequestHeader.Builder()
          if hasRequestHeader {
            try subBuilder.mergeFrom(requestHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          requestHeader = subBuilder.buildPartial()

        case 18:
          let subBuilder:ConversationId.Builder = ConversationId.Builder()
          if hasConversationId {
            try subBuilder.mergeFrom(conversationId)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          conversationId = subBuilder.buildPartial()

        case 24:
          lastReadTimestamp = try input.readUInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UpdateWatermarkResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var responseHeader:ResponseHeader!
  public private(set) var hasResponseHeader:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasResponseHeader {
      try output.writeMessage(1, value:responseHeader)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasResponseHeader {
        if let varSizeresponseHeader = responseHeader?.computeMessageSize(1) {
            serialize_size += varSizeresponseHeader
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:NSInputStream) throws -> Array<UpdateWatermarkResponse> {
    var mergedArray = Array<UpdateWatermarkResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:NSInputStream) throws -> UpdateWatermarkResponse? {
    return try UpdateWatermarkResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:NSData) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromData(data, extensionRegistry:HangoutsRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:NSData, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkResponse {
    return try UpdateWatermarkResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UpdateWatermarkResponse.Builder {
    return UpdateWatermarkResponse.classBuilder() as! UpdateWatermarkResponse.Builder
  }
  public func getBuilder() -> UpdateWatermarkResponse.Builder {
    return classBuilder() as! UpdateWatermarkResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UpdateWatermarkResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UpdateWatermarkResponse.Builder()
  }
  public func toBuilder() throws -> UpdateWatermarkResponse.Builder {
    return try UpdateWatermarkResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:UpdateWatermarkResponse) throws -> UpdateWatermarkResponse.Builder {
    return try UpdateWatermarkResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(_ indent:String) throws -> String {
    var output:String = ""
    if hasResponseHeader {
      output += "\(indent) responseHeader {\n"
      if let outDescResponseHeader = responseHeader {
        output += try outDescResponseHeader.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasResponseHeader {
              if let hashValueresponseHeader = responseHeader?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresponseHeader
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UpdateWatermarkResponse"
  }
  override public func className() -> String {
      return "UpdateWatermarkResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UpdateWatermarkResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UpdateWatermarkResponse = UpdateWatermarkResponse()
    public func getMessage() -> UpdateWatermarkResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasResponseHeader:Bool {
         get {
             return builderResult.hasResponseHeader
         }
    }
    public var responseHeader:ResponseHeader! {
         get {
             if responseHeaderBuilder_ != nil {
                builderResult.responseHeader = responseHeaderBuilder_.getMessage()
             }
             return builderResult.responseHeader
         }
         set (value) {
             builderResult.hasResponseHeader = true
             builderResult.responseHeader = value
         }
    }
    private var responseHeaderBuilder_:ResponseHeader.Builder! {
         didSet {
            builderResult.hasResponseHeader = true
         }
    }
    public func getResponseHeaderBuilder() -> ResponseHeader.Builder {
      if responseHeaderBuilder_ == nil {
         responseHeaderBuilder_ = ResponseHeader.Builder()
         builderResult.responseHeader = responseHeaderBuilder_.getMessage()
         if responseHeader != nil {
            try! responseHeaderBuilder_.mergeFrom(responseHeader)
         }
      }
      return responseHeaderBuilder_
    }
    public func setResponseHeader(_ value:ResponseHeader!) -> UpdateWatermarkResponse.Builder {
      self.responseHeader = value
      return self
    }
    public func mergeResponseHeader(_ value:ResponseHeader) throws -> UpdateWatermarkResponse.Builder {
      if builderResult.hasResponseHeader {
        builderResult.responseHeader = try ResponseHeader.builderWithPrototype(builderResult.responseHeader).mergeFrom(value).buildPartial()
      } else {
        builderResult.responseHeader = value
      }
      builderResult.hasResponseHeader = true
      return self
    }
    public func clearResponseHeader() -> UpdateWatermarkResponse.Builder {
      responseHeaderBuilder_ = nil
      builderResult.hasResponseHeader = false
      builderResult.responseHeader = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UpdateWatermarkResponse.Builder {
      builderResult = UpdateWatermarkResponse()
      return self
    }
    public override func clone() throws -> UpdateWatermarkResponse.Builder {
      return try UpdateWatermarkResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UpdateWatermarkResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UpdateWatermarkResponse {
      let returnMe:UpdateWatermarkResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:UpdateWatermarkResponse) throws -> UpdateWatermarkResponse.Builder {
      if other == UpdateWatermarkResponse() {
       return self
      }
      if (other.hasResponseHeader) {
          try mergeResponseHeader(other.responseHeader)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> UpdateWatermarkResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UpdateWatermarkResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:ResponseHeader.Builder = ResponseHeader.Builder()
          if hasResponseHeader {
            try subBuilder.mergeFrom(responseHeader)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          responseHeader = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
